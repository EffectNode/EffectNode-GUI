[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>FUNdamentals</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n\n    <!--\n    -->\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  \n    <style type=\"text/css\">\n      \n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    <!--DO_NOT_REMOVE_ME____AUTO_INIT-->\n  </body>\n</html>"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"//\nimport '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.onmessage = (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}\n\nwindow.addEventListener('en.slider', ({ detail }) => {\n  console.log(detail);\n  \n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"}]