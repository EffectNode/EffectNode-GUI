{"output":{"html":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  <script>\n  !function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var c=\"function\"==typeof require&&require;if(!u&&c)return c(o,!0);if(i)return i(o,!0);var a=new Error(\"Cannot find module '\"+o+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(n){var r=t[o][1][n];return s(r||n)},f,f.exports,e,t,n,r)}return n[o].exports}for(var i=\"function\"==typeof require&&require,o=0;o<r.length;o++)s(r[o]);return s}({1:[function(t,n,r){(function(n){\"use strict\";function define(t,n,e){t[n]||Object[r](t,n,{writable:!0,configurable:!0,value:e})}if(t(327),t(328),t(2),n._babelPolyfill)throw new Error(\"only one instance of babel-polyfill is allowed\");n._babelPolyfill=!0;var r=\"defineProperty\";define(String.prototype,\"padLeft\",\"\".padStart),define(String.prototype,\"padRight\",\"\".padEnd),\"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill\".split(\",\").forEach(function(t){[][t]&&define(Array,t,Function.call.bind([][t]))})}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{2:2,327:327,328:328}],2:[function(t,n,r){t(130),n.exports=t(23).RegExp.escape},{130:130,23:23}],3:[function(t,n,r){n.exports=function(t){if(\"function\"!=typeof t)throw TypeError(t+\" is not a function!\");return t}},{}],4:[function(t,n,r){var e=t(18);n.exports=function(t,n){if(\"number\"!=typeof t&&\"Number\"!=e(t))throw TypeError(n);return+t}},{18:18}],5:[function(t,n,r){var e=t(128)(\"unscopables\"),i=Array.prototype;void 0==i[e]&&t(42)(i,e,{}),n.exports=function(t){i[e][t]=!0}},{128:128,42:42}],6:[function(t,n,r){n.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+\": incorrect invocation!\");return t}},{}],7:[function(t,n,r){var e=t(51);n.exports=function(t){if(!e(t))throw TypeError(t+\" is not an object!\");return t}},{51:51}],8:[function(t,n,r){\"use strict\";var e=t(119),i=t(114),o=t(118);n.exports=[].copyWithin||function copyWithin(t,n){var r=e(this),u=o(r.length),c=i(t,u),a=i(n,u),f=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===f?u:i(f,u))-a,u-c),l=1;for(a<c&&c<a+s&&(l=-1,a+=s-1,c+=s-1);s-- >0;)a in r?r[c]=r[a]:delete r[c],c+=l,a+=l;return r}},{114:114,118:118,119:119}],9:[function(t,n,r){\"use strict\";var e=t(119),i=t(114),o=t(118);n.exports=function fill(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),a=u>2?arguments[2]:void 0,f=void 0===a?r:i(a,r);f>c;)n[c++]=t;return n}},{114:114,118:118,119:119}],10:[function(t,n,r){var e=t(39);n.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},{39:39}],11:[function(t,n,r){var e=t(117),i=t(118),o=t(114);n.exports=function(t){return function(n,r,u){var c,a=e(n),f=i(a.length),s=o(u,f);if(t&&r!=r){for(;f>s;)if((c=a[s++])!=c)return!0}else for(;f>s;s++)if((t||s in a)&&a[s]===r)return t||s||0;return!t&&-1}}},{114:114,117:117,118:118}],12:[function(t,n,r){var e=t(25),i=t(47),o=t(119),u=t(118),c=t(15);n.exports=function(t,n){var r=1==t,a=2==t,f=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),m=i(g),b=e(c,p,3),x=u(m.length),S=0,w=r?v(n,x):a?v(n,0):void 0;x>S;S++)if((h||S in m)&&(d=m[S],y=b(d,S,g),t))if(r)w[S]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return S;case 2:w.push(d)}else if(s)return!1;return l?-1:f||s?s:w}}},{118:118,119:119,15:15,25:25,47:47}],13:[function(t,n,r){var e=t(3),i=t(119),o=t(47),u=t(118);n.exports=function(t,n,r,c,a){e(n);var f=i(t),s=o(f),l=u(f.length),h=a?l-1:0,v=a?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,a?h<0:l<=h)throw TypeError(\"Reduce of empty array with no initial value\")}for(;a?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,f));return c}},{118:118,119:119,3:3,47:47}],14:[function(t,n,r){var e=t(51),i=t(49),o=t(128)(\"species\");n.exports=function(t){var n;return i(t)&&(n=t.constructor,\"function\"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},{128:128,49:49,51:51}],15:[function(t,n,r){var e=t(14);n.exports=function(t,n){return new(e(t))(n)}},{14:14}],16:[function(t,n,r){\"use strict\";var e=t(3),i=t(51),o=t(46),u=[].slice,c={},a=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]=\"a[\"+i+\"]\";c[n]=Function(\"F,a\",\"return new F(\"+e.join(\",\")+\")\")}return c[n](t,r)};n.exports=Function.bind||function bind(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?a(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},{3:3,46:46,51:51}],17:[function(t,n,r){var e=t(18),i=t(128)(\"toStringTag\"),o=\"Arguments\"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};n.exports=function(t){var n,r,c;return void 0===t?\"Undefined\":null===t?\"Null\":\"string\"==typeof(r=u(n=Object(t),i))?r:o?e(n):\"Object\"==(c=e(n))&&\"function\"==typeof n.callee?\"Arguments\":c}},{128:128,18:18}],18:[function(t,n,r){var e={}.toString;n.exports=function(t){return e.call(t).slice(8,-1)}},{}],19:[function(t,n,r){\"use strict\";var e=t(72).f,i=t(71),o=t(93),u=t(25),c=t(6),a=t(39),f=t(55),s=t(57),l=t(100),h=t(29),v=t(66).fastKey,p=t(125),d=h?\"_s\":\"size\",y=function(t,n){var r,e=v(n);if(\"F\"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};n.exports={getConstructor:function(t,n,r,f){var s=t(function(t,e){c(t,s,n,\"_i\"),t._t=n,t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[f],t)});return o(s.prototype,{clear:function clear(){for(var t=p(this,n),r=t._i,e=t._f;e;e=e.n)e.r=!0,e.p&&(e.p=e.p.n=void 0),delete r[e.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var r=p(this,n),e=y(r,t);if(e){var i=e.n,o=e.p;delete r._i[e.i],e.r=!0,o&&(o.n=i),i&&(i.p=o),r._f==e&&(r._f=i),r._l==e&&(r._l=o),r[d]--}return!!e},forEach:function forEach(t){p(this,n);for(var r,e=u(t,arguments.length>1?arguments[1]:void 0,3);r=r?r.n:this._f;)for(e(r.v,r.k,this);r&&r.r;)r=r.p},has:function has(t){return!!y(p(this,n),t)}}),h&&e(s.prototype,\"size\",{get:function(){return p(this,n)[d]}}),s},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=v(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,\"F\"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){f(t,n,function(t,r){this._t=p(t,n),this._k=r,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?\"keys\"==n?s(0,r.k):\"values\"==n?s(0,r.v):s(0,[r.k,r.v]):(t._t=void 0,s(1))},r?\"entries\":\"values\",!r,!0),l(n)}}},{100:100,125:125,25:25,29:29,39:39,55:55,57:57,6:6,66:66,71:71,72:72,93:93}],20:[function(t,n,r){var e=t(17),i=t(10);n.exports=function(t){return function toJSON(){if(e(this)!=t)throw TypeError(t+\"#toJSON isn't generic\");return i(this)}}},{10:10,17:17}],21:[function(t,n,r){\"use strict\";var e=t(93),i=t(66).getWeak,o=t(7),u=t(51),c=t(6),a=t(39),f=t(12),s=t(41),l=t(125),h=f(5),v=f(6),p=0,d=function(t){return t._l||(t._l=new y)},y=function(){this.a=[]},g=function(t,n){return h(t.a,function(t){return t[0]===n})};y.prototype={get:function(t){var n=g(this,t);if(n)return n[1]},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=v(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},n.exports={getConstructor:function(t,n,r,o){var f=t(function(t,e){c(t,f,n,\"_i\"),t._t=n,t._i=p++,t._l=void 0,void 0!=e&&a(e,r,t[o],t)});return e(f.prototype,{delete:function(t){if(!u(t))return!1;var r=i(t);return!0===r?d(l(this,n)).delete(t):r&&s(r,this._i)&&delete r[this._i]},has:function has(t){if(!u(t))return!1;var r=i(t);return!0===r?d(l(this,n)).has(t):r&&s(r,this._i)}}),f},def:function(t,n,r){var e=i(o(n),!0);return!0===e?d(t).set(n,r):e[t._i]=r,t},ufstore:d}},{12:12,125:125,39:39,41:41,51:51,6:6,66:66,7:7,93:93}],22:[function(t,n,r){\"use strict\";var e=t(40),i=t(33),o=t(94),u=t(93),c=t(66),a=t(39),f=t(6),s=t(51),l=t(35),h=t(56),v=t(101),p=t(45);n.exports=function(t,n,r,d,y,g){var m=e[t],b=m,x=y?\"set\":\"add\",S=b&&b.prototype,w={},_=function(t){var n=S[t];o(S,t,\"delete\"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:\"has\"==t?function has(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:\"get\"==t?function get(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:\"add\"==t?function add(t){return n.call(this,0===t?0:t),this}:function set(t,r){return n.call(this,0===t?0:t,r),this})};if(\"function\"==typeof b&&(g||S.forEach&&!l(function(){(new b).entries().next()}))){var E=new b,O=E[x](g?{}:-0,1)!=E,P=l(function(){E.has(1)}),M=h(function(t){new b(t)}),F=!g&&l(function(){for(var t=new b,n=5;n--;)t[x](n,n);return!t.has(-0)});M||(b=n(function(n,r){f(n,b,t);var e=p(new m,n,b);return void 0!=r&&a(r,y,e[x],e),e}),b.prototype=S,S.constructor=b),(P||F)&&(_(\"delete\"),_(\"has\"),y&&_(\"get\")),(F||O)&&_(x),g&&S.clear&&delete S.clear}else b=d.getConstructor(n,t,y,x),u(b.prototype,r),c.NEED=!0;return v(b,t),w[t]=b,i(i.G+i.W+i.F*(b!=m),w),g||d.setStrong(b,t,y),b}},{101:101,33:33,35:35,39:39,40:40,45:45,51:51,56:56,6:6,66:66,93:93,94:94}],23:[function(t,n,r){var e=n.exports={version:\"2.5.0\"};\"number\"==typeof __e&&(__e=e)},{}],24:[function(t,n,r){\"use strict\";var e=t(72),i=t(92);n.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},{72:72,92:92}],25:[function(t,n,r){var e=t(3);n.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},{3:3}],26:[function(t,n,r){\"use strict\";var e=t(35),i=Date.prototype.getTime,o=Date.prototype.toISOString,u=function(t){return t>9?t:\"0\"+t};n.exports=e(function(){return\"0385-07-25T07:06:39.999Z\"!=o.call(new Date(-5e13-1))})||!e(function(){o.call(new Date(NaN))})?function toISOString(){if(!isFinite(i.call(this)))throw RangeError(\"Invalid time value\");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?\"-\":n>9999?\"+\":\"\";return e+(\"00000\"+Math.abs(n)).slice(e?-6:-4)+\"-\"+u(t.getUTCMonth()+1)+\"-\"+u(t.getUTCDate())+\"T\"+u(t.getUTCHours())+\":\"+u(t.getUTCMinutes())+\":\"+u(t.getUTCSeconds())+\".\"+(r>99?r:\"0\"+u(r))+\"Z\"}:o},{35:35}],27:[function(t,n,r){\"use strict\";var e=t(7),i=t(120);n.exports=function(t){if(\"string\"!==t&&\"number\"!==t&&\"default\"!==t)throw TypeError(\"Incorrect hint\");return i(e(this),\"number\"!=t)}},{120:120,7:7}],28:[function(t,n,r){n.exports=function(t){if(void 0==t)throw TypeError(\"Can't call method on  \"+t);return t}},{}],29:[function(t,n,r){n.exports=!t(35)(function(){return 7!=Object.defineProperty({},\"a\",{get:function(){return 7}}).a})},{35:35}],30:[function(t,n,r){var e=t(51),i=t(40).document,o=e(i)&&e(i.createElement);n.exports=function(t){return o?i.createElement(t):{}}},{40:40,51:51}],31:[function(t,n,r){n.exports=\"constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\".split(\",\")},{}],32:[function(t,n,r){var e=t(81),i=t(78),o=t(82);n.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),a=o.f,f=0;c.length>f;)a.call(t,u=c[f++])&&n.push(u);return n}},{78:78,81:81,82:82}],33:[function(t,n,r){var e=t(40),i=t(23),o=t(42),u=t(94),c=t(25),a=function(t,n,r){var f,s,l,h,v=t&a.F,p=t&a.G,d=t&a.S,y=t&a.P,g=t&a.B,m=p?e:d?e[n]||(e[n]={}):(e[n]||{}).prototype,b=p?i:i[n]||(i[n]={}),x=b.prototype||(b.prototype={});p&&(r=n);for(f in r)s=!v&&m&&void 0!==m[f],l=(s?m:r)[f],h=g&&s?c(l,e):y&&\"function\"==typeof l?c(Function.call,l):l,m&&u(m,f,l,t&a.U),b[f]!=l&&o(b,f,h),y&&x[f]!=l&&(x[f]=l)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,n.exports=a},{23:23,25:25,40:40,42:42,94:94}],34:[function(t,n,r){var e=t(128)(\"match\");n.exports=function(t){var n=/./;try{\"/./\"[t](n)}catch(r){try{return n[e]=!1,!\"/./\"[t](n)}catch(t){}}return!0}},{128:128}],35:[function(t,n,r){n.exports=function(t){try{return!!t()}catch(t){return!0}}},{}],36:[function(t,n,r){\"use strict\";var e=t(42),i=t(94),o=t(35),u=t(28),c=t(128);n.exports=function(t,n,r){var a=c(t),f=r(u,a,\"\"[t]),s=f[0],l=f[1];o(function(){var n={};return n[a]=function(){return 7},7!=\"\"[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,a,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}},{128:128,28:28,35:35,42:42,94:94}],37:[function(t,n,r){\"use strict\";var e=t(7);n.exports=function(){var t=e(this),n=\"\";return t.global&&(n+=\"g\"),t.ignoreCase&&(n+=\"i\"),t.multiline&&(n+=\"m\"),t.unicode&&(n+=\"u\"),t.sticky&&(n+=\"y\"),n}},{7:7}],38:[function(t,n,r){\"use strict\";function flattenIntoArray(t,n,r,a,f,s,l,h){for(var v,p,d=f,y=0,g=!!l&&u(l,h,3);y<a;){if(y in r){if(v=g?g(r[y],y,n):r[y],p=!1,i(v)&&(p=v[c],p=void 0!==p?!!p:e(v)),p&&s>0)d=flattenIntoArray(t,n,v,o(v.length),d,s-1)-1;else{if(d>=9007199254740991)throw TypeError();t[d]=v}d++}y++}return d}var e=t(49),i=t(51),o=t(118),u=t(25),c=t(128)(\"isConcatSpreadable\");n.exports=flattenIntoArray},{118:118,128:128,25:25,49:49,51:51}],39:[function(t,n,r){var e=t(25),i=t(53),o=t(48),u=t(7),c=t(118),a=t(129),f={},s={},r=n.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:a(t),m=e(r,l,n?2:1),b=0;if(\"function\"!=typeof g)throw TypeError(t+\" is not iterable!\");if(o(g)){for(v=c(t.length);v>b;b++)if((y=n?m(u(p=t[b])[0],p[1]):m(t[b]))===f||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,m,p.value,n))===f||y===s)return y};r.BREAK=f,r.RETURN=s},{118:118,129:129,25:25,48:48,53:53,7:7}],40:[function(t,n,r){var e=n.exports=\"undefined\"!=typeof window&&window.Math==Math?window:\"undefined\"!=typeof self&&self.Math==Math?self:Function(\"return this\")();\"number\"==typeof __g&&(__g=e)},{}],41:[function(t,n,r){var e={}.hasOwnProperty;n.exports=function(t,n){return e.call(t,n)}},{}],42:[function(t,n,r){var e=t(72),i=t(92);n.exports=t(29)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},{29:29,72:72,92:92}],43:[function(t,n,r){var e=t(40).document;n.exports=e&&e.documentElement},{40:40}],44:[function(t,n,r){n.exports=!t(29)&&!t(35)(function(){return 7!=Object.defineProperty(t(30)(\"div\"),\"a\",{get:function(){return 7}}).a})},{29:29,30:30,35:35}],45:[function(t,n,r){var e=t(51),i=t(99).set;n.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&\"function\"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},{51:51,99:99}],46:[function(t,n,r){n.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},{}],47:[function(t,n,r){var e=t(18);n.exports=Object(\"z\").propertyIsEnumerable(0)?Object:function(t){return\"String\"==e(t)?t.split(\"\"):Object(t)}},{18:18}],48:[function(t,n,r){var e=t(58),i=t(128)(\"iterator\"),o=Array.prototype;n.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},{128:128,58:58}],49:[function(t,n,r){var e=t(18);n.exports=Array.isArray||function isArray(t){return\"Array\"==e(t)}},{18:18}],50:[function(t,n,r){var e=t(51),i=Math.floor;n.exports=function isInteger(t){return!e(t)&&isFinite(t)&&i(t)===t}},{51:51}],51:[function(t,n,r){n.exports=function(t){return\"object\"==typeof t?null!==t:\"function\"==typeof t}},{}],52:[function(t,n,r){var e=t(51),i=t(18),o=t(128)(\"match\");n.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:\"RegExp\"==i(t))}},{128:128,18:18,51:51}],53:[function(t,n,r){var e=t(7);n.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},{7:7}],54:[function(t,n,r){\"use strict\";var e=t(71),i=t(92),o=t(101),u={};t(42)(u,t(128)(\"iterator\"),function(){return this}),n.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+\" Iterator\")}},{101:101,128:128,42:42,71:71,92:92}],55:[function(t,n,r){\"use strict\";var e=t(60),i=t(33),o=t(94),u=t(42),c=t(41),a=t(58),f=t(54),s=t(101),l=t(79),h=t(128)(\"iterator\"),v=!([].keys&&\"next\"in[].keys()),p=function(){return this};n.exports=function(t,n,r,d,y,g,m){f(r,n,d);var b,x,S,w=function(t){if(!v&&t in P)return P[t];switch(t){case\"keys\":return function keys(){return new r(this,t)};case\"values\":return function values(){return new r(this,t)}}return function entries(){return new r(this,t)}},_=n+\" Iterator\",E=\"values\"==y,O=!1,P=t.prototype,M=P[h]||P[\"@@iterator\"]||y&&P[y],F=M||w(y),I=y?E?w(\"entries\"):F:void 0,A=\"Array\"==n?P.entries||M:M;if(A&&(S=l(A.call(new t)))!==Object.prototype&&S.next&&(s(S,_,!0),e||c(S,h)||u(S,h,p)),E&&M&&\"values\"!==M.name&&(O=!0,F=function values(){return M.call(this)}),e&&!m||!v&&!O&&P[h]||u(P,h,F),a[n]=F,a[_]=p,y)if(b={values:E?F:w(\"values\"),keys:g?F:w(\"keys\"),entries:I},m)for(x in b)x in P||o(P,x,b[x]);else i(i.P+i.F*(v||O),n,b);return b}},{101:101,128:128,33:33,41:41,42:42,54:54,58:58,60:60,79:79,94:94}],56:[function(t,n,r){var e=t(128)(\"iterator\"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}n.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},{128:128}],57:[function(t,n,r){n.exports=function(t,n){return{value:n,done:!!t}}},{}],58:[function(t,n,r){n.exports={}},{}],59:[function(t,n,r){var e=t(81),i=t(117);n.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,a=0;c>a;)if(o[r=u[a++]]===n)return r}},{117:117,81:81}],60:[function(t,n,r){n.exports=!1},{}],61:[function(t,n,r){var e=Math.expm1;n.exports=!e||e(10)>22025.465794806718||e(10)<22025.465794806718||-2e-17!=e(-2e-17)?function expm1(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:e},{}],62:[function(t,n,r){var e=t(65),i=Math.pow,o=i(2,-52),u=i(2,-23),c=i(2,127)*(2-u),a=i(2,-126),f=function(t){return t+1/o-1/o};n.exports=Math.fround||function fround(t){var n,r,i=Math.abs(t),s=e(t);return i<a?s*f(i/a/u)*a*u:(n=(1+u/o)*i,r=n-(n-i),r>c||r!=r?s*(1/0):s*r)}},{65:65}],63:[function(t,n,r){n.exports=Math.log1p||function log1p(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},{}],64:[function(t,n,r){n.exports=Math.scale||function scale(t,n,r,e,i){return 0===arguments.length||t!=t||n!=n||r!=r||e!=e||i!=i?NaN:t===1/0||t===-1/0?t:(t-n)*(i-e)/(r-n)+e}},{}],65:[function(t,n,r){n.exports=Math.sign||function sign(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},{}],66:[function(t,n,r){var e=t(124)(\"meta\"),i=t(51),o=t(41),u=t(72).f,c=0,a=Object.isExtensible||function(){return!0},f=!t(35)(function(){return a(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:\"O\"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return\"symbol\"==typeof t?t:(\"string\"==typeof t?\"S\":\"P\")+t;if(!o(t,e)){if(!a(t))return\"F\";if(!n)return\"E\";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!a(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return f&&p.NEED&&a(t)&&!o(t,e)&&s(t),t},p=n.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},{124:124,35:35,41:41,51:51,72:72}],67:[function(t,n,r){var e=t(160),i=t(33),o=t(103)(\"metadata\"),u=o.store||(o.store=new(t(266))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},a=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},f=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||\"symbol\"==typeof t?t:String(t)},v=function(t){i(i.S,\"Reflect\",t)};n.exports={store:u,map:c,has:a,get:f,set:s,keys:l,key:h,exp:v}},{103:103,160:160,266:266,33:33}],68:[function(t,n,r){var e=t(40),i=t(113).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,a=\"process\"==t(18)(u);n.exports=function(){var t,n,r,f=function(){var e,i;for(a&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(a)r=function(){u.nextTick(f)};else if(o){var s=!0,l=document.createTextNode(\"\");new o(f).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(f)}}else r=function(){i.call(e,f)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},{113:113,18:18,40:40}],69:[function(t,n,r){\"use strict\";function PromiseCapability(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw TypeError(\"Bad Promise constructor\");n=t,r=e}),this.resolve=e(n),this.reject=e(r)}var e=t(3);n.exports.f=function(t){return new PromiseCapability(t)}},{3:3}],70:[function(t,n,r){\"use strict\";var e=t(81),i=t(78),o=t(82),u=t(119),c=t(47),a=Object.assign;n.exports=!a||t(35)(function(){var t={},n={},r=Symbol(),e=\"abcdefghijklmnopqrst\";return t[r]=7,e.split(\"\").forEach(function(t){n[t]=t}),7!=a({},t)[r]||Object.keys(a({},n)).join(\"\")!=e})?function assign(t,n){for(var r=u(t),a=arguments.length,f=1,s=i.f,l=o.f;a>f;)for(var h,v=c(arguments[f++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:a},{119:119,35:35,47:47,78:78,81:81,82:82}],71:[function(t,n,r){var e=t(7),i=t(73),o=t(31),u=t(102)(\"IE_PROTO\"),c=function(){},a=function(){var n,r=t(30)(\"iframe\"),e=o.length;for(r.style.display=\"none\",t(43).appendChild(r),r.src=\"javascript:\",n=r.contentWindow.document,n.open(),n.write(\"<script>document.F=Object<\\/script>\"),n.close(),a=n.F;e--;)delete a.prototype[o[e]];return a()};n.exports=Object.create||function create(t,n){var r;return null!==t?(c.prototype=e(t),r=new c,c.prototype=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},{102:102,30:30,31:31,43:43,7:7,73:73}],72:[function(t,n,r){var e=t(7),i=t(44),o=t(120),u=Object.defineProperty;r.f=t(29)?Object.defineProperty:function defineProperty(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if(\"get\"in r||\"set\"in r)throw TypeError(\"Accessors not supported!\");return\"value\"in r&&(t[n]=r.value),t}},{120:120,29:29,44:44,7:7}],73:[function(t,n,r){var e=t(72),i=t(7),o=t(81);n.exports=t(29)?Object.defineProperties:function defineProperties(t,n){i(t);for(var r,u=o(n),c=u.length,a=0;c>a;)e.f(t,r=u[a++],n[r]);return t}},{29:29,7:7,72:72,81:81}],74:[function(t,n,r){\"use strict\";n.exports=t(60)||!t(35)(function(){var n=Math.random();__defineSetter__.call(null,n,function(){}),delete t(40)[n]})},{35:35,40:40,60:60}],75:[function(t,n,r){var e=t(82),i=t(92),o=t(117),u=t(120),c=t(41),a=t(44),f=Object.getOwnPropertyDescriptor;r.f=t(29)?f:function getOwnPropertyDescriptor(t,n){if(t=o(t),n=u(n,!0),a)try{return f(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},{117:117,120:120,29:29,41:41,44:44,82:82,92:92}],76:[function(t,n,r){var e=t(117),i=t(77).f,o={}.toString,u=\"object\"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};n.exports.f=function getOwnPropertyNames(t){return u&&\"[object Window]\"==o.call(t)?c(t):i(e(t))}},{117:117,77:77}],77:[function(t,n,r){var e=t(80),i=t(31).concat(\"length\",\"prototype\");r.f=Object.getOwnPropertyNames||function getOwnPropertyNames(t){return e(t,i)}},{31:31,80:80}],78:[function(t,n,r){r.f=Object.getOwnPropertySymbols},{}],79:[function(t,n,r){var e=t(41),i=t(119),o=t(102)(\"IE_PROTO\"),u=Object.prototype;n.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:\"function\"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},{102:102,119:119,41:41}],80:[function(t,n,r){var e=t(41),i=t(117),o=t(11)(!1),u=t(102)(\"IE_PROTO\");n.exports=function(t,n){var r,c=i(t),a=0,f=[];for(r in c)r!=u&&e(c,r)&&f.push(r);for(;n.length>a;)e(c,r=n[a++])&&(~o(f,r)||f.push(r));return f}},{102:102,11:11,117:117,41:41}],81:[function(t,n,r){var e=t(80),i=t(31);n.exports=Object.keys||function keys(t){return e(t,i)}},{31:31,80:80}],82:[function(t,n,r){r.f={}.propertyIsEnumerable},{}],83:[function(t,n,r){var e=t(33),i=t(23),o=t(35);n.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),\"Object\",u)}},{23:23,33:33,35:35}],84:[function(t,n,r){var e=t(81),i=t(117),o=t(82).f;n.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),a=c.length,f=0,s=[];a>f;)o.call(u,r=c[f++])&&s.push(t?[r,u[r]]:u[r]);return s}}},{117:117,81:81,82:82}],85:[function(t,n,r){var e=t(77),i=t(78),o=t(7),u=t(40).Reflect;n.exports=u&&u.ownKeys||function ownKeys(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},{40:40,7:7,77:77,78:78}],86:[function(t,n,r){var e=t(40).parseFloat,i=t(111).trim;n.exports=1/e(t(112)+\"-0\")!=-1/0?function parseFloat(t){var n=i(String(t),3),r=e(n);return 0===r&&\"-\"==n.charAt(0)?-0:r}:e},{111:111,112:112,40:40}],87:[function(t,n,r){var e=t(40).parseInt,i=t(111).trim,o=t(112),u=/^[-+]?0[xX]/;n.exports=8!==e(o+\"08\")||22!==e(o+\"0x16\")?function parseInt(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},{111:111,112:112,40:40}],88:[function(t,n,r){\"use strict\";var e=t(89),i=t(46),o=t(3);n.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,a=!1;n>u;)(r[u]=arguments[u++])===c&&(a=!0);return function(){var e,o=this,u=arguments.length,f=0,s=0;if(!a&&!u)return i(t,r,o);if(e=r.slice(),a)for(;n>f;f++)e[f]===c&&(e[f]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},{3:3,46:46,89:89}],89:[function(t,n,r){n.exports=t(40)},{40:40}],90:[function(t,n,r){n.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},{}],91:[function(t,n,r){var e=t(69);n.exports=function(t,n){var r=e.f(t);return(0,r.resolve)(n),r.promise}},{69:69}],92:[function(t,n,r){n.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},{}],93:[function(t,n,r){var e=t(94);n.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},{94:94}],94:[function(t,n,r){var e=t(40),i=t(42),o=t(41),u=t(124)(\"src\"),c=Function.toString,a=(\"\"+c).split(\"toString\");t(23).inspectSource=function(t){return c.call(t)},(n.exports=function(t,n,r,c){var f=\"function\"==typeof r;f&&(o(r,\"name\")||i(r,\"name\",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?\"\"+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,\"toString\",function toString(){return\"function\"==typeof this&&this[u]||c.call(this)})},{124:124,23:23,40:40,41:41,42:42}],95:[function(t,n,r){n.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},{}],96:[function(t,n,r){n.exports=Object.is||function is(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},{}],97:[function(t,n,r){\"use strict\";var e=t(33),i=t(3),o=t(25),u=t(39);n.exports=function(t){e(e.S,t,{from:function from(t){var n,r,e,c,a=arguments[1];return i(this),n=void 0!==a,n&&i(a),void 0==t?new this:(r=[],n?(e=0,c=o(a,arguments[2],2),u(t,!1,function(t){r.push(c(t,e++))})):u(t,!1,r.push,r),new this(r))}})}},{25:25,3:3,33:33,39:39}],98:[function(t,n,r){\"use strict\";var e=t(33);n.exports=function(t){e(e.S,t,{of:function of(){for(var t=arguments.length,n=Array(t);t--;)n[t]=arguments[t];return new this(n)}})}},{33:33}],99:[function(t,n,r){var e=t(51),i=t(7),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+\": can't set as prototype!\")};n.exports={set:Object.setPrototypeOf||(\"__proto__\"in{}?function(n,r,e){try{e=t(25)(Function.call,t(75).f(Object.prototype,\"__proto__\").set,2),e(n,[]),r=!(n instanceof Array)}catch(t){r=!0}return function setPrototypeOf(t,n){return o(t,n),r?t.__proto__=n:e(t,n),t}}({},!1):void 0),check:o}},{25:25,51:51,7:7,75:75}],100:[function(t,n,r){\"use strict\";var e=t(40),i=t(72),o=t(29),u=t(128)(\"species\");n.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},{128:128,29:29,40:40,72:72}],101:[function(t,n,r){var e=t(72).f,i=t(41),o=t(128)(\"toStringTag\");n.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},{128:128,41:41,72:72}],102:[function(t,n,r){var e=t(103)(\"keys\"),i=t(124);n.exports=function(t){return e[t]||(e[t]=i(t))}},{103:103,124:124}],103:[function(t,n,r){var e=t(40),i=e[\"__core-js_shared__\"]||(e[\"__core-js_shared__\"]={});n.exports=function(t){return i[t]||(i[t]={})}},{40:40}],104:[function(t,n,r){var e=t(7),i=t(3),o=t(128)(\"species\");n.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},{128:128,3:3,7:7}],105:[function(t,n,r){\"use strict\";var e=t(35);n.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},{35:35}],106:[function(t,n,r){var e=t(116),i=t(28);n.exports=function(t){return function(n,r){var o,u,c=String(i(n)),a=e(r),f=c.length;return a<0||a>=f?t?\"\":void 0:(o=c.charCodeAt(a),o<55296||o>56319||a+1===f||(u=c.charCodeAt(a+1))<56320||u>57343?t?c.charAt(a):o:t?c.slice(a,a+2):u-56320+(o-55296<<10)+65536)}}},{116:116,28:28}],107:[function(t,n,r){var e=t(52),i=t(28);n.exports=function(t,n,r){if(e(n))throw TypeError(\"String#\"+r+\" doesn't accept regex!\");return String(i(t))}},{28:28,52:52}],108:[function(t,n,r){var e=t(33),i=t(35),o=t(28),u=/\"/g,c=function(t,n,r,e){var i=String(o(t)),c=\"<\"+n;return\"\"!==r&&(c+=\" \"+r+'=\"'+String(e).replace(u,\"&quot;\")+'\"'),c+\">\"+i+\"</\"+n+\">\"};n.exports=function(t,n){var r={};r[t]=n(c),e(e.P+e.F*i(function(){var n=\"\"[t]('\"');return n!==n.toLowerCase()||n.split('\"').length>3}),\"String\",r)}},{28:28,33:33,35:35}],109:[function(t,n,r){var e=t(118),i=t(110),o=t(28);n.exports=function(t,n,r,u){var c=String(o(t)),a=c.length,f=void 0===r?\" \":String(r),s=e(n);if(s<=a||\"\"==f)return c;var l=s-a,h=i.call(f,Math.ceil(l/f.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},{110:110,118:118,28:28}],110:[function(t,n,r){\"use strict\";var e=t(116),i=t(28);n.exports=function repeat(t){var n=String(i(this)),r=\"\",o=e(t);if(o<0||o==1/0)throw RangeError(\"Count can't be negative\");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},{116:116,28:28}],111:[function(t,n,r){var e=t(33),i=t(28),o=t(35),u=t(112),c=\"[\"+u+\"]\",a=\"​\",f=RegExp(\"^\"+c+c+\"*\"),s=RegExp(c+c+\"*$\"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||a[t]()!=a}),f=i[t]=c?n(h):u[t];r&&(i[r]=f),e(e.P+e.F*c,\"String\",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(f,\"\")),2&n&&(t=t.replace(s,\"\")),t};n.exports=l},{112:112,28:28,33:33,35:35}],112:[function(t,n,r){n.exports=\"\\t\\n\\v\\f\\r   ᠎             　\\u2028\\u2029\\ufeff\"},{}],113:[function(t,n,r){var e,i,o,u=t(25),c=t(46),a=t(43),f=t(30),s=t(40),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=s.Dispatch,y=0,g={},m=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},b=function(t){m.call(t.data)};h&&v||(h=function setImmediate(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return g[++y]=function(){c(\"function\"==typeof t?t:Function(t),n)},e(y),y},v=function clearImmediate(t){delete g[t]},\"process\"==t(18)(l)?e=function(t){l.nextTick(u(m,t,1))}:d&&d.now?e=function(t){d.now(u(m,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=b,e=u(o.postMessage,o,1)):s.addEventListener&&\"function\"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+\"\",\"*\")},s.addEventListener(\"message\",b,!1)):e=\"onreadystatechange\"in f(\"script\")?function(t){a.appendChild(f(\"script\")).onreadystatechange=function(){a.removeChild(this),m.call(t)}}:function(t){setTimeout(u(m,t,1),0)}),n.exports={set:h,clear:v}},{18:18,25:25,30:30,40:40,43:43,46:46}],114:[function(t,n,r){var e=t(116),i=Math.max,o=Math.min;n.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},{116:116}],115:[function(t,n,r){var e=t(116),i=t(118);n.exports=function(t){if(void 0===t)return 0;var n=e(t),r=i(n);if(n!==r)throw RangeError(\"Wrong length!\");return r}},{116:116,118:118}],116:[function(t,n,r){var e=Math.ceil,i=Math.floor;n.exports=function(t){return isNaN(t=+t)?0:(t>0?i:e)(t)}},{}],117:[function(t,n,r){var e=t(47),i=t(28);n.exports=function(t){return e(i(t))}},{28:28,47:47}],118:[function(t,n,r){var e=t(116),i=Math.min;n.exports=function(t){return t>0?i(e(t),9007199254740991):0}},{116:116}],\n119:[function(t,n,r){var e=t(28);n.exports=function(t){return Object(e(t))}},{28:28}],120:[function(t,n,r){var e=t(51);n.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&\"function\"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if(\"function\"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&\"function\"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError(\"Can't convert object to primitive value\")}},{51:51}],121:[function(t,n,r){\"use strict\";if(t(29)){var e=t(60),i=t(40),o=t(35),u=t(33),c=t(123),a=t(122),f=t(25),s=t(6),l=t(92),h=t(42),v=t(93),p=t(116),d=t(118),y=t(115),g=t(114),m=t(120),b=t(41),x=t(17),S=t(51),w=t(119),_=t(48),E=t(71),O=t(79),P=t(77).f,M=t(129),F=t(124),I=t(128),A=t(12),k=t(11),N=t(104),j=t(141),T=t(58),R=t(56),L=t(100),G=t(9),D=t(8),C=t(72),W=t(75),U=C.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K=Array.prototype,Y=a.ArrayBuffer,J=a.DataView,H=A(0),X=A(2),$=A(3),Z=A(4),Q=A(5),tt=A(6),nt=k(!0),rt=k(!1),et=j.values,it=j.keys,ot=j.entries,ut=K.lastIndexOf,ct=K.reduce,at=K.reduceRight,ft=K.join,st=K.sort,lt=K.slice,ht=K.toString,vt=K.toLocaleString,pt=I(\"iterator\"),dt=I(\"toStringTag\"),yt=F(\"typed_constructor\"),gt=F(\"def_constructor\"),mt=c.CONSTR,bt=c.TYPED,xt=c.VIEW,St=A(1,function(t,n){return Pt(N(t,t[gt]),n)}),wt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),_t=!!q&&!!q.prototype.set&&o(function(){new q(1).set({})}),Et=function(t,n){var r=p(t);if(r<0||r%n)throw V(\"Wrong offset!\");return r},Ot=function(t){if(S(t)&&bt in t)return t;throw z(t+\" is not a typed array!\")},Pt=function(t,n){if(!(S(t)&&yt in t))throw z(\"It is not a typed array constructor!\");return new t(n)},Mt=function(t,n){return Ft(N(t,t[gt]),n)},Ft=function(t,n){for(var r=0,e=n.length,i=Pt(t,e);e>r;)i[r]=n[r++];return i},It=function(t,n,r){U(t,n,{get:function(){return this._d[r]}})},At=function from(t){var n,r,e,i,o,u,c=w(t),a=arguments.length,s=a>1?arguments[1]:void 0,l=void 0!==s,h=M(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&a>2&&(s=f(s,arguments[2],2)),n=0,r=d(c.length),i=Pt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},kt=function of(){for(var t=0,n=arguments.length,r=Pt(this,n);n>t;)r[t]=arguments[t++];return r},Nt=!!q&&o(function(){vt.call(new q(1))}),jt=function toLocaleString(){return vt.apply(Nt?lt.call(Ot(this)):Ot(this),arguments)},Tt={copyWithin:function copyWithin(t,n){return D.call(Ot(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function every(t){return Z(Ot(this),t,arguments.length>1?arguments[1]:void 0)},fill:function fill(t){return G.apply(Ot(this),arguments)},filter:function filter(t){return Mt(this,X(Ot(this),t,arguments.length>1?arguments[1]:void 0))},find:function find(t){return Q(Ot(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function findIndex(t){return tt(Ot(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function forEach(t){H(Ot(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function indexOf(t){return rt(Ot(this),t,arguments.length>1?arguments[1]:void 0)},includes:function includes(t){return nt(Ot(this),t,arguments.length>1?arguments[1]:void 0)},join:function join(t){return ft.apply(Ot(this),arguments)},lastIndexOf:function lastIndexOf(t){return ut.apply(Ot(this),arguments)},map:function map(t){return St(Ot(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function reduce(t){return ct.apply(Ot(this),arguments)},reduceRight:function reduceRight(t){return at.apply(Ot(this),arguments)},reverse:function reverse(){for(var t,n=this,r=Ot(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function some(t){return $(Ot(this),t,arguments.length>1?arguments[1]:void 0)},sort:function sort(t){return st.call(Ot(this),t)},subarray:function subarray(t,n){var r=Ot(this),e=r.length,i=g(t,e);return new(N(r,r[gt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:g(n,e))-i))}},Rt=function slice(t,n){return Mt(this,lt.call(Ot(this),t,n))},Lt=function set(t){Ot(this);var n=Et(arguments[1],1),r=this.length,e=w(t),i=d(e.length),o=0;if(i+n>r)throw V(\"Wrong length!\");for(;o<i;)this[n+o]=e[o++]},Gt={entries:function entries(){return ot.call(Ot(this))},keys:function keys(){return it.call(Ot(this))},values:function values(){return et.call(Ot(this))}},Dt=function(t,n){return S(t)&&t[bt]&&\"symbol\"!=typeof n&&n in t&&String(+n)==String(n)},Ct=function getOwnPropertyDescriptor(t,n){return Dt(t,n=m(n,!0))?l(2,t[n]):B(t,n)},Wt=function defineProperty(t,n,r){return!(Dt(t,n=m(n,!0))&&S(r)&&b(r,\"value\"))||b(r,\"get\")||b(r,\"set\")||r.configurable||b(r,\"writable\")&&!r.writable||b(r,\"enumerable\")&&!r.enumerable?U(t,n,r):(t[n]=r.value,t)};mt||(W.f=Ct,C.f=Wt),u(u.S+u.F*!mt,\"Object\",{getOwnPropertyDescriptor:Ct,defineProperty:Wt}),o(function(){ht.call({})})&&(ht=vt=function toString(){return ft.call(this)});var Ut=v({},Tt);v(Ut,Gt),h(Ut,pt,Gt.values),v(Ut,{slice:Rt,set:Lt,constructor:function(){},toString:ht,toLocaleString:jt}),It(Ut,\"buffer\",\"b\"),It(Ut,\"byteOffset\",\"o\"),It(Ut,\"byteLength\",\"l\"),It(Ut,\"length\",\"e\"),U(Ut,dt,{get:function(){return this[bt]}}),n.exports=function(t,n,r,a){a=!!a;var f=t+(a?\"Clamped\":\"\")+\"Array\",l=\"get\"+t,v=\"set\"+t,p=i[f],g=p||{},m=p&&O(p),b=!p||!c.ABV,w={},_=p&&p.prototype,M=function(t,r){var e=t._d;return e.v[l](r*n+e.o,wt)},F=function(t,r,e){var i=t._d;a&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[v](r*n+i.o,e,wt)},I=function(t,n){U(t,n,{get:function(){return M(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};b?(p=r(function(t,r,e,i){s(t,p,f,\"_d\");var o,u,c,a,l=0,v=0;if(S(r)){if(!(r instanceof Y||\"ArrayBuffer\"==(a=x(r))||\"SharedArrayBuffer\"==a))return bt in r?Ft(p,r):At.call(p,r);o=r,v=Et(e,n);var g=r.byteLength;if(void 0===i){if(g%n)throw V(\"Wrong length!\");if((u=g-v)<0)throw V(\"Wrong length!\")}else if((u=d(i)*n)+v>g)throw V(\"Wrong length!\");c=u/n}else c=y(r),u=c*n,o=new Y(u);for(h(t,\"_d\",{b:o,o:v,l:u,e:c,v:new J(o)});l<c;)I(t,l++)}),_=p.prototype=E(Ut),h(_,\"constructor\",p)):o(function(){p(1)})&&o(function(){new p(-1)})&&R(function(t){new p,new p(null),new p(1.5),new p(t)},!0)||(p=r(function(t,r,e,i){s(t,p,f);var o;return S(r)?r instanceof Y||\"ArrayBuffer\"==(o=x(r))||\"SharedArrayBuffer\"==o?void 0!==i?new g(r,Et(e,n),i):void 0!==e?new g(r,Et(e,n)):new g(r):bt in r?Ft(p,r):At.call(p,r):new g(y(r))}),H(m!==Function.prototype?P(g).concat(P(m)):P(g),function(t){t in p||h(p,t,g[t])}),p.prototype=_,e||(_.constructor=p));var A=_[pt],k=!!A&&(\"values\"==A.name||void 0==A.name),N=Gt.values;h(p,yt,!0),h(_,bt,f),h(_,xt,!0),h(_,gt,p),(a?new p(1)[dt]==f:dt in _)||U(_,dt,{get:function(){return f}}),w[f]=p,u(u.G+u.W+u.F*(p!=g),w),u(u.S,f,{BYTES_PER_ELEMENT:n}),u(u.S+u.F*o(function(){g.of.call(p,1)}),f,{from:At,of:kt}),\"BYTES_PER_ELEMENT\"in _||h(_,\"BYTES_PER_ELEMENT\",n),u(u.P,f,Tt),L(f),u(u.P+u.F*_t,f,{set:Lt}),u(u.P+u.F*!k,f,Gt),e||_.toString==ht||(_.toString=ht),u(u.P+u.F*o(function(){new p(1).slice()}),f,{slice:Rt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new p([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),f,{toLocaleString:jt}),T[f]=k?A:N,e||k||h(_,pt,N)}}else n.exports=function(){}},{100:100,104:104,11:11,114:114,115:115,116:116,118:118,119:119,12:12,120:120,122:122,123:123,124:124,128:128,129:129,141:141,17:17,25:25,29:29,33:33,35:35,40:40,41:41,42:42,48:48,51:51,56:56,58:58,6:6,60:60,71:71,72:72,75:75,77:77,79:79,8:8,9:9,92:92,93:93}],122:[function(t,n,r){\"use strict\";function packIEEE754(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,a=(1<<c)-1,f=a>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=P(t),t!=t||t===E?(i=t!=t?1:0,e=a):(e=F(I(t)/A),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+f>=1?s/o:s*M(2,1-f),t*o>=2&&(e++,o/=2),e+f>=a?(i=0,e=a):e+f>=1?(i=(t*o-1)*M(2,n),e+=f):(i=t*M(2,f-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u}function unpackIEEE754(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,a=r-1,f=t[a--],s=127&f;for(f>>=7;c>0;s=256*s+t[a],a--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[a],a--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:f?-E:E;e+=M(2,n),s-=u}return(f?-1:1)*e*M(2,s-n)}function unpackI32(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]}function packI8(t){return[255&t]}function packI16(t){return[255&t,t>>8&255]}function packI32(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]}function packF64(t){return packIEEE754(t,52,8)}function packF32(t){return packIEEE754(t,23,4)}function addGetter(t,n,r){d(t[m],n,{get:function(){return this[r]}})}function get(t,n,r,e){var i=+r,o=v(i);if(o+n>t[N])throw _(b);var u=t[k]._b,c=o+t[j],a=u.slice(c,c+n);return e?a:a.reverse()}function set(t,n,r,e,i,o){var u=+r,c=v(u);if(c+n>t[N])throw _(b);for(var a=t[k]._b,f=c+t[j],s=e(+i),l=0;l<n;l++)a[f+l]=s[o?l:n-l-1]}var e=t(40),i=t(29),o=t(60),u=t(123),c=t(42),a=t(93),f=t(35),s=t(6),l=t(116),h=t(118),v=t(115),p=t(77).f,d=t(72).f,y=t(9),g=t(101),m=\"prototype\",b=\"Wrong index!\",x=e.ArrayBuffer,S=e.DataView,w=e.Math,_=e.RangeError,E=e.Infinity,O=x,P=w.abs,M=w.pow,F=w.floor,I=w.log,A=w.LN2,k=i?\"_b\":\"buffer\",N=i?\"_l\":\"byteLength\",j=i?\"_o\":\"byteOffset\";if(u.ABV){if(!f(function(){x(1)})||!f(function(){new x(-1)})||f(function(){return new x,new x(1.5),new x(NaN),\"ArrayBuffer\"!=x.name})){x=function ArrayBuffer(t){return s(this,x),new O(v(t))};for(var T,R=x[m]=O[m],L=p(O),G=0;L.length>G;)(T=L[G++])in x||c(x,T,O[T]);o||(R.constructor=x)}var D=new S(new x(2)),C=S[m].setInt8;D.setInt8(0,2147483648),D.setInt8(1,2147483649),!D.getInt8(0)&&D.getInt8(1)||a(S[m],{setInt8:function setInt8(t,n){C.call(this,t,n<<24>>24)},setUint8:function setUint8(t,n){C.call(this,t,n<<24>>24)}},!0)}else x=function ArrayBuffer(t){s(this,x,\"ArrayBuffer\");var n=v(t);this._b=y.call(Array(n),0),this[N]=n},S=function DataView(t,n,r){s(this,S,\"DataView\"),s(t,x,\"DataView\");var e=t[N],i=l(n);if(i<0||i>e)throw _(\"Wrong offset!\");if(r=void 0===r?e-i:h(r),i+r>e)throw _(\"Wrong length!\");this[k]=t,this[j]=i,this[N]=r},i&&(addGetter(x,\"byteLength\",\"_l\"),addGetter(S,\"buffer\",\"_b\"),addGetter(S,\"byteLength\",\"_l\"),addGetter(S,\"byteOffset\",\"_o\")),a(S[m],{getInt8:function getInt8(t){return get(this,1,t)[0]<<24>>24},getUint8:function getUint8(t){return get(this,1,t)[0]},getInt16:function getInt16(t){var n=get(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function getUint16(t){var n=get(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function getInt32(t){return unpackI32(get(this,4,t,arguments[1]))},getUint32:function getUint32(t){return unpackI32(get(this,4,t,arguments[1]))>>>0},getFloat32:function getFloat32(t){return unpackIEEE754(get(this,4,t,arguments[1]),23,4)},getFloat64:function getFloat64(t){return unpackIEEE754(get(this,8,t,arguments[1]),52,8)},setInt8:function setInt8(t,n){set(this,1,t,packI8,n)},setUint8:function setUint8(t,n){set(this,1,t,packI8,n)},setInt16:function setInt16(t,n){set(this,2,t,packI16,n,arguments[2])},setUint16:function setUint16(t,n){set(this,2,t,packI16,n,arguments[2])},setInt32:function setInt32(t,n){set(this,4,t,packI32,n,arguments[2])},setUint32:function setUint32(t,n){set(this,4,t,packI32,n,arguments[2])},setFloat32:function setFloat32(t,n){set(this,4,t,packF32,n,arguments[2])},setFloat64:function setFloat64(t,n){set(this,8,t,packF64,n,arguments[2])}});g(x,\"ArrayBuffer\"),g(S,\"DataView\"),c(S[m],u.VIEW,!0),r.ArrayBuffer=x,r.DataView=S},{101:101,115:115,116:116,118:118,123:123,29:29,35:35,40:40,42:42,6:6,60:60,72:72,77:77,9:9,93:93}],123:[function(t,n,r){for(var e,i=t(40),o=t(42),u=t(124),c=u(\"typed_array\"),a=u(\"view\"),f=!(!i.ArrayBuffer||!i.DataView),s=f,l=0,h=\"Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array\".split(\",\");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,a,!0)):s=!1;n.exports={ABV:f,CONSTR:s,TYPED:c,VIEW:a}},{124:124,40:40,42:42}],124:[function(t,n,r){var e=0,i=Math.random();n.exports=function(t){return\"Symbol(\".concat(void 0===t?\"\":t,\")_\",(++e+i).toString(36))}},{}],125:[function(t,n,r){var e=t(51);n.exports=function(t,n){if(!e(t)||t._t!==n)throw TypeError(\"Incompatible receiver, \"+n+\" required!\");return t}},{51:51}],126:[function(t,n,r){var e=t(40),i=t(23),o=t(60),u=t(127),c=t(72).f;n.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});\"_\"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},{127:127,23:23,40:40,60:60,72:72}],127:[function(t,n,r){r.f=t(128)},{128:128}],128:[function(t,n,r){var e=t(103)(\"wks\"),i=t(124),o=t(40).Symbol,u=\"function\"==typeof o;(n.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)(\"Symbol.\"+t))}).store=e},{103:103,124:124,40:40}],129:[function(t,n,r){var e=t(17),i=t(128)(\"iterator\"),o=t(58);n.exports=t(23).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t[\"@@iterator\"]||o[e(t)]}},{128:128,17:17,23:23,58:58}],130:[function(t,n,r){var e=t(33),i=t(95)(/[\\\\^$*+?.()|[\\]{}]/g,\"\\\\</body>\");e(e.S,\"RegExp\",{escape:function escape(t){return i(t)}})},{33:33,95:95}],131:[function(t,n,r){var e=t(33);e(e.P,\"Array\",{copyWithin:t(8)}),t(5)(\"copyWithin\")},{33:33,5:5,8:8}],132:[function(t,n,r){\"use strict\";var e=t(33),i=t(12)(4);e(e.P+e.F*!t(105)([].every,!0),\"Array\",{every:function every(t){return i(this,t,arguments[1])}})},{105:105,12:12,33:33}],133:[function(t,n,r){var e=t(33);e(e.P,\"Array\",{fill:t(9)}),t(5)(\"fill\")},{33:33,5:5,9:9}],134:[function(t,n,r){\"use strict\";var e=t(33),i=t(12)(2);e(e.P+e.F*!t(105)([].filter,!0),\"Array\",{filter:function filter(t){return i(this,t,arguments[1])}})},{105:105,12:12,33:33}],135:[function(t,n,r){\"use strict\";var e=t(33),i=t(12)(6),o=\"findIndex\",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,\"Array\",{findIndex:function findIndex(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),t(5)(o)},{12:12,33:33,5:5}],136:[function(t,n,r){\"use strict\";var e=t(33),i=t(12)(5),o=!0;\"find\"in[]&&Array(1).find(function(){o=!1}),e(e.P+e.F*o,\"Array\",{find:function find(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),t(5)(\"find\")},{12:12,33:33,5:5}],137:[function(t,n,r){\"use strict\";var e=t(33),i=t(12)(0),o=t(105)([].forEach,!0);e(e.P+e.F*!o,\"Array\",{forEach:function forEach(t){return i(this,t,arguments[1])}})},{105:105,12:12,33:33}],138:[function(t,n,r){\"use strict\";var e=t(25),i=t(33),o=t(119),u=t(53),c=t(48),a=t(118),f=t(24),s=t(129);i(i.S+i.F*!t(56)(function(t){Array.from(t)}),\"Array\",{from:function from(t){var n,r,i,l,h=o(t),v=\"function\"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,m=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==m||v==Array&&c(m))for(n=a(h.length),r=new v(n);n>g;g++)f(r,g,y?d(h[g],g):h[g]);else for(l=m.call(h),r=new v;!(i=l.next()).done;g++)f(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},{118:118,119:119,129:129,24:24,25:25,33:33,48:48,53:53,56:56}],139:[function(t,n,r){\"use strict\";var e=t(33),i=t(11)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!t(105)(o)),\"Array\",{indexOf:function indexOf(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},{105:105,11:11,33:33}],140:[function(t,n,r){var e=t(33);e(e.S,\"Array\",{isArray:t(49)})},{33:33,49:49}],141:[function(t,n,r){\"use strict\";var e=t(5),i=t(57),o=t(58),u=t(117);n.exports=t(55)(Array,\"Array\",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):\"keys\"==n?i(0,r):\"values\"==n?i(0,t[r]):i(0,[r,t[r]])},\"values\"),o.Arguments=o.Array,e(\"keys\"),e(\"values\"),e(\"entries\")},{117:117,5:5,55:55,57:57,58:58}],142:[function(t,n,r){\"use strict\";var e=t(33),i=t(117),o=[].join;e(e.P+e.F*(t(47)!=Object||!t(105)(o)),\"Array\",{join:function join(t){return o.call(i(this),void 0===t?\",\":t)}})},{105:105,117:117,33:33,47:47}],143:[function(t,n,r){\"use strict\";var e=t(33),i=t(117),o=t(116),u=t(118),c=[].lastIndexOf,a=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(a||!t(105)(c)),\"Array\",{lastIndexOf:function lastIndexOf(t){if(a)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},{105:105,116:116,117:117,118:118,33:33}],144:[function(t,n,r){\"use strict\";var e=t(33),i=t(12)(1);e(e.P+e.F*!t(105)([].map,!0),\"Array\",{map:function map(t){return i(this,t,arguments[1])}})},{105:105,12:12,33:33}],145:[function(t,n,r){\"use strict\";var e=t(33),i=t(24);e(e.S+e.F*t(35)(function(){function F(){}return!(Array.of.call(F)instanceof F)}),\"Array\",{of:function of(){for(var t=0,n=arguments.length,r=new(\"function\"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},{24:24,33:33,35:35}],146:[function(t,n,r){\"use strict\";var e=t(33),i=t(13);e(e.P+e.F*!t(105)([].reduceRight,!0),\"Array\",{reduceRight:function reduceRight(t){return i(this,t,arguments.length,arguments[1],!0)}})},{105:105,13:13,33:33}],147:[function(t,n,r){\"use strict\";var e=t(33),i=t(13);e(e.P+e.F*!t(105)([].reduce,!0),\"Array\",{reduce:function reduce(t){return i(this,t,arguments.length,arguments[1],!1)}})},{105:105,13:13,33:33}],148:[function(t,n,r){\"use strict\";var e=t(33),i=t(43),o=t(18),u=t(114),c=t(118),a=[].slice;e(e.P+e.F*t(35)(function(){i&&a.call(i)}),\"Array\",{slice:function slice(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,\"Array\"==e)return a.call(this,t,n);for(var i=u(t,r),f=u(n,r),s=c(f-i),l=Array(s),h=0;h<s;h++)l[h]=\"String\"==e?this.charAt(i+h):this[i+h];return l}})},{114:114,118:118,18:18,33:33,35:35,43:43}],149:[function(t,n,r){\"use strict\";var e=t(33),i=t(12)(3);e(e.P+e.F*!t(105)([].some,!0),\"Array\",{some:function some(t){return i(this,t,arguments[1])}})},{105:105,12:12,33:33}],150:[function(t,n,r){\"use strict\";var e=t(33),i=t(3),o=t(119),u=t(35),c=[].sort,a=[1,2,3];e(e.P+e.F*(u(function(){a.sort(void 0)})||!u(function(){a.sort(null)})||!t(105)(c)),\"Array\",{sort:function sort(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},{105:105,119:119,3:3,33:33,35:35}],151:[function(t,n,r){t(100)(\"Array\")},{100:100}],152:[function(t,n,r){var e=t(33);e(e.S,\"Date\",{now:function(){return(new Date).getTime()}})},{33:33}],153:[function(t,n,r){var e=t(33),i=t(26);e(e.P+e.F*(Date.prototype.toISOString!==i),\"Date\",{toISOString:i})},{26:26,33:33}],154:[function(t,n,r){\"use strict\";var e=t(33),i=t(119),o=t(120);e(e.P+e.F*t(35)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),\"Date\",{toJSON:function toJSON(t){var n=i(this),r=o(n);return\"number\"!=typeof r||isFinite(r)?n.toISOString():null}})},{119:119,120:120,33:33,35:35}],155:[function(t,n,r){var e=t(128)(\"toPrimitive\"),i=Date.prototype;e in i||t(42)(i,e,t(27))},{128:128,27:27,42:42}],156:[function(t,n,r){var e=Date.prototype,i=e.toString,o=e.getTime;new Date(NaN)+\"\"!=\"Invalid Date\"&&t(94)(e,\"toString\",function toString(){var t=o.call(this);return t===t?i.call(this):\"Invalid Date\"})},{94:94}],157:[function(t,n,r){var e=t(33);e(e.P,\"Function\",{bind:t(16)})},{16:16,33:33}],158:[function(t,n,r){\"use strict\";var e=t(51),i=t(79),o=t(128)(\"hasInstance\"),u=Function.prototype;o in u||t(72).f(u,o,{value:function(t){if(\"function\"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},{128:128,51:51,72:72,79:79}],159:[function(t,n,r){var e=t(72).f,i=Function.prototype,o=/^\\s*function ([^ (]*)/;\"name\"in i||t(29)&&e(i,\"name\",{configurable:!0,get:function(){try{return(\"\"+this).match(o)[1]}catch(t){return\"\"}}})},{29:29,72:72}],160:[function(t,n,r){\"use strict\";var e=t(19),i=t(125);n.exports=t(22)(\"Map\",function(t){return function Map(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function get(t){var n=e.getEntry(i(this,\"Map\"),t);return n&&n.v},set:function set(t,n){return e.def(i(this,\"Map\"),0===t?0:t,n)}},e,!0)},{125:125,19:19,22:22}],161:[function(t,n,r){var e=t(33),i=t(63),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),\"Math\",{acosh:function acosh(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},{33:33,63:63}],162:[function(t,n,r){function asinh(t){return isFinite(t=+t)&&0!=t?t<0?-asinh(-t):Math.log(t+Math.sqrt(t*t+1)):t}var e=t(33),i=Math.asinh;e(e.S+e.F*!(i&&1/i(0)>0),\"Math\",{asinh:asinh})},{33:33}],163:[function(t,n,r){var e=t(33),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),\"Math\",{atanh:function atanh(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},{33:33}],164:[function(t,n,r){var e=t(33),i=t(65);e(e.S,\"Math\",{cbrt:function cbrt(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},{33:33,65:65}],165:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{clz32:function clz32(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},{33:33}],166:[function(t,n,r){var e=t(33),i=Math.exp;e(e.S,\"Math\",{cosh:function cosh(t){return(i(t=+t)+i(-t))/2}})},{33:33}],167:[function(t,n,r){var e=t(33),i=t(61);e(e.S+e.F*(i!=Math.expm1),\"Math\",{expm1:i})},{33:33,61:61}],168:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{fround:t(62)})},{33:33,62:62}],169:[function(t,n,r){var e=t(33),i=Math.abs;e(e.S,\"Math\",{hypot:function hypot(t,n){for(var r,e,o=0,u=0,c=arguments.length,a=0;u<c;)r=i(arguments[u++]),a<r?(e=a/r,o=o*e*e+1,a=r):r>0?(e=r/a,o+=e*e):o+=r;return a===1/0?1/0:a*Math.sqrt(o)}})},{33:33}],170:[function(t,n,r){var e=t(33),i=Math.imul;e(e.S+e.F*t(35)(function(){return-5!=i(4294967295,5)||2!=i.length}),\"Math\",{imul:function imul(t,n){var r=+t,e=+n,i=65535&r,o=65535&e;return 0|i*o+((65535&r>>>16)*o+i*(65535&e>>>16)<<16>>>0)}})},{33:33,35:35}],171:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{log10:function log10(t){return Math.log(t)*Math.LOG10E}})},{33:33}],172:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{log1p:t(63)})},{33:33,63:63}],173:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{log2:function log2(t){return Math.log(t)/Math.LN2}})},{33:33}],174:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{sign:t(65)})},{33:33,65:65}],175:[function(t,n,r){var e=t(33),i=t(61),o=Math.exp;e(e.S+e.F*t(35)(function(){return-2e-17!=!Math.sinh(-2e-17)}),\"Math\",{sinh:function sinh(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},{33:33,35:35,61:61}],176:[function(t,n,r){var e=t(33),i=t(61),o=Math.exp;e(e.S,\"Math\",{tanh:function tanh(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},{33:33,61:61}],177:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{trunc:function trunc(t){return(t>0?Math.floor:Math.ceil)(t)}})},{33:33}],178:[function(t,n,r){\"use strict\";var e=t(40),i=t(41),o=t(18),u=t(45),c=t(120),a=t(35),f=t(77).f,s=t(75).f,l=t(72).f,h=t(111).trim,v=e.Number,p=v,d=v.prototype,y=\"Number\"==o(t(71)(d)),g=\"trim\"in String.prototype,m=function(t){var n=c(t,!1);if(\"string\"==typeof n&&n.length>2){n=g?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,a=n.slice(2),f=0,s=a.length;f<s;f++)if((u=a.charCodeAt(f))<48||u>i)return NaN;return parseInt(a,e)}}return+n};if(!v(\" 0o1\")||!v(\"0b1\")||v(\"+0x1\")){v=function Number(t){var n=arguments.length<1?0:t,r=this;return r instanceof v&&(y?a(function(){d.valueOf.call(r)}):\"Number\"!=o(r))?u(new p(m(n)),r,v):m(n)};for(var b,x=t(29)?f(p):\"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger\".split(\",\"),S=0;x.length>S;S++)i(p,b=x[S])&&!i(v,b)&&l(v,b,s(p,b));v.prototype=d,d.constructor=v,t(94)(e,\"Number\",v)}},{111:111,120:120,18:18,29:29,35:35,40:40,41:41,45:45,71:71,72:72,75:75,77:77,94:94}],179:[function(t,n,r){var e=t(33);e(e.S,\"Number\",{EPSILON:Math.pow(2,-52)})},{33:33}],180:[function(t,n,r){var e=t(33),i=t(40).isFinite;e(e.S,\"Number\",{isFinite:function isFinite(t){return\"number\"==typeof t&&i(t)}})},{33:33,40:40}],181:[function(t,n,r){var e=t(33);e(e.S,\"Number\",{isInteger:t(50)})},{33:33,50:50}],182:[function(t,n,r){var e=t(33);e(e.S,\"Number\",{isNaN:function isNaN(t){return t!=t}})},{33:33}],183:[function(t,n,r){var e=t(33),i=t(50),o=Math.abs;e(e.S,\"Number\",{isSafeInteger:function isSafeInteger(t){return i(t)&&o(t)<=9007199254740991}})},{33:33,50:50}],184:[function(t,n,r){var e=t(33);e(e.S,\"Number\",{MAX_SAFE_INTEGER:9007199254740991})},{33:33}],185:[function(t,n,r){var e=t(33);e(e.S,\"Number\",{MIN_SAFE_INTEGER:-9007199254740991})},{33:33}],186:[function(t,n,r){var e=t(33),i=t(86);e(e.S+e.F*(Number.parseFloat!=i),\"Number\",{parseFloat:i})},{33:33,86:86}],187:[function(t,n,r){var e=t(33),i=t(87);e(e.S+e.F*(Number.parseInt!=i),\"Number\",{parseInt:i})},{33:33,87:87}],188:[function(t,n,r){\"use strict\";var e=t(33),i=t(116),o=t(4),u=t(110),c=1..toFixed,a=Math.floor,f=[0,0,0,0,0,0],s=\"Number.toFixed: incorrect invocation!\",l=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*f[r],f[r]=e%1e7,e=a(e/1e7)},h=function(t){for(var n=6,r=0;--n>=0;)r+=f[n],f[n]=a(r/t),r=r%t*1e7},v=function(){for(var t=6,n=\"\";--t>=0;)if(\"\"!==n||0===t||0!==f[t]){var r=String(f[t]);n=\"\"===n?r:n+u.call(\"0\",7-r.length)+r}return n},p=function(t,n,r){return 0===n?r:n%2==1?p(t,n-1,r*t):p(t*t,n/2,r)},d=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&(\"0.000\"!==8e-5.toFixed(3)||\"1\"!==.9.toFixed(0)||\"1.25\"!==1.255.toFixed(2)||\"1000000000000000128\"!==(0xde0b6b3a7640080).toFixed(0))||!t(35)(function(){c.call({})})),\"Number\",{toFixed:function toFixed(t){var n,r,e,c,a=o(this,s),f=i(t),y=\"\",g=\"0\";if(f<0||f>20)throw RangeError(s);if(a!=a)return\"NaN\";if(a<=-1e21||a>=1e21)return String(a);if(a<0&&(y=\"-\",a=-a),a>1e-21)if(n=d(a*p(2,69,1))-69,r=n<0?a*p(2,-n,1):a/p(2,n,1),r*=4503599627370496,(n=52-n)>0){for(l(0,r),e=f;e>=7;)l(1e7,0),e-=7;for(l(p(10,e,1),0),e=n-1;e>=23;)h(1<<23),e-=23;h(1<<e),l(1,1),h(2),g=v()}else l(0,r),l(1<<-n,0),g=v()+u.call(\"0\",f);return f>0?(c=g.length,g=y+(c<=f?\"0.\"+u.call(\"0\",f-c)+g:g.slice(0,c-f)+\".\"+g.slice(c-f))):g=y+g,g}})},{110:110,116:116,33:33,35:35,4:4}],189:[function(t,n,r){\"use strict\";var e=t(33),i=t(35),o=t(4),u=1..toPrecision;e(e.P+e.F*(i(function(){return\"1\"!==u.call(1,void 0)})||!i(function(){u.call({})})),\"Number\",{toPrecision:function toPrecision(t){var n=o(this,\"Number#toPrecision: incorrect invocation!\");return void 0===t?u.call(n):u.call(n,t)}})},{33:33,35:35,4:4}],190:[function(t,n,r){var e=t(33);e(e.S+e.F,\"Object\",{assign:t(70)})},{33:33,70:70}],191:[function(t,n,r){var e=t(33);e(e.S,\"Object\",{create:t(71)})},{33:33,71:71}],192:[function(t,n,r){var e=t(33);e(e.S+e.F*!t(29),\"Object\",{defineProperties:t(73)})},{29:29,33:33,73:73}],193:[function(t,n,r){var e=t(33);e(e.S+e.F*!t(29),\"Object\",{defineProperty:t(72).f})},{29:29,33:33,72:72}],194:[function(t,n,r){var e=t(51),i=t(66).onFreeze;t(83)(\"freeze\",function(t){return function freeze(n){return t&&e(n)?t(i(n)):n}})},{51:51,66:66,83:83}],195:[function(t,n,r){var e=t(117),i=t(75).f;t(83)(\"getOwnPropertyDescriptor\",function(){return function getOwnPropertyDescriptor(t,n){return i(e(t),n)}})},{117:117,75:75,83:83}],196:[function(t,n,r){t(83)(\"getOwnPropertyNames\",function(){return t(76).f})},{76:76,83:83}],197:[function(t,n,r){var e=t(119),i=t(79);t(83)(\"getPrototypeOf\",function(){return function getPrototypeOf(t){return i(e(t))}})},{119:119,79:79,83:83}],198:[function(t,n,r){var e=t(51);t(83)(\"isExtensible\",function(t){return function isExtensible(n){return!!e(n)&&(!t||t(n))}})},{51:51,83:83}],199:[function(t,n,r){var e=t(51);t(83)(\"isFrozen\",function(t){return function isFrozen(n){return!e(n)||!!t&&t(n)}})},{51:51,83:83}],200:[function(t,n,r){var e=t(51);t(83)(\"isSealed\",function(t){return function isSealed(n){return!e(n)||!!t&&t(n)}})},{51:51,83:83}],201:[function(t,n,r){var e=t(33);e(e.S,\"Object\",{is:t(96)})},{33:33,96:96}],202:[function(t,n,r){var e=t(119),i=t(81);t(83)(\"keys\",function(){return function keys(t){return i(e(t))}})},{119:119,81:81,83:83}],203:[function(t,n,r){var e=t(51),i=t(66).onFreeze;t(83)(\"preventExtensions\",function(t){return function preventExtensions(n){return t&&e(n)?t(i(n)):n}})},{51:51,66:66,83:83}],204:[function(t,n,r){var e=t(51),i=t(66).onFreeze;t(83)(\"seal\",function(t){return function seal(n){return t&&e(n)?t(i(n)):n}})},{51:51,66:66,83:83}],205:[function(t,n,r){var e=t(33);e(e.S,\"Object\",{setPrototypeOf:t(99).set})},{33:33,99:99}],206:[function(t,n,r){\"use strict\";var e=t(17),i={};i[t(128)(\"toStringTag\")]=\"z\",i+\"\"!=\"[object z]\"&&t(94)(Object.prototype,\"toString\",function toString(){return\"[object \"+e(this)+\"]\"},!0)},{128:128,17:17,94:94}],207:[function(t,n,r){var e=t(33),i=t(86);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},{33:33,86:86}],208:[function(t,n,r){var e=t(33),i=t(87);e(e.G+e.F*(parseInt!=i),{parseInt:i})},{33:33,87:87}],209:[function(t,n,r){\"use strict\";var e,i,o,u,c=t(60),a=t(40),f=t(25),s=t(17),l=t(33),h=t(51),v=t(3),p=t(6),d=t(39),y=t(104),g=t(113).set,m=t(68)(),b=t(69),x=t(90),S=t(91),w=a.TypeError,_=a.process,E=a.Promise,O=\"process\"==s(_),P=function(){},M=i=b.f,F=!!function(){try{var n=E.resolve(1),r=(n.constructor={})[t(128)(\"species\")]=function(t){t(P,P)};return(O||\"function\"==typeof PromiseRejectionEvent)&&n.then(P)instanceof r}catch(t){}}(),I=c?function(t,n){return t===n||t===E&&n===u}:function(t,n){return t===n},A=function(t){var n;return!(!h(t)||\"function\"!=typeof(n=t.then))&&n},k=function(t,n){if(!t._n){t._n=!0;var r=t._c;m(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,a=n.reject,f=n.domain;try{u?(i||(2==t._h&&T(t),t._h=1),!0===u?r=e:(f&&f.enter(),r=u(e),f&&f.exit()),r===n.promise?a(w(\"Promise-chain cycle\")):(o=A(r))?o.call(r,c,a):c(r)):a(e)}catch(t){a(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){g.call(a,function(){var n,r,e,i=t._v,o=j(t);if(o&&(n=x(function(){O?_.emit(\"unhandledRejection\",i,t):(r=a.onunhandledrejection)?r({promise:t,reason:i}):(e=a.console)&&e.error&&e.error(\"Unhandled promise rejection\",i)}),t._h=O||j(t)?2:1),t._a=void 0,o&&n.e)throw n.v})},j=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!j(n.promise))return!1;return!0},T=function(t){g.call(a,function(){var n;O?_.emit(\"rejectionHandled\",t):(n=a.onrejectionhandled)&&n({promise:t,reason:t._v})})},R=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),k(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw w(\"Promise can't be resolved itself\");(n=A(t))?m(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(R,e,1))}catch(t){R.call(e,t)}}):(r._v=t,r._s=1,k(r,!1))}catch(t){R.call({_w:r,_d:!1},t)}}};F||(E=function Promise(t){p(this,E,\"Promise\",\"_h\"),v(t),e.call(this);try{t(f(L,this,1),f(R,this,1))}catch(t){R.call(this,t)}},e=function Promise(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=t(93)(E.prototype,{then:function then(t,n){var r=M(y(this,E));return r.ok=\"function\"!=typeof t||t,r.fail=\"function\"==typeof n&&n,r.domain=O?_.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&k(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),o=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(R,t,1)},b.f=M=function(t){return I(E,t)?new o(t):i(t)}),l(l.G+l.W+l.F*!F,{Promise:E}),t(101)(E,\"Promise\"),t(100)(\"Promise\"),u=t(23).Promise,l(l.S+l.F*!F,\"Promise\",{reject:function reject(t){var n=M(this);return(0,n.reject)(t),n.promise}}),l(l.S+l.F*(c||!F),\"Promise\",{resolve:function resolve(t){return t instanceof E&&I(t.constructor,this)?t:S(this,t)}}),l(l.S+l.F*!(F&&t(56)(function(t){E.all(t).catch(P)})),\"Promise\",{all:function all(t){var n=this,r=M(n),e=r.resolve,i=r.reject,o=x(function(){var r=[],o=0,u=1;d(t,!1,function(t){var c=o++,a=!1;r.push(void 0),u++,n.resolve(t).then(function(t){a||(a=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o.e&&i(o.v),r.promise},race:function race(t){var n=this,r=M(n),e=r.reject,i=x(function(){d(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i.e&&e(i.v),r.promise}})},{100:100,101:101,104:104,113:113,128:128,17:17,23:23,25:25,\n3:3,33:33,39:39,40:40,51:51,56:56,6:6,60:60,68:68,69:69,90:90,91:91,93:93}],210:[function(t,n,r){var e=t(33),i=t(3),o=t(7),u=(t(40).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!t(35)(function(){u(function(){})}),\"Reflect\",{apply:function apply(t,n,r){var e=i(t),a=o(r);return u?u(e,n,a):c.call(e,n,a)}})},{3:3,33:33,35:35,40:40,7:7}],211:[function(t,n,r){var e=t(33),i=t(71),o=t(3),u=t(7),c=t(51),a=t(35),f=t(16),s=(t(40).Reflect||{}).construct,l=a(function(){function F(){}return!(s(function(){},[],F)instanceof F)}),h=!a(function(){s(function(){})});e(e.S+e.F*(l||h),\"Reflect\",{construct:function construct(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(f.apply(t,e))}var a=r.prototype,v=i(c(a)?a:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},{16:16,3:3,33:33,35:35,40:40,51:51,7:7,71:71}],212:[function(t,n,r){var e=t(72),i=t(33),o=t(7),u=t(120);i(i.S+i.F*t(35)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),\"Reflect\",{defineProperty:function defineProperty(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},{120:120,33:33,35:35,7:7,72:72}],213:[function(t,n,r){var e=t(33),i=t(75).f,o=t(7);e(e.S,\"Reflect\",{deleteProperty:function deleteProperty(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},{33:33,7:7,75:75}],214:[function(t,n,r){\"use strict\";var e=t(33),i=t(7),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};t(54)(o,\"Object\",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,\"Reflect\",{enumerate:function enumerate(t){return new o(t)}})},{33:33,54:54,7:7}],215:[function(t,n,r){var e=t(75),i=t(33),o=t(7);i(i.S,\"Reflect\",{getOwnPropertyDescriptor:function getOwnPropertyDescriptor(t,n){return e.f(o(t),n)}})},{33:33,7:7,75:75}],216:[function(t,n,r){var e=t(33),i=t(79),o=t(7);e(e.S,\"Reflect\",{getPrototypeOf:function getPrototypeOf(t){return i(o(t))}})},{33:33,7:7,79:79}],217:[function(t,n,r){function get(t,n){var r,u,f=arguments.length<3?t:arguments[2];return a(t)===f?t[n]:(r=e.f(t,n))?o(r,\"value\")?r.value:void 0!==r.get?r.get.call(f):void 0:c(u=i(t))?get(u,n,f):void 0}var e=t(75),i=t(79),o=t(41),u=t(33),c=t(51),a=t(7);u(u.S,\"Reflect\",{get:get})},{33:33,41:41,51:51,7:7,75:75,79:79}],218:[function(t,n,r){var e=t(33);e(e.S,\"Reflect\",{has:function has(t,n){return n in t}})},{33:33}],219:[function(t,n,r){var e=t(33),i=t(7),o=Object.isExtensible;e(e.S,\"Reflect\",{isExtensible:function isExtensible(t){return i(t),!o||o(t)}})},{33:33,7:7}],220:[function(t,n,r){var e=t(33);e(e.S,\"Reflect\",{ownKeys:t(85)})},{33:33,85:85}],221:[function(t,n,r){var e=t(33),i=t(7),o=Object.preventExtensions;e(e.S,\"Reflect\",{preventExtensions:function preventExtensions(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},{33:33,7:7}],222:[function(t,n,r){var e=t(33),i=t(99);i&&e(e.S,\"Reflect\",{setPrototypeOf:function setPrototypeOf(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},{33:33,99:99}],223:[function(t,n,r){function set(t,n,r){var c,l,h=arguments.length<4?t:arguments[3],v=i.f(f(t),n);if(!v){if(s(l=o(t)))return set(l,n,r,h);v=a(0)}return u(v,\"value\")?!(!1===v.writable||!s(h))&&(c=i.f(h,n)||a(0),c.value=r,e.f(h,n,c),!0):void 0!==v.set&&(v.set.call(h,r),!0)}var e=t(72),i=t(75),o=t(79),u=t(41),c=t(33),a=t(92),f=t(7),s=t(51);c(c.S,\"Reflect\",{set:set})},{33:33,41:41,51:51,7:7,72:72,75:75,79:79,92:92}],224:[function(t,n,r){var e=t(40),i=t(45),o=t(72).f,u=t(77).f,c=t(52),a=t(37),f=e.RegExp,s=f,l=f.prototype,h=/a/g,v=/a/g,p=new f(h)!==h;if(t(29)&&(!p||t(35)(function(){return v[t(128)(\"match\")]=!1,f(h)!=h||f(v)==v||\"/a/i\"!=f(h,\"i\")}))){f=function RegExp(t,n){var r=this instanceof f,e=c(t),o=void 0===n;return!r&&e&&t.constructor===f&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof f)?t.source:t,e&&o?a.call(t):n),r?this:l,f)};for(var d=u(s),y=0;d.length>y;)!function(t){t in f||o(f,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=f,f.prototype=l,t(94)(e,\"RegExp\",f)}t(100)(\"RegExp\")},{100:100,128:128,29:29,35:35,37:37,40:40,45:45,52:52,72:72,77:77,94:94}],225:[function(t,n,r){t(29)&&\"g\"!=/./g.flags&&t(72).f(RegExp.prototype,\"flags\",{configurable:!0,get:t(37)})},{29:29,37:37,72:72}],226:[function(t,n,r){t(36)(\"match\",1,function(t,n,r){return[function match(r){\"use strict\";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},{36:36}],227:[function(t,n,r){t(36)(\"replace\",2,function(t,n,r){return[function replace(e,i){\"use strict\";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},{36:36}],228:[function(t,n,r){t(36)(\"search\",1,function(t,n,r){return[function search(r){\"use strict\";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},{36:36}],229:[function(t,n,r){t(36)(\"split\",2,function(n,r,e){\"use strict\";var i=t(52),o=e,u=[].push,c=\"length\";if(\"c\"==\"abbc\".split(/(b)*/)[1]||4!=\"test\".split(/(?:)/,-1)[c]||2!=\"ab\".split(/(?:ab)*/)[c]||4!=\".\".split(/(.?)(.?)/)[c]||\".\".split(/()()/)[c]>1||\"\".split(/.?/)[c]){var a=void 0===/()??/.exec(\"\")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,f,s,l,h,v=[],p=(t.ignoreCase?\"i\":\"\")+(t.multiline?\"m\":\"\")+(t.unicode?\"u\":\"\")+(t.sticky?\"y\":\"\"),d=0,y=void 0===n?4294967295:n>>>0,g=new RegExp(t.source,p+\"g\");for(a||(e=new RegExp(\"^\"+g.source+\"$(?!\\\\s)\",p));(f=g.exec(r))&&!((s=f.index+f[0][c])>d&&(v.push(r.slice(d,f.index)),!a&&f[c]>1&&f[0].replace(e,function(){for(h=1;h<arguments[c]-2;h++)void 0===arguments[h]&&(f[h]=void 0)}),f[c]>1&&f.index<r[c]&&u.apply(v,f.slice(1)),l=f[0][c],d=s,v[c]>=y));)g.lastIndex===f.index&&g.lastIndex++;return d===r[c]?!l&&g.test(\"\")||v.push(\"\"):v.push(r.slice(d)),v[c]>y?v.slice(0,y):v}}else\"0\".split(void 0,0)[c]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function split(t,i){var o=n(this),u=void 0==t?void 0:t[r];return void 0!==u?u.call(t,o,i):e.call(String(o),t,i)},e]})},{36:36,52:52}],230:[function(t,n,r){\"use strict\";t(225);var e=t(7),i=t(37),o=t(29),u=/./.toString,c=function(n){t(94)(RegExp.prototype,\"toString\",n,!0)};t(35)(function(){return\"/a/b\"!=u.call({source:\"a\",flags:\"b\"})})?c(function toString(){var t=e(this);return\"/\".concat(t.source,\"/\",\"flags\"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):\"toString\"!=u.name&&c(function toString(){return u.call(this)})},{225:225,29:29,35:35,37:37,7:7,94:94}],231:[function(t,n,r){\"use strict\";var e=t(19),i=t(125);n.exports=t(22)(\"Set\",function(t){return function Set(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function add(t){return e.def(i(this,\"Set\"),t=0===t?0:t,t)}},e)},{125:125,19:19,22:22}],232:[function(t,n,r){\"use strict\";t(108)(\"anchor\",function(t){return function anchor(n){return t(this,\"a\",\"name\",n)}})},{108:108}],233:[function(t,n,r){\"use strict\";t(108)(\"big\",function(t){return function big(){return t(this,\"big\",\"\",\"\")}})},{108:108}],234:[function(t,n,r){\"use strict\";t(108)(\"blink\",function(t){return function blink(){return t(this,\"blink\",\"\",\"\")}})},{108:108}],235:[function(t,n,r){\"use strict\";t(108)(\"bold\",function(t){return function bold(){return t(this,\"b\",\"\",\"\")}})},{108:108}],236:[function(t,n,r){\"use strict\";var e=t(33),i=t(106)(!1);e(e.P,\"String\",{codePointAt:function codePointAt(t){return i(this,t)}})},{106:106,33:33}],237:[function(t,n,r){\"use strict\";var e=t(33),i=t(118),o=t(107),u=\"\".endsWith;e(e.P+e.F*t(34)(\"endsWith\"),\"String\",{endsWith:function endsWith(t){var n=o(this,t,\"endsWith\"),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),c=void 0===r?e:Math.min(i(r),e),a=String(t);return u?u.call(n,a,c):n.slice(c-a.length,c)===a}})},{107:107,118:118,33:33,34:34}],238:[function(t,n,r){\"use strict\";t(108)(\"fixed\",function(t){return function fixed(){return t(this,\"tt\",\"\",\"\")}})},{108:108}],239:[function(t,n,r){\"use strict\";t(108)(\"fontcolor\",function(t){return function fontcolor(n){return t(this,\"font\",\"color\",n)}})},{108:108}],240:[function(t,n,r){\"use strict\";t(108)(\"fontsize\",function(t){return function fontsize(n){return t(this,\"font\",\"size\",n)}})},{108:108}],241:[function(t,n,r){var e=t(33),i=t(114),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),\"String\",{fromCodePoint:function fromCodePoint(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+\" is not a valid code point\");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join(\"\")}})},{114:114,33:33}],242:[function(t,n,r){\"use strict\";var e=t(33),i=t(107);e(e.P+e.F*t(34)(\"includes\"),\"String\",{includes:function includes(t){return!!~i(this,t,\"includes\").indexOf(t,arguments.length>1?arguments[1]:void 0)}})},{107:107,33:33,34:34}],243:[function(t,n,r){\"use strict\";t(108)(\"italics\",function(t){return function italics(){return t(this,\"i\",\"\",\"\")}})},{108:108}],244:[function(t,n,r){\"use strict\";var e=t(106)(!0);t(55)(String,\"String\",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},{106:106,55:55}],245:[function(t,n,r){\"use strict\";t(108)(\"link\",function(t){return function link(n){return t(this,\"a\",\"href\",n)}})},{108:108}],246:[function(t,n,r){var e=t(33),i=t(117),o=t(118);e(e.S,\"String\",{raw:function raw(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join(\"\")}})},{117:117,118:118,33:33}],247:[function(t,n,r){var e=t(33);e(e.P,\"String\",{repeat:t(110)})},{110:110,33:33}],248:[function(t,n,r){\"use strict\";t(108)(\"small\",function(t){return function small(){return t(this,\"small\",\"\",\"\")}})},{108:108}],249:[function(t,n,r){\"use strict\";var e=t(33),i=t(118),o=t(107),u=\"\".startsWith;e(e.P+e.F*t(34)(\"startsWith\"),\"String\",{startsWith:function startsWith(t){var n=o(this,t,\"startsWith\"),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return u?u.call(n,e,r):n.slice(r,r+e.length)===e}})},{107:107,118:118,33:33,34:34}],250:[function(t,n,r){\"use strict\";t(108)(\"strike\",function(t){return function strike(){return t(this,\"strike\",\"\",\"\")}})},{108:108}],251:[function(t,n,r){\"use strict\";t(108)(\"sub\",function(t){return function sub(){return t(this,\"sub\",\"\",\"\")}})},{108:108}],252:[function(t,n,r){\"use strict\";t(108)(\"sup\",function(t){return function sup(){return t(this,\"sup\",\"\",\"\")}})},{108:108}],253:[function(t,n,r){\"use strict\";t(111)(\"trim\",function(t){return function trim(){return t(this,3)}})},{111:111}],254:[function(t,n,r){\"use strict\";var e=t(40),i=t(41),o=t(29),u=t(33),c=t(94),a=t(66).KEY,f=t(35),s=t(103),l=t(101),h=t(124),v=t(128),p=t(127),d=t(126),y=t(59),g=t(32),m=t(49),b=t(7),x=t(117),S=t(120),w=t(92),_=t(71),E=t(76),O=t(75),P=t(72),M=t(81),F=O.f,I=P.f,A=E.f,k=e.Symbol,N=e.JSON,j=N&&N.stringify,T=v(\"_hidden\"),R=v(\"toPrimitive\"),L={}.propertyIsEnumerable,G=s(\"symbol-registry\"),D=s(\"symbols\"),C=s(\"op-symbols\"),W=Object.prototype,U=\"function\"==typeof k,B=e.QObject,V=!B||!B.prototype||!B.prototype.findChild,z=o&&f(function(){return 7!=_(I({},\"a\",{get:function(){return I(this,\"a\",{value:7}).a}})).a})?function(t,n,r){var e=F(W,n);e&&delete W[n],I(t,n,r),e&&t!==W&&I(W,n,e)}:I,q=function(t){var n=D[t]=_(k.prototype);return n._k=t,n},K=U&&\"symbol\"==typeof k.iterator?function(t){return\"symbol\"==typeof t}:function(t){return t instanceof k},Y=function defineProperty(t,n,r){return t===W&&Y(C,n,r),b(t),n=S(n,!0),b(r),i(D,n)?(r.enumerable?(i(t,T)&&t[T][n]&&(t[T][n]=!1),r=_(r,{enumerable:w(0,!1)})):(i(t,T)||I(t,T,w(1,{})),t[T][n]=!0),z(t,n,r)):I(t,n,r)},J=function defineProperties(t,n){b(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},H=function create(t,n){return void 0===n?_(t):J(_(t),n)},X=function propertyIsEnumerable(t){var n=L.call(this,t=S(t,!0));return!(this===W&&i(D,t)&&!i(C,t))&&(!(n||!i(this,t)||!i(D,t)||i(this,T)&&this[T][t])||n)},$=function getOwnPropertyDescriptor(t,n){if(t=x(t),n=S(n,!0),t!==W||!i(D,n)||i(C,n)){var r=F(t,n);return!r||!i(D,n)||i(t,T)&&t[T][n]||(r.enumerable=!0),r}},Z=function getOwnPropertyNames(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(D,n=r[o++])||n==T||n==a||e.push(n);return e},Q=function getOwnPropertySymbols(t){for(var n,r=t===W,e=A(r?C:x(t)),o=[],u=0;e.length>u;)!i(D,n=e[u++])||r&&!i(W,n)||o.push(D[n]);return o};U||(k=function Symbol(){if(this instanceof k)throw TypeError(\"Symbol is not a constructor!\");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===W&&n.call(C,r),i(this,T)&&i(this[T],t)&&(this[T][t]=!1),z(this,t,w(1,r))};return o&&V&&z(W,t,{configurable:!0,set:n}),q(t)},c(k.prototype,\"toString\",function toString(){return this._k}),O.f=$,P.f=Y,t(77).f=E.f=Z,t(82).f=X,t(78).f=Q,o&&!t(60)&&c(W,\"propertyIsEnumerable\",X,!0),p.f=function(t){return q(v(t))}),u(u.G+u.W+u.F*!U,{Symbol:k});for(var tt=\"hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables\".split(\",\"),nt=0;tt.length>nt;)v(tt[nt++]);for(var rt=M(v.store),et=0;rt.length>et;)d(rt[et++]);u(u.S+u.F*!U,\"Symbol\",{for:function(t){return i(G,t+=\"\")?G[t]:G[t]=k(t)},keyFor:function keyFor(t){if(K(t))return y(G,t);throw TypeError(t+\" is not a symbol!\")},useSetter:function(){V=!0},useSimple:function(){V=!1}}),u(u.S+u.F*!U,\"Object\",{create:H,defineProperty:Y,defineProperties:J,getOwnPropertyDescriptor:$,getOwnPropertyNames:Z,getOwnPropertySymbols:Q}),N&&u(u.S+u.F*(!U||f(function(){var t=k();return\"[null]\"!=j([t])||\"{}\"!=j({a:t})||\"{}\"!=j(Object(t))})),\"JSON\",{stringify:function stringify(t){if(void 0!==t&&!K(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],\"function\"==typeof n&&(r=n),!r&&m(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!K(n))return n}),e[1]=n,j.apply(N,e)}}}),k.prototype[R]||t(42)(k.prototype,R,k.prototype.valueOf),l(k,\"Symbol\"),l(Math,\"Math\",!0),l(e.JSON,\"JSON\",!0)},{101:101,103:103,117:117,120:120,124:124,126:126,127:127,128:128,29:29,32:32,33:33,35:35,40:40,41:41,42:42,49:49,59:59,60:60,66:66,7:7,71:71,72:72,75:75,76:76,77:77,78:78,81:81,82:82,92:92,94:94}],255:[function(t,n,r){\"use strict\";var e=t(33),i=t(123),o=t(122),u=t(7),c=t(114),a=t(118),f=t(51),s=t(40).ArrayBuffer,l=t(104),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW;e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,\"ArrayBuffer\",{isView:function isView(t){return p&&p(t)||f(t)&&y in t}}),e(e.P+e.U+e.F*t(35)(function(){return!new h(2).slice(1,void 0).byteLength}),\"ArrayBuffer\",{slice:function slice(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(a(i-e)),f=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,f.getUint8(e++));return o}}),t(100)(\"ArrayBuffer\")},{100:100,104:104,114:114,118:118,122:122,123:123,33:33,35:35,40:40,51:51,7:7}],256:[function(t,n,r){var e=t(33);e(e.G+e.W+e.F*!t(123).ABV,{DataView:t(122).DataView})},{122:122,123:123,33:33}],257:[function(t,n,r){t(121)(\"Float32\",4,function(t){return function Float32Array(n,r,e){return t(this,n,r,e)}})},{121:121}],258:[function(t,n,r){t(121)(\"Float64\",8,function(t){return function Float64Array(n,r,e){return t(this,n,r,e)}})},{121:121}],259:[function(t,n,r){t(121)(\"Int16\",2,function(t){return function Int16Array(n,r,e){return t(this,n,r,e)}})},{121:121}],260:[function(t,n,r){t(121)(\"Int32\",4,function(t){return function Int32Array(n,r,e){return t(this,n,r,e)}})},{121:121}],261:[function(t,n,r){t(121)(\"Int8\",1,function(t){return function Int8Array(n,r,e){return t(this,n,r,e)}})},{121:121}],262:[function(t,n,r){t(121)(\"Uint16\",2,function(t){return function Uint16Array(n,r,e){return t(this,n,r,e)}})},{121:121}],263:[function(t,n,r){t(121)(\"Uint32\",4,function(t){return function Uint32Array(n,r,e){return t(this,n,r,e)}})},{121:121}],264:[function(t,n,r){t(121)(\"Uint8\",1,function(t){return function Uint8Array(n,r,e){return t(this,n,r,e)}})},{121:121}],265:[function(t,n,r){t(121)(\"Uint8\",1,function(t){return function Uint8ClampedArray(n,r,e){return t(this,n,r,e)}},!0)},{121:121}],266:[function(t,n,r){\"use strict\";var e,i=t(12)(0),o=t(94),u=t(66),c=t(70),a=t(21),f=t(51),s=t(35),l=t(125),h=u.getWeak,v=Object.isExtensible,p=a.ufstore,d={},y=function(t){return function WeakMap(){return t(this,arguments.length>0?arguments[0]:void 0)}},g={get:function get(t){if(f(t)){var n=h(t);return!0===n?p(l(this,\"WeakMap\")).get(t):n?n[this._i]:void 0}},set:function set(t,n){return a.def(l(this,\"WeakMap\"),t,n)}},m=n.exports=t(22)(\"WeakMap\",y,g,a,!0,!0);s(function(){return 7!=(new m).set((Object.freeze||Object)(d),7).get(d)})&&(e=a.getConstructor(y,\"WeakMap\"),c(e.prototype,g),u.NEED=!0,i([\"delete\",\"has\",\"get\",\"set\"],function(t){var n=m.prototype,r=n[t];o(n,t,function(n,i){if(f(n)&&!v(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return\"set\"==t?this:o}return r.call(this,n,i)})}))},{12:12,125:125,21:21,22:22,35:35,51:51,66:66,70:70,94:94}],267:[function(t,n,r){\"use strict\";var e=t(21),i=t(125);t(22)(\"WeakSet\",function(t){return function WeakSet(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function add(t){return e.def(i(this,\"WeakSet\"),t,!0)}},e,!1,!0)},{125:125,21:21,22:22}],268:[function(t,n,r){\"use strict\";var e=t(33),i=t(38),o=t(119),u=t(118),c=t(3),a=t(15);e(e.P,\"Array\",{flatMap:function flatMap(t){var n,r,e=o(this);return c(t),n=u(e.length),r=a(e,0),i(r,e,e,n,0,1,t,arguments[1]),r}}),t(5)(\"flatMap\")},{118:118,119:119,15:15,3:3,33:33,38:38,5:5}],269:[function(t,n,r){\"use strict\";var e=t(33),i=t(38),o=t(119),u=t(118),c=t(116),a=t(15);e(e.P,\"Array\",{flatten:function flatten(){var t=arguments[0],n=o(this),r=u(n.length),e=a(n,0);return i(e,n,n,r,0,void 0===t?1:c(t)),e}}),t(5)(\"flatten\")},{116:116,118:118,119:119,15:15,33:33,38:38,5:5}],270:[function(t,n,r){\"use strict\";var e=t(33),i=t(11)(!0);e(e.P,\"Array\",{includes:function includes(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),t(5)(\"includes\")},{11:11,33:33,5:5}],271:[function(t,n,r){var e=t(33),i=t(68)(),o=t(40).process,u=\"process\"==t(18)(o);e(e.G,{asap:function asap(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},{18:18,33:33,40:40,68:68}],272:[function(t,n,r){var e=t(33),i=t(18);e(e.S,\"Error\",{isError:function isError(t){return\"Error\"===i(t)}})},{18:18,33:33}],273:[function(t,n,r){var e=t(33);e(e.G,{global:t(40)})},{33:33,40:40}],274:[function(t,n,r){t(97)(\"Map\")},{97:97}],275:[function(t,n,r){t(98)(\"Map\")},{98:98}],276:[function(t,n,r){var e=t(33);e(e.P+e.R,\"Map\",{toJSON:t(20)(\"Map\")})},{20:20,33:33}],277:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{clamp:function clamp(t,n,r){return Math.min(r,Math.max(n,t))}})},{33:33}],278:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{DEG_PER_RAD:Math.PI/180})},{33:33}],279:[function(t,n,r){var e=t(33),i=180/Math.PI;e(e.S,\"Math\",{degrees:function degrees(t){return t*i}})},{33:33}],280:[function(t,n,r){var e=t(33),i=t(64),o=t(62);e(e.S,\"Math\",{fscale:function fscale(t,n,r,e,u){return o(i(t,n,r,e,u))}})},{33:33,62:62,64:64}],281:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{iaddh:function iaddh(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},{33:33}],282:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{imulh:function imulh(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>16,c=e>>16,a=(u*o>>>0)+(i*o>>>16);return u*c+(a>>16)+((i*c>>>0)+(65535&a)>>16)}})},{33:33}],283:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{isubh:function isubh(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},{33:33}],284:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{RAD_PER_DEG:180/Math.PI})},{33:33}],285:[function(t,n,r){var e=t(33),i=Math.PI/180;e(e.S,\"Math\",{radians:function radians(t){return t*i}})},{33:33}],286:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{scale:t(64)})},{33:33,64:64}],287:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{signbit:function signbit(t){return(t=+t)!=t?t:0==t?1/t==1/0:t>0}})},{33:33}],288:[function(t,n,r){var e=t(33);e(e.S,\"Math\",{umulh:function umulh(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>>16,c=e>>>16,a=(u*o>>>0)+(i*o>>>16);return u*c+(a>>>16)+((i*c>>>0)+(65535&a)>>>16)}})},{33:33}],289:[function(t,n,r){\"use strict\";var e=t(33),i=t(119),o=t(3),u=t(72);t(29)&&e(e.P+t(74),\"Object\",{__defineGetter__:function __defineGetter__(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},{119:119,29:29,3:3,33:33,72:72,74:74}],290:[function(t,n,r){\"use strict\";var e=t(33),i=t(119),o=t(3),u=t(72);t(29)&&e(e.P+t(74),\"Object\",{__defineSetter__:function __defineSetter__(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},{119:119,29:29,3:3,33:33,72:72,74:74}],291:[function(t,n,r){var e=t(33),i=t(84)(!0);e(e.S,\"Object\",{entries:function entries(t){return i(t)}})},{33:33,84:84}],292:[function(t,n,r){var e=t(33),i=t(85),o=t(117),u=t(75),c=t(24);e(e.S,\"Object\",{getOwnPropertyDescriptors:function getOwnPropertyDescriptors(t){for(var n,r,e=o(t),a=u.f,f=i(e),s={},l=0;f.length>l;)void 0!==(r=a(e,n=f[l++]))&&c(s,n,r);return s}})},{117:117,24:24,33:33,75:75,85:85}],293:[function(t,n,r){\"use strict\";var e=t(33),i=t(119),o=t(120),u=t(79),c=t(75).f;t(29)&&e(e.P+t(74),\"Object\",{__lookupGetter__:function __lookupGetter__(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},{119:119,120:120,29:29,33:33,74:74,75:75,79:79}],294:[function(t,n,r){\"use strict\";var e=t(33),i=t(119),o=t(120),u=t(79),c=t(75).f;t(29)&&e(e.P+t(74),\"Object\",{__lookupSetter__:function __lookupSetter__(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},{119:119,120:120,29:29,33:33,74:74,75:75,79:79}],295:[function(t,n,r){var e=t(33),i=t(84)(!1);e(e.S,\"Object\",{values:function values(t){return i(t)}})},{33:33,84:84}],296:[function(t,n,r){\"use strict\";var e=t(33),i=t(40),o=t(23),u=t(68)(),c=t(128)(\"observable\"),a=t(3),f=t(7),s=t(6),l=t(93),h=t(42),v=t(39),p=v.RETURN,d=function(t){return null==t?void 0:a(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},m=function(t){g(t)||(t._o=void 0,y(t))},b=function(t,n){f(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&(\"function\"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:a(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};b.prototype=l({},{unsubscribe:function unsubscribe(){m(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function next(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{m(n)}finally{throw t}}}},error:function error(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function complete(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var S=function Observable(t){s(this,S,\"Observable\",\"_f\")._f=a(t)};l(S.prototype,{subscribe:function subscribe(t){return new b(t,this._f)},forEach:function forEach(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){a(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(S,{from:function from(t){var n=\"function\"==typeof this?this:S,r=d(f(t)[c]);if(r){var e=f(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function of(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new(\"function\"==typeof this?this:S)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(S.prototype,c,function(){return this}),e(e.G,{Observable:S}),t(100)(\"Observable\")},{100:100,128:128,23:23,3:3,33:33,39:39,40:40,42:42,6:6,68:68,7:7,93:93}],297:[function(t,n,r){\"use strict\";var e=t(33),i=t(23),o=t(40),u=t(104),c=t(91);e(e.P+e.R,\"Promise\",{finally:function(t){var n=u(this,i.Promise||o.Promise),r=\"function\"==typeof t;return this.then(r?function(r){return c(n,t()).then(function(){return r})}:t,r?function(r){return c(n,t()).then(function(){throw r})}:t)}})},{104:104,23:23,33:33,40:40,91:91}],298:[function(t,n,r){\"use strict\";var e=t(33),i=t(69),o=t(90);e(e.S,\"Promise\",{try:function(t){var n=i.f(this),r=o(t);return(r.e?n.reject:n.resolve)(r.v),n.promise}})},{33:33,69:69,90:90}],299:[function(t,n,r){var e=t(67),i=t(7),o=e.key,u=e.set;e.exp({defineMetadata:function defineMetadata(t,n,r,e){u(t,n,i(r),o(e))}})},{67:67,7:7}],300:[function(t,n,r){var e=t(67),i=t(7),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function deleteMetadata(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var a=c.get(n);return a.delete(r),!!a.size||c.delete(n)}})},{67:67,7:7}],301:[function(t,n,r){var e=t(231),i=t(10),o=t(67),u=t(7),c=t(79),a=o.keys,f=o.key,s=function(t,n){var r=a(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function getMetadataKeys(t){return s(u(t),arguments.length<2?void 0:f(arguments[1]))}})},{10:10,231:231,67:67,7:7,79:79}],302:[function(t,n,r){var e=t(67),i=t(7),o=t(79),u=e.has,c=e.get,a=e.key,f=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?f(t,e,r):void 0};e.exp({getMetadata:function getMetadata(t,n){return f(t,i(n),arguments.length<3?void 0:a(arguments[2]))}})},{67:67,7:7,79:79}],303:[function(t,n,r){var e=t(67),i=t(7),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function getOwnMetadataKeys(t){return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},{67:67,7:7}],304:[function(t,n,r){var e=t(67),i=t(7),o=e.get,u=e.key;e.exp({getOwnMetadata:function getOwnMetadata(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},{67:67,7:7}],305:[function(t,n,r){var e=t(67),i=t(7),o=t(79),u=e.has,c=e.key,a=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&a(t,e,r)};e.exp({hasMetadata:function hasMetadata(t,n){return a(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},{67:67,7:7,79:79}],306:[function(t,n,r){var e=t(67),i=t(7),o=e.has,u=e.key;e.exp({hasOwnMetadata:function hasOwnMetadata(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},{67:67,7:7}],307:[function(t,n,r){var e=t(67),i=t(7),o=t(3),u=e.key,c=e.set;e.exp({metadata:function metadata(t,n){return function decorator(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},{3:3,67:67,7:7}],308:[function(t,n,r){t(97)(\"Set\")},{97:97}],309:[function(t,n,r){t(98)(\"Set\")},{98:98}],310:[function(t,n,r){var e=t(33);e(e.P+e.R,\"Set\",{toJSON:t(20)(\"Set\")})},{20:20,33:33}],311:[function(t,n,r){\"use strict\";var e=t(33),i=t(106)(!0);e(e.P,\"String\",{at:function at(t){return i(this,t)}})},{106:106,33:33}],312:[function(t,n,r){\"use strict\";var e=t(33),i=t(28),o=t(118),u=t(52),c=t(37),a=RegExp.prototype,f=function(t,n){this._r=t,this._s=n};t(54)(f,\"RegExp String\",function next(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,\"String\",{matchAll:function matchAll(t){if(i(this),!u(t))throw TypeError(t+\" is not a regexp!\");var n=String(this),r=\"flags\"in a?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf(\"g\")?r:\"g\"+r);return e.lastIndex=o(t.lastIndex),new f(e,n)}})},{118:118,28:28,33:33,37:37,52:52,54:54}],313:[function(t,n,r){\"use strict\";var e=t(33),i=t(109);e(e.P,\"String\",{padEnd:function padEnd(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},{109:109,33:33}],314:[function(t,n,r){\"use strict\";var e=t(33),i=t(109);e(e.P,\"String\",{padStart:function padStart(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},{109:109,33:33}],315:[function(t,n,r){\"use strict\";t(111)(\"trimLeft\",function(t){return function trimLeft(){return t(this,1)}},\"trimStart\")},{111:111}],316:[function(t,n,r){\"use strict\";t(111)(\"trimRight\",function(t){return function trimRight(){return t(this,2)}},\"trimEnd\")},{111:111}],317:[function(t,n,r){t(126)(\"asyncIterator\")},{126:126}],318:[function(t,n,r){t(126)(\"observable\")},{126:126}],319:[function(t,n,r){var e=t(33);e(e.S,\"System\",{global:t(40)})},{33:33,40:40}],320:[function(t,n,r){t(97)(\"WeakMap\")},{97:97}],321:[function(t,n,r){t(98)(\"WeakMap\")},{98:98}],322:[function(t,n,r){t(97)(\"WeakSet\")},{97:97}],323:[function(t,n,r){t(98)(\"WeakSet\")},{98:98}],324:[function(t,n,r){for(var e=t(141),i=t(81),o=t(94),u=t(40),c=t(42),a=t(58),f=t(128),s=f(\"iterator\"),l=f(\"toStringTag\"),h=a.Array,v={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=i(v),d=0;d<p.length;d++){var y,g=p[d],m=v[g],b=u[g],x=b&&b.prototype;if(x&&(x[s]||c(x,s,h),x[l]||c(x,l,g),a[g]=h,m))for(y in e)x[y]||o(x,y,e[y],!0)}},{128:128,141:141,40:40,42:42,58:58,81:81,94:94}],325:[function(t,n,r){var e=t(33),i=t(113);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},{113:113,33:33}],326:[function(t,n,r){var e=t(40),i=t(33),o=t(46),u=t(88),c=e.navigator,a=!!c&&/MSIE .\\./.test(c.userAgent),f=function(t){return a?function(n,r){return t(o(u,[].slice.call(arguments,2),\"function\"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*a,{setTimeout:f(e.setTimeout),setInterval:f(e.setInterval)})},{33:33,40:40,46:46,88:88}],327:[function(t,n,r){t(254),t(191),t(193),t(192),t(195),t(197),t(202),t(196),t(194),t(204),t(203),t(199),t(200),t(198),t(190),t(201),t(205),t(206),t(157),t(159),t(158),t(208),t(207),t(178),t(188),t(189),t(179),t(180),t(181),t(182),t(183),t(184),t(185),t(186),t(187),t(161),t(162),t(163),t(164),t(165),t(166),t(167),t(168),t(169),t(170),t(171),t(172),t(173),t(174),t(175),t(176),t(177),t(241),t(246),t(253),t(244),t(236),t(237),t(242),t(247),t(249),t(232),t(233),t(234),t(235),t(238),t(239),t(240),t(243),t(245),t(248),t(250),t(251),t(252),t(152),t(154),t(153),t(156),t(155),t(140),t(138),t(145),t(142),t(148),t(150),t(137),t(144),t(134),t(149),t(132),t(147),t(146),t(139),t(143),t(131),t(133),t(136),t(135),t(151),t(141),t(224),t(230),t(225),t(226),t(227),t(228),t(229),t(209),t(160),t(231),t(266),t(267),t(255),t(256),t(261),t(264),t(265),t(259),t(262),t(260),t(263),t(257),t(258),t(210),t(211),t(212),t(213),t(214),t(217),t(215),t(216),t(218),t(219),t(220),t(221),t(223),t(222),t(270),t(268),t(269),t(311),t(314),t(313),t(315),t(316),t(312),t(317),t(318),t(292),t(295),t(291),t(289),t(290),t(293),t(294),t(276),t(310),t(275),t(309),t(321),t(323),t(274),t(308),t(320),t(322),t(273),t(319),t(272),t(277),t(278),t(279),t(280),t(281),t(283),t(282),t(284),t(285),t(286),t(288),t(287),t(297),t(298),t(299),t(300),t(302),t(301),t(304),t(303),t(305),t(306),t(307),t(271),t(296),t(326),t(325),t(324),n.exports=t(23)},{131:131,132:132,133:133,134:134,135:135,136:136,137:137,138:138,139:139,140:140,141:141,142:142,143:143,144:144,145:145,146:146,147:147,148:148,149:149,150:150,151:151,152:152,153:153,154:154,155:155,156:156,157:157,158:158,159:159,160:160,161:161,162:162,163:163,164:164,165:165,166:166,167:167,168:168,169:169,170:170,171:171,172:172,173:173,174:174,175:175,176:176,177:177,178:178,179:179,180:180,181:181,182:182,183:183,184:184,185:185,\n186:186,187:187,188:188,189:189,190:190,191:191,192:192,193:193,194:194,195:195,196:196,197:197,198:198,199:199,200:200,201:201,202:202,203:203,204:204,205:205,206:206,207:207,208:208,209:209,210:210,211:211,212:212,213:213,214:214,215:215,216:216,217:217,218:218,219:219,220:220,221:221,222:222,223:223,224:224,225:225,226:226,227:227,228:228,229:229,23:23,230:230,231:231,232:232,233:233,234:234,235:235,236:236,237:237,238:238,239:239,240:240,241:241,242:242,243:243,244:244,245:245,246:246,247:247,248:248,249:249,250:250,251:251,252:252,253:253,254:254,255:255,256:256,257:257,258:258,259:259,260:260,261:261,262:262,263:263,264:264,265:265,266:266,267:267,268:268,269:269,270:270,271:271,272:272,273:273,274:274,275:275,276:276,277:277,278:278,279:279,280:280,281:281,282:282,283:283,284:284,285:285,286:286,287:287,288:288,289:289,290:290,291:291,292:292,293:293,294:294,295:295,296:296,297:297,298:298,299:299,300:300,301:301,302:302,303:303,304:304,305:305,306:306,307:307,308:308,309:309,310:310,311:311,312:312,313:313,314:314,315:315,316:316,317:317,318:318,319:319,320:320,321:321,322:322,323:323,324:324,325:325,326:326}],328:[function(t,n,r){(function(t){!function(t){\"use strict\";function wrap(t,n,r,e){var i=n&&n.prototype instanceof Generator?n:Generator,o=Object.create(i.prototype),u=new Context(e||[]);return o._invoke=makeInvokeMethod(t,r,u),o}function tryCatch(t,n,r){try{return{type:\"normal\",arg:t.call(n,r)}}catch(t){return{type:\"throw\",arg:t}}}function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}function defineIteratorMethods(t){[\"next\",\"throw\",\"return\"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function AsyncIterator(n){function invoke(t,r,e,o){var u=tryCatch(n[t],n,r);if(\"throw\"!==u.type){var c=u.arg,a=c.value;return a&&\"object\"==typeof a&&i.call(a,\"__await\")?Promise.resolve(a.__await).then(function(t){invoke(\"next\",t,e,o)},function(t){invoke(\"throw\",t,e,o)}):Promise.resolve(a).then(function(t){c.value=t,e(c)},o)}o(u.arg)}function enqueue(t,n){function callInvokeWithMethodAndArg(){return new Promise(function(r,e){invoke(t,n,r,e)})}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}\"object\"==typeof t.process&&t.process.domain&&(invoke=t.process.domain.bind(invoke));var r;this._invoke=enqueue}function makeInvokeMethod(t,n,r){var e=l;return function invoke(i,o){if(e===v)throw new Error(\"Generator is already running\");if(e===p){if(\"throw\"===i)throw o;return doneResult()}for(r.method=i,r.arg=o;;){var u=r.delegate;if(u){var c=maybeInvokeDelegate(u,r);if(c){if(c===d)continue;return c}}if(\"next\"===r.method)r.sent=r._sent=r.arg;else if(\"throw\"===r.method){if(e===l)throw e=p,r.arg;r.dispatchException(r.arg)}else\"return\"===r.method&&r.abrupt(\"return\",r.arg);e=v;var a=tryCatch(t,n,r);if(\"normal\"===a.type){if(e=r.done?p:h,a.arg===d)continue;return{value:a.arg,done:r.done}}\"throw\"===a.type&&(e=p,r.method=\"throw\",r.arg=a.arg)}}}function maybeInvokeDelegate(t,n){var e=t.iterator[n.method];if(e===r){if(n.delegate=null,\"throw\"===n.method){if(t.iterator.return&&(n.method=\"return\",n.arg=r,maybeInvokeDelegate(t,n),\"throw\"===n.method))return d;n.method=\"throw\",n.arg=new TypeError(\"The iterator does not provide a 'throw' method\")}return d}var i=tryCatch(e,t.iterator,n.arg);if(\"throw\"===i.type)return n.method=\"throw\",n.arg=i.arg,n.delegate=null,d;var o=i.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,\"return\"!==n.method&&(n.method=\"next\",n.arg=r),n.delegate=null,d):o:(n.method=\"throw\",n.arg=new TypeError(\"iterator result is not an object\"),n.delegate=null,d)}function pushTryEntry(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function resetTryEntry(t){var n=t.completion||{};n.type=\"normal\",delete n.arg,t.completion=n}function Context(t){this.tryEntries=[{tryLoc:\"root\"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(t){if(t){var n=t[u];if(n)return n.call(t);if(\"function\"==typeof t.next)return t;if(!isNaN(t.length)){var e=-1,o=function next(){for(;++e<t.length;)if(i.call(t,e))return next.value=t[e],next.done=!1,next;return next.value=r,next.done=!0,next};return o.next=o}}return{next:doneResult}}function doneResult(){return{value:r,done:!0}}var r,e=Object.prototype,i=e.hasOwnProperty,o=\"function\"==typeof Symbol?Symbol:{},u=o.iterator||\"@@iterator\",c=o.asyncIterator||\"@@asyncIterator\",a=o.toStringTag||\"@@toStringTag\",f=\"object\"==typeof n,s=t.regeneratorRuntime;if(s)return void(f&&(n.exports=s));s=t.regeneratorRuntime=f?n.exports:{},s.wrap=wrap;var l=\"suspendedStart\",h=\"suspendedYield\",v=\"executing\",p=\"completed\",d={},y={};y[u]=function(){return this};var g=Object.getPrototypeOf,m=g&&g(g(values([])));m&&m!==e&&i.call(m,u)&&(y=m);var b=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(y);GeneratorFunction.prototype=b.constructor=GeneratorFunctionPrototype,GeneratorFunctionPrototype.constructor=GeneratorFunction,GeneratorFunctionPrototype[a]=GeneratorFunction.displayName=\"GeneratorFunction\",s.isGeneratorFunction=function(t){var n=\"function\"==typeof t&&t.constructor;return!!n&&(n===GeneratorFunction||\"GeneratorFunction\"===(n.displayName||n.name))},s.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,a in t||(t[a]=\"GeneratorFunction\")),t.prototype=Object.create(b),t},s.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),AsyncIterator.prototype[c]=function(){return this},s.AsyncIterator=AsyncIterator,s.async=function(t,n,r,e){var i=new AsyncIterator(wrap(t,n,r,e));return s.isGeneratorFunction(n)?i:i.next().then(function(t){return t.done?t.value:i.next()})},defineIteratorMethods(b),b[a]=\"Generator\",b[u]=function(){return this},b.toString=function(){return\"[object Generator]\"},s.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function next(){for(;n.length;){var r=n.pop();if(r in t)return next.value=r,next.done=!1,next}return next.done=!0,next}},s.values=values,Context.prototype={constructor:Context,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method=\"next\",this.arg=r,this.tryEntries.forEach(resetTryEntry),!t)for(var n in this)\"t\"===n.charAt(0)&&i.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=r)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if(\"throw\"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function handle(e,i){return u.type=\"throw\",u.arg=t,n.next=e,i&&(n.method=\"next\",n.arg=r),!!i}if(this.done)throw t;for(var n=this,e=this.tryEntries.length-1;e>=0;--e){var o=this.tryEntries[e],u=o.completion;if(\"root\"===o.tryLoc)return handle(\"end\");if(o.tryLoc<=this.prev){var c=i.call(o,\"catchLoc\"),a=i.call(o,\"finallyLoc\");if(c&&a){if(this.prev<o.catchLoc)return handle(o.catchLoc,!0);if(this.prev<o.finallyLoc)return handle(o.finallyLoc)}else if(c){if(this.prev<o.catchLoc)return handle(o.catchLoc,!0)}else{if(!a)throw new Error(\"try statement without catch or finally\");if(this.prev<o.finallyLoc)return handle(o.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&i.call(e,\"finallyLoc\")&&this.prev<e.finallyLoc){var o=e;break}}o&&(\"break\"===t||\"continue\"===t)&&o.tryLoc<=n&&n<=o.finallyLoc&&(o=null);var u=o?o.completion:{};return u.type=t,u.arg=n,o?(this.method=\"next\",this.next=o.finallyLoc,d):this.complete(u)},complete:function(t,n){if(\"throw\"===t.type)throw t.arg;return\"break\"===t.type||\"continue\"===t.type?this.next=t.arg:\"return\"===t.type?(this.rval=this.arg=t.arg,this.method=\"return\",this.next=\"end\"):\"normal\"===t.type&&n&&(this.next=n),d},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),d}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if(\"throw\"===e.type){var i=e.arg;resetTryEntry(r)}return i}}throw new Error(\"illegal catch attempt\")},delegateYield:function(t,n,e){return this.delegate={iterator:values(t),resultName:n,nextLoc:e},\"next\"===this.method&&(this.arg=r),d}}}(\"object\"==typeof t?t:\"object\"==typeof window?window:\"object\"==typeof self?self:this)}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1]);\n  (function RunRunUnicorn(){\n\n    var app = \"\\n\\n(function(){\\n  var requireJSRequire,require,define;!function(global,setTimeout){function commentReplace(e,t){return t||\\\"\\\"}function isFunction(e){return\\\"[object Function]\\\"===ostring.call(e)}function isArray(e){return\\\"[object Array]\\\"===ostring.call(e)}function each(e,t){if(e){var n;for(n=0;n<e.length&&(!e[n]||!t(e[n],n,e));n+=1);}}function eachReverse(e,t){if(e){var n;for(n=e.length-1;n>-1&&(!e[n]||!t(e[n],n,e));n-=1);}}function hasProp(e,t){return hasOwn.call(e,t)}function getOwn(e,t){return hasProp(e,t)&&e[t]}function eachProp(e,t){var n;for(n in e)if(hasProp(e,n)&&t(e[n],n))break}function mixin(e,t,n,i){return t&&eachProp(t,function(t,r){!n&&hasProp(e,r)||(!i||\\\"object\\\"!=typeof t||!t||isArray(t)||isFunction(t)||t instanceof RegExp?e[r]=t:(e[r]||(e[r]={}),mixin(e[r],t,n,i)))}),e}function bind(e,t){return function(){return t.apply(e,arguments)}}function scripts(){return document.getElementsByTagName(\\\"script\\\")}function defaultOnError(e){throw e}function getGlobal(e){if(!e)return e;var t=global;return each(e.split(\\\".\\\"),function(e){t=t[e]}),t}function makeError(e,t,n,i){var r=new Error(t+\\\"\\\\nhttp://requirejs.org/docs/errors.html#\\\"+e);return r.requireType=e,r.requireModules=i,n&&(r.originalError=n),r}function newContext(e){function t(e){var t,n;for(t=0;t<e.length;t++)if(\\\".\\\"===(n=e[t]))e.splice(t,1),t-=1;else if(\\\"..\\\"===n){if(0===t||1===t&&\\\"..\\\"===e[2]||\\\"..\\\"===e[t-1])continue;t>0&&(e.splice(t-1,2),t-=2)}}function n(e,n,i){var r,s,o,a,u,c,d,l,p,f,h,m=n&&n.split(\\\"/\\\"),g=E.map,v=g&&g[\\\"*\\\"];if(e&&(e=e.split(\\\"/\\\"),c=e.length-1,E.nodeIdCompat&&jsSuffixRegExp.test(e[c])&&(e[c]=e[c].replace(jsSuffixRegExp,\\\"\\\")),\\\".\\\"===e[0].charAt(0)&&m&&(h=m.slice(0,m.length-1),e=h.concat(e)),t(e),e=e.join(\\\"/\\\")),i&&g&&(m||v)){s=e.split(\\\"/\\\");e:for(o=s.length;o>0;o-=1){if(u=s.slice(0,o).join(\\\"/\\\"),m)for(a=m.length;a>0;a-=1)if((r=getOwn(g,m.slice(0,a).join(\\\"/\\\")))&&(r=getOwn(r,u))){d=r,l=o;break e}!p&&v&&getOwn(v,u)&&(p=getOwn(v,u),f=o)}!d&&p&&(d=p,l=f),d&&(s.splice(0,l,d),e=s.join(\\\"/\\\"))}return getOwn(E.pkgs,e)||e}function i(e){isBrowser&&each(scripts(),function(t){if(t.getAttribute(\\\"data-requiremodule\\\")===e&&t.getAttribute(\\\"data-requirecontext\\\")===b.contextName)return t.parentNode.removeChild(t),!0})}function r(e){var t=getOwn(E.paths,e);if(t&&isArray(t)&&t.length>1)return t.shift(),b.require.undef(e),b.makeRequire(null,{skipMap:!0})([e]),!0}function s(e){var t,n=e?e.indexOf(\\\"!\\\"):-1;return n>-1&&(t=e.substring(0,n),e=e.substring(n+1,e.length)),[t,e]}function o(e,t,i,r){var o,a,u,c,d=null,l=t?t.name:null,p=e,f=!0,h=\\\"\\\";return e||(f=!1,e=\\\"_@r\\\"+(R+=1)),c=s(e),d=c[0],e=c[1],d&&(d=n(d,l,r),a=getOwn(P,d)),e&&(d?h=i?e:a&&a.normalize?a.normalize(e,function(e){return n(e,l,r)}):-1===e.indexOf(\\\"!\\\")?n(e,l,r):e:(h=n(e,l,r),c=s(h),d=c[0],h=c[1],i=!0,o=b.nameToUrl(h))),u=!d||a||i?\\\"\\\":\\\"_unnormalized\\\"+(T+=1),{prefix:d,name:h,parentMap:t,unnormalized:!!u,url:o,originalName:p,isDefine:f,id:(d?d+\\\"!\\\"+h:h)+u}}function a(e){var t=e.id,n=getOwn(S,t);return n||(n=S[t]=new b.Module(e)),n}function u(e,t,n){var i=e.id,r=getOwn(S,i);!hasProp(P,i)||r&&!r.defineEmitComplete?(r=a(e),r.error&&\\\"error\\\"===t?n(r.error):r.on(t,n)):\\\"defined\\\"===t&&n(P[i])}function c(e,t){var n=e.requireModules,i=!1;t?t(e):(each(n,function(t){var n=getOwn(S,t);n&&(n.error=e,n.events.error&&(i=!0,n.emit(\\\"error\\\",e)))}),i||req.onError(e))}function d(){globalDefQueue.length&&(each(globalDefQueue,function(e){var t=e[0];\\\"string\\\"==typeof t&&(b.defQueueMap[t]=!0),O.push(e)}),globalDefQueue=[])}function l(e){delete S[e],delete q[e]}function p(e,t,n){var i=e.map.id;e.error?e.emit(\\\"error\\\",e.error):(t[i]=!0,each(e.depMaps,function(i,r){var s=i.id,o=getOwn(S,s);!o||e.depMatched[r]||n[s]||(getOwn(t,s)?(e.defineDep(r,P[s]),e.check()):p(o,t,n))}),n[i]=!0)}function f(){var e,t,n=1e3*E.waitSeconds,s=n&&b.startTime+n<(new Date).getTime(),o=[],a=[],u=!1,d=!0;if(!v){if(v=!0,eachProp(q,function(e){var n=e.map,c=n.id;if(e.enabled&&(n.isDefine||a.push(e),!e.error))if(!e.inited&&s)r(c)?(t=!0,u=!0):(o.push(c),i(c));else if(!e.inited&&e.fetched&&n.isDefine&&(u=!0,!n.prefix))return d=!1}),s&&o.length)return e=makeError(\\\"timeout\\\",\\\"Load timeout for modules: \\\"+o,null,o),e.contextName=b.contextName,c(e);d&&each(a,function(e){p(e,{},{})}),s&&!t||!u||!isBrowser&&!isWebWorker||w||(w=setTimeout(function(){w=0,f()},50)),v=!1}}function h(e){hasProp(P,e[0])||a(o(e[0],null,!0)).init(e[1],e[2])}function m(e){var t=e.currentTarget||e.srcElement;return{node:t,id:t&&t.getAttribute(\\\"data-requiremodule\\\")}}function g(){var e;for(d();O.length;){if(e=O.shift(),null===e[0])return c(makeError(\\\"mismatch\\\",\\\"Mismatched anonymous define() module: \\\"+e[e.length-1]));h(e)}b.defQueueMap={}}var v,x,b,y,w,E={waitSeconds:7,baseUrl:\\\"./\\\",paths:{},bundles:{},pkgs:{},shim:{},config:{}},S={},q={},M={},O=[],P={},j={},k={},R=1,T=1;return y={require:function(e){return e.require?e.require:e.require=b.makeRequire(e.map)},exports:function(e){if(e.usingExports=!0,e.map.isDefine)return e.exports?P[e.map.id]=e.exports:e.exports=P[e.map.id]={}},module:function(e){return e.module?e.module:e.module={id:e.map.id,uri:e.map.url,config:function(){return getOwn(E.config,e.map.id)||{}},exports:e.exports||(e.exports={})}}},x=function(e){this.events=getOwn(M,e.id)||{},this.map=e,this.shim=getOwn(E.shim,e.id),this.depExports=[],this.depMaps=[],this.depMatched=[],this.pluginMaps={},this.depCount=0},x.prototype={init:function(e,t,n,i){i=i||{},this.inited||(this.factory=t,n?this.on(\\\"error\\\",n):this.events.error&&(n=bind(this,function(e){this.emit(\\\"error\\\",e)})),this.depMaps=e&&e.slice(0),this.errback=n,this.inited=!0,this.ignore=i.ignore,i.enabled||this.enabled?this.enable():this.check())},defineDep:function(e,t){this.depMatched[e]||(this.depMatched[e]=!0,this.depCount-=1,this.depExports[e]=t)},fetch:function(){if(!this.fetched){this.fetched=!0,b.startTime=(new Date).getTime();var e=this.map;if(!this.shim)return e.prefix?this.callPlugin():this.load();b.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],bind(this,function(){return e.prefix?this.callPlugin():this.load()}))}},load:function(){var e=this.map.url;j[e]||(j[e]=!0,b.load(this.map.id,e))},check:function(){if(this.enabled&&!this.enabling){var e,t,n=this.map.id,i=this.depExports,r=this.exports,s=this.factory;if(this.inited){if(this.error)this.emit(\\\"error\\\",this.error);else if(!this.defining){if(this.defining=!0,this.depCount<1&&!this.defined){if(isFunction(s)){if(this.events.error&&this.map.isDefine||req.onError!==defaultOnError)try{r=b.execCb(n,s,i,r)}catch(t){e=t}else r=b.execCb(n,s,i,r);if(this.map.isDefine&&void 0===r&&(t=this.module,t?r=t.exports:this.usingExports&&(r=this.exports)),e)return e.requireMap=this.map,e.requireModules=this.map.isDefine?[this.map.id]:null,e.requireType=this.map.isDefine?\\\"define\\\":\\\"require\\\",c(this.error=e)}else r=s;if(this.exports=r,this.map.isDefine&&!this.ignore&&(P[n]=r,req.onResourceLoad)){var o=[];each(this.depMaps,function(e){o.push(e.normalizedMap||e)}),req.onResourceLoad(b,this.map,o)}l(n),this.defined=!0}this.defining=!1,this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit(\\\"defined\\\",this.exports),this.defineEmitComplete=!0)}}else hasProp(b.defQueueMap,n)||this.fetch()}},callPlugin:function(){var e=this.map,t=e.id,i=o(e.prefix);this.depMaps.push(i),u(i,\\\"defined\\\",bind(this,function(i){var r,s,d,p=getOwn(k,this.map.id),f=this.map.name,h=this.map.parentMap?this.map.parentMap.name:null,m=b.makeRequire(e.parentMap,{enableBuildCallback:!0});return this.map.unnormalized?(i.normalize&&(f=i.normalize(f,function(e){return n(e,h,!0)})||\\\"\\\"),s=o(e.prefix+\\\"!\\\"+f,this.map.parentMap,!0),u(s,\\\"defined\\\",bind(this,function(e){this.map.normalizedMap=s,this.init([],function(){return e},null,{enabled:!0,ignore:!0})})),void((d=getOwn(S,s.id))&&(this.depMaps.push(s),this.events.error&&d.on(\\\"error\\\",bind(this,function(e){this.emit(\\\"error\\\",e)})),d.enable()))):p?(this.map.url=b.nameToUrl(p),void this.load()):(r=bind(this,function(e){this.init([],function(){return e},null,{enabled:!0})}),r.error=bind(this,function(e){this.inited=!0,this.error=e,e.requireModules=[t],eachProp(S,function(e){0===e.map.id.indexOf(t+\\\"_unnormalized\\\")&&l(e.map.id)}),c(e)}),r.fromText=bind(this,function(n,i){var s=e.name,u=o(s),d=useInteractive;i&&(n=i),d&&(useInteractive=!1),a(u),hasProp(E.config,t)&&(E.config[s]=E.config[t]);try{req.exec(n)}catch(e){return c(makeError(\\\"fromtexteval\\\",\\\"fromText eval for \\\"+t+\\\" failed: \\\"+e,e,[t]))}d&&(useInteractive=!0),this.depMaps.push(u),b.completeLoad(s),m([s],r)}),void i.load(e.name,m,r,E))})),b.enable(i,this),this.pluginMaps[i.id]=i},enable:function(){q[this.map.id]=this,this.enabled=!0,this.enabling=!0,each(this.depMaps,bind(this,function(e,t){var n,i,r;if(\\\"string\\\"==typeof e){if(e=o(e,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap),this.depMaps[t]=e,r=getOwn(y,e.id))return void(this.depExports[t]=r(this));this.depCount+=1,u(e,\\\"defined\\\",bind(this,function(e){this.undefed||(this.defineDep(t,e),this.check())})),this.errback?u(e,\\\"error\\\",bind(this,this.errback)):this.events.error&&u(e,\\\"error\\\",bind(this,function(e){this.emit(\\\"error\\\",e)}))}n=e.id,i=S[n],hasProp(y,n)||!i||i.enabled||b.enable(e,this)})),eachProp(this.pluginMaps,bind(this,function(e){var t=getOwn(S,e.id);t&&!t.enabled&&b.enable(e,this)})),this.enabling=!1,this.check()},on:function(e,t){var n=this.events[e];n||(n=this.events[e]=[]),n.push(t)},emit:function(e,t){each(this.events[e],function(e){e(t)}),\\\"error\\\"===e&&delete this.events[e]}},b={config:E,contextName:e,registry:S,defined:P,urlFetched:j,defQueue:O,defQueueMap:{},Module:x,makeModuleMap:o,nextTick:req.nextTick,onError:c,configure:function(e){if(e.baseUrl&&\\\"/\\\"!==e.baseUrl.charAt(e.baseUrl.length-1)&&(e.baseUrl+=\\\"/\\\"),\\\"string\\\"==typeof e.urlArgs){var t=e.urlArgs;e.urlArgs=function(e,n){return(-1===n.indexOf(\\\"?\\\")?\\\"?\\\":\\\"&\\\")+t}}var n=E.shim,i={paths:!0,bundles:!0,config:!0,map:!0};eachProp(e,function(e,t){i[t]?(E[t]||(E[t]={}),mixin(E[t],e,!0,!0)):E[t]=e}),e.bundles&&eachProp(e.bundles,function(e,t){each(e,function(e){e!==t&&(k[e]=t)})}),e.shim&&(eachProp(e.shim,function(e,t){isArray(e)&&(e={deps:e}),!e.exports&&!e.init||e.exportsFn||(e.exportsFn=b.makeShimExports(e)),n[t]=e}),E.shim=n),e.packages&&each(e.packages,function(e){var t,n;e=\\\"string\\\"==typeof e?{name:e}:e,n=e.name,t=e.location,t&&(E.paths[n]=e.location),E.pkgs[n]=e.name+\\\"/\\\"+(e.main||\\\"main\\\").replace(currDirRegExp,\\\"\\\").replace(jsSuffixRegExp,\\\"\\\")}),eachProp(S,function(e,t){e.inited||e.map.unnormalized||(e.map=o(t,null,!0))}),(e.deps||e.callback)&&b.require(e.deps||[],e.callback)},makeShimExports:function(e){function t(){var t;return e.init&&(t=e.init.apply(global,arguments)),t||e.exports&&getGlobal(e.exports)}return t},makeRequire:function(t,r){function s(n,i,u){var d,l,p;return r.enableBuildCallback&&i&&isFunction(i)&&(i.__requireJsBuild=!0),\\\"string\\\"==typeof n?isFunction(i)?c(makeError(\\\"requireargs\\\",\\\"Invalid require call\\\"),u):t&&hasProp(y,n)?y[n](S[t.id]):req.get?req.get(b,n,t,s):(l=o(n,t,!1,!0),d=l.id,hasProp(P,d)?P[d]:c(makeError(\\\"notloaded\\\",'Module name \\\"'+d+'\\\" has not been loaded yet for context: '+e+(t?\\\"\\\":\\\". Use require([])\\\")))):(g(),b.nextTick(function(){g(),p=a(o(null,t)),p.skipMap=r.skipMap,p.init(n,i,u,{enabled:!0}),f()}),s)}return r=r||{},mixin(s,{isBrowser:isBrowser,toUrl:function(e){var i,r=e.lastIndexOf(\\\".\\\"),s=e.split(\\\"/\\\")[0],o=\\\".\\\"===s||\\\"..\\\"===s;return-1!==r&&(!o||r>1)&&(i=e.substring(r,e.length),e=e.substring(0,r)),b.nameToUrl(n(e,t&&t.id,!0),i,!0)},defined:function(e){return hasProp(P,o(e,t,!1,!0).id)},specified:function(e){return e=o(e,t,!1,!0).id,hasProp(P,e)||hasProp(S,e)}}),t||(s.undef=function(e){d();var n=o(e,t,!0),r=getOwn(S,e);r.undefed=!0,i(e),delete P[e],delete j[n.url],delete M[e],eachReverse(O,function(t,n){t[0]===e&&O.splice(n,1)}),delete b.defQueueMap[e],r&&(r.events.defined&&(M[e]=r.events),l(e))}),s},enable:function(e){getOwn(S,e.id)&&a(e).enable()},completeLoad:function(e){var t,n,i,s=getOwn(E.shim,e)||{},o=s.exports;for(d();O.length;){if(n=O.shift(),null===n[0]){if(n[0]=e,t)break;t=!0}else n[0]===e&&(t=!0);h(n)}if(b.defQueueMap={},i=getOwn(S,e),!t&&!hasProp(P,e)&&i&&!i.inited){if(!(!E.enforceDefine||o&&getGlobal(o)))return r(e)?void 0:c(makeError(\\\"nodefine\\\",\\\"No define call for \\\"+e,null,[e]));h([e,s.deps||[],s.exportsFn])}f()},nameToUrl:function(e,t,n){var i,r,s,o,a,u,c,d=getOwn(E.pkgs,e);if(d&&(e=d),c=getOwn(k,e))return b.nameToUrl(c,t,n);if(req.jsExtRegExp.test(e))a=e+(t||\\\"\\\");else{for(i=E.paths,r=e.split(\\\"/\\\"),s=r.length;s>0;s-=1)if(o=r.slice(0,s).join(\\\"/\\\"),u=getOwn(i,o)){isArray(u)&&(u=u[0]),r.splice(0,s,u);break}a=r.join(\\\"/\\\"),a+=t||(/^data\\\\:|^blob\\\\:|\\\\?/.test(a)||n?\\\"\\\":\\\".js\\\"),a=(\\\"/\\\"===a.charAt(0)||a.match(/^[\\\\w\\\\+\\\\.\\\\-]+:/)?\\\"\\\":E.baseUrl)+a}return E.urlArgs&&!/^blob\\\\:/.test(a)?a+E.urlArgs(e,a):a},load:function(e,t){req.load(b,e,t)},execCb:function(e,t,n,i){return t.apply(i,n)},onScriptLoad:function(e){if(\\\"load\\\"===e.type||readyRegExp.test((e.currentTarget||e.srcElement).readyState)){interactiveScript=null;var t=m(e);b.completeLoad(t.id)}},onScriptError:function(e){var t=m(e);if(!r(t.id)){var n=[];return eachProp(S,function(e,i){0!==i.indexOf(\\\"_@r\\\")&&each(e.depMaps,function(e){if(e.id===t.id)return n.push(i),!0})}),c(makeError(\\\"scripterror\\\",'Script error for \\\"'+t.id+(n.length?'\\\", needed by: '+n.join(\\\", \\\"):'\\\"'),e,[t.id]))}}},b.require=b.makeRequire(),b}function getInteractiveScript(){return interactiveScript&&\\\"interactive\\\"===interactiveScript.readyState?interactiveScript:(eachReverse(scripts(),function(e){if(\\\"interactive\\\"===e.readyState)return interactiveScript=e}),interactiveScript)}var req,s,head,baseElement,dataMain,src,interactiveScript,currentlyAddingScript,mainScript,subPath,version=\\\"2.3.5\\\",commentRegExp=/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/|([^:\\\"'=]|^)\\\\/\\\\/.*$/gm,cjsRequireRegExp=/[^.]\\\\s*require\\\\s*\\\\(\\\\s*[\\\"']([^'\\\"\\\\s]+)[\\\"']\\\\s*\\\\)/g,jsSuffixRegExp=/\\\\.js$/,currDirRegExp=/^\\\\.\\\\//,op=Object.prototype,ostring=op.toString,hasOwn=op.hasOwnProperty,isBrowser=!(\\\"undefined\\\"==typeof window||\\\"undefined\\\"==typeof navigator||!window.document),isWebWorker=!isBrowser&&\\\"undefined\\\"!=typeof importScripts,readyRegExp=isBrowser&&\\\"PLAYSTATION 3\\\"===navigator.platform?/^complete$/:/^(complete|loaded)$/,defContextName=\\\"_\\\",isOpera=\\\"undefined\\\"!=typeof opera&&\\\"[object Opera]\\\"===opera.toString(),contexts={},cfg={},globalDefQueue=[],useInteractive=!1;if(void 0===define){if(\\\"undefined\\\"!=typeof requirejs){if(isFunction(requirejs))return;cfg=requirejs,requirejs=void 0}void 0===require||isFunction(require)||(cfg=require,require=void 0),req=requirejs=function(e,t,n,i){var r,s,o=defContextName;return isArray(e)||\\\"string\\\"==typeof e||(s=e,isArray(t)?(e=t,t=n,n=i):e=[]),s&&s.context&&(o=s.context),r=getOwn(contexts,o),r||(r=contexts[o]=req.s.newContext(o)),s&&r.configure(s),r.require(e,t,n)},req.config=function(e){return req(e)},req.nextTick=void 0!==setTimeout?function(e){setTimeout(e,4)}:function(e){e()},requireJSRequire||(requireJSRequire=req),req.version=version,req.jsExtRegExp=/^\\\\/|:|\\\\?|\\\\.js$/,req.isBrowser=isBrowser,s=req.s={contexts:contexts,newContext:newContext},req({}),each([\\\"toUrl\\\",\\\"undef\\\",\\\"defined\\\",\\\"specified\\\"],function(e){req[e]=function(){var t=contexts[defContextName];return t.require[e].apply(t,arguments)}}),isBrowser&&(head=s.head=document.getElementsByTagName(\\\"head\\\")[0],(baseElement=document.getElementsByTagName(\\\"base\\\")[0])&&(head=s.head=baseElement.parentNode)),req.onError=defaultOnError,req.createNode=function(e,t,n){var i=e.xhtml?document.createElementNS(\\\"http://www.w3.org/1999/xhtml\\\",\\\"html:script\\\"):document.createElement(\\\"script\\\");return i.type=e.scriptType||\\\"text/javascript\\\",i.charset=\\\"utf-8\\\",i.async=!0,i},req.load=function(e,t,n){var i,r=e&&e.config||{};if(isBrowser)return i=req.createNode(r,t,n),i.setAttribute(\\\"data-requirecontext\\\",e.contextName),i.setAttribute(\\\"data-requiremodule\\\",t),!i.attachEvent||i.attachEvent.toString&&i.attachEvent.toString().indexOf(\\\"[native code\\\")<0||isOpera?(i.addEventListener(\\\"load\\\",e.onScriptLoad,!1),i.addEventListener(\\\"error\\\",e.onScriptError,!1)):(useInteractive=!0,i.attachEvent(\\\"onreadystatechange\\\",e.onScriptLoad)),i.src=n,r.onNodeCreated&&r.onNodeCreated(i,r,t,n),currentlyAddingScript=i,currentlyAddingScript=null,e.onScriptLoad({type:\\\"load\\\"}),i;if(isWebWorker)try{setTimeout(function(){},0),importScripts(n),e.completeLoad(t)}catch(i){e.onError(makeError(\\\"importscripts\\\",\\\"importScripts failed for \\\"+t+\\\" at \\\"+n,i,[t]))}},isBrowser&&!cfg.skipDataMain&&eachReverse(scripts(),function(e){if(head||(head=e.parentNode),dataMain=e.getAttribute(\\\"data-main\\\"))return mainScript=dataMain,cfg.baseUrl||-1!==mainScript.indexOf(\\\"!\\\")||(src=mainScript.split(\\\"/\\\"),mainScript=src.pop(),subPath=src.length?src.join(\\\"/\\\")+\\\"/\\\":\\\"./\\\",cfg.baseUrl=subPath),mainScript=mainScript.replace(jsSuffixRegExp,\\\"\\\"),req.jsExtRegExp.test(mainScript)&&(mainScript=dataMain),cfg.deps=cfg.deps?cfg.deps.concat(mainScript):[mainScript],!0}),define=function(e,t,n){var i,r;\\\"string\\\"!=typeof e&&(n=t,t=e,e=null),isArray(t)||(n=t,t=null),!t&&isFunction(n)&&(t=[],n.length&&(n.toString().replace(commentRegExp,commentReplace).replace(cjsRequireRegExp,function(e,n){t.push(n)}),t=(1===n.length?[\\\"require\\\"]:[\\\"require\\\",\\\"exports\\\",\\\"module\\\"]).concat(t))),useInteractive&&(i=currentlyAddingScript||getInteractiveScript())&&(e||(e=i.getAttribute(\\\"data-requiremodule\\\")),r=contexts[i.getAttribute(\\\"data-requirecontext\\\")]),r?(r.defQueue.push([e,t,n]),r.defQueueMap[e]=!0):globalDefQueue.push([e,t,n])},define.amd={jQuery:!0},req.exec=function(text){return eval(text)},req(cfg)}}(this,\\\"undefined\\\"==typeof setTimeout?void 0:setTimeout);\\n\\n  function OMG_KCsVcjjednlGSjCajzecXtVY () {\\n    var self = this;\\n\\n    !function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/style.css\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.styleCss=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var t=\\\"html, body {\\\\n  width: 100%;\\\\n  height: 100%;\\\\n  margin: 0px;\\\\n  padding: 0px;\\\\n}\\\\nhtml, body, #app {\\\\n  box-sizing: border-box;\\\\n  width: 100%;\\\\n  height: 100%;\\\\n  overflow: hidden;\\\\n}\\\\n.full{\\\\n  width: 100%;\\\\n  height: 100%;\\\\n}\\\",n=document.head||document.getElementsByTagName(\\\"head\\\")[0],i=document.createElement(\\\"style\\\");i.type=\\\"text/css\\\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i),e.default=\\\"html, body {\\\\n  width: 100%;\\\\n  height: 100%;\\\\n  margin: 0px;\\\\n  padding: 0px;\\\\n}\\\\nhtml, body, #app {\\\\n  box-sizing: border-box;\\\\n  width: 100%;\\\\n  height: 100%;\\\\n  overflow: hidden;\\\\n}\\\\n.full{\\\\n  width: 100%;\\\\n  height: 100%;\\\\n}\\\"}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/main.js\\\",[\\\"exports\\\",\\\"@/app.vue\\\",\\\"@/router.js\\\",\\\"@/style.css\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/app.vue\\\"),require(\\\"@/router.js\\\"),require(\\\"@/style.css\\\"));else{var n={exports:{}};t(n.exports,e.appVue,e.routerJs,e.styleCss),e.mainJs=n.exports}}(this,function(e,t,n){\\\"use strict\\\";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var r=i(t),s=i(n),o=document.querySelector(\\\"#app-attach-point\\\"),a=document.createElement(\\\"div\\\"),u=o||a;o||(a.id=\\\"#app-attach-point\\\",document.body.appendChild(a));var d=new Vue({router:s.default,el:u,components:{App:r.default},template:'<div id=\\\"app\\\"><App /></div>'});window.addEventListener(\\\"main-system-ready\\\",function(e){var t=e.detail;console.log(\\\"App Got Custom Event:\\\",t)},!1),e.default=d}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/router.js\\\",[\\\"exports\\\",\\\"@/webgl/layout/Player.vue\\\",\\\"@/webgl/pages/Home.vue\\\",\\\"@/webgl/pages/Happy.vue\\\",\\\"@/webgl/pages/Sample.vue\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/webgl/layout/Player.vue\\\"),require(\\\"@/webgl/pages/Home.vue\\\"),require(\\\"@/webgl/pages/Happy.vue\\\"),require(\\\"@/webgl/pages/Sample.vue\\\"));else{var n={exports:{}};t(n.exports,e.webglLayoutPlayerVue,e.webglPagesHomeVue,e.webglPagesHappyVue,e.webglPagesSampleVue),e.routerJs=n.exports}}(this,function(e,t,n,i,r){\\\"use strict\\\";function s(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var o=s(t),a=s(n),u=s(i),d=s(r),c=new VueRouter({mode:\\\"hash\\\",routes:[{path:\\\"/\\\",component:d.default},{path:\\\"/sub\\\",component:o.default,children:[{path:\\\"\\\",component:a.default},{path:\\\"happy\\\",component:u.default}]}]});e.default=c}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/app.vue\\\",[\\\"exports\\\",\\\"@/three.js\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/three.js\\\"));else{var n={exports:{}};t(n.exports,e.threeJs),e.appVue=n.exports}}(this,function(e,t){\\\"use strict\\\";function n(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var i=(n(t),\\\"\\\\n\\\\n\\\"),r=document.head||document.getElementsByTagName(\\\"head\\\")[0],s=document.createElement(\\\"style\\\");s.type=\\\"text/css\\\",s.styleSheet?s.styleSheet.cssText=i:s.appendChild(document.createTextNode(i)),r.appendChild(s),e.default={template:\\\"\\\\n  <divdata-s-hih>\\\\n    <router-view></router-view>\\\\n  </div>\\\\n\\\",data:function(){return{}},created:function(){},beforeDestroy:function(){},methods:{}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/pages/Sample.vue\\\",[\\\"exports\\\",\\\"@/webgl/Bundle.js\\\",\\\"@/shader/Fling/vs.vert\\\",\\\"@/shader/Simple/fs.frag\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/webgl/Bundle.js\\\"),require(\\\"@/shader/Fling/vs.vert\\\"),require(\\\"@/shader/Simple/fs.frag\\\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs,e.shaderFlingVsVert,e.shaderSimpleFsFrag),e.webglPagesSampleVue=n.exports}}(this,function(e,t,n,i){\\\"use strict\\\";function r(e){return e&&e.__esModule?e:{default:e}}function s(e,t){return null!=t&&\\\"undefined\\\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function o(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\\\" \\\"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\\\"\\\"))});var a=o.join(\\\",\\\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(s(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\\\"load\\\",function t(){e.removeEventListener(\\\"load\\\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var a=r(t),u=r(n),d=r(i),c=\\\"\\\\n.pos-rel{\\\\n  position: relative;\\\\n}\\\\n.full{\\\\n  width: 100%;\\\\n  height: 100%;\\\\n}\\\\n.renderer{\\\\n  position: absolute;\\\\n  top: 0px;\\\\n  left: 0px;\\\\n}\\\\n.touch-surface{\\\\n  position: absolute;\\\\n  top: 0px;\\\\n  left: 0px;\\\\n  z-index: 100;\\\\n}\\\\n\\\",l=document.head||document.getElementsByTagName(\\\"head\\\")[0],p=document.createElement(\\\"style\\\");p.type=\\\"text/css\\\",p.styleSheet?p.styleSheet.cssText=c:p.appendChild(document.createTextNode(c)),l.appendChild(p),o(p,\\\"[data-s-1i2e]\\\"),e.default={template:'\\\\n  <div class=\\\"full\\\"data-s-1i2e>\\\\n\\\\n    <Renderer\\\\n      class=\\\"pos-rel full\\\"\\\\n      ref=\\\"renderer\\\"\\\\n      :size=\\\"size\\\"\\\\n      @renderer=\\\"(v) => { renderer = v }\\\"\\\\n    >\\\\n      \\\\n    </Renderer>\\\\n    \\\\n    \\\\x3c!-- <div class=\\\"full touch-surface\\\" @click=\\\"wonder\\\">\\\\n      12345\\\\n    </div> --\\\\x3e\\\\n    \\\\n    <div class=\\\"layout\\\">\\\\n      \\\\n    </div>\\\\n\\\\n    <PerspectiveCamera\\\\n      :fov=\\\"75\\\"\\\\n      :aspect=\\\"size.aspect\\\"\\\\n      :near=\\\"1\\\"\\\\n      :far=\\\"1000\\\"\\\\n      :position=\\\"{ x: 0, y: 0, z: 10 }\\\"\\\\n      \\\\n      @camera=\\\"(v) => { camera = v; }\\\"\\\\n    />\\\\n\\\\n    <Scene @scene=\\\"(v) => { scene = v }\\\">\\\\n      <Object3D pz=\\\"10\\\">\\\\n        <PointLight />\\\\n      </Object3D>\\\\n      \\\\n      <Object3D pz=\\\"0\\\">\\\\n        <Points>\\\\n          <SphereBufferGeometry />\\\\n          <ShaderMaterial :vs=\\\"simple.vs\\\" :fs=\\\"simple.fs\\\" :uniforms=\\\"animatable\\\" />\\\\n        </Points>\\\\n      </Object3D>\\\\n      \\\\n    </Scene>\\\\n\\\\n  </div>\\\\n',components:Object.assign({},a.default),computed:{},methods:{renderWebGL:function(){this.animatable.time.value=.001*window.performance.now(),this.scene&&this.camera&&this.renderer&&this.renderer.render(this.scene,this.camera)},wonder:function(){window.alert(\\\"click\\\")}},data:function(){return{animatable:{time:{value:0}},simple:{vs:u.default,fs:d.default},size:{width:window.innerWidth,height:window.innerHeight,aspect:window.innerWidth/window.innerHeight},renderer:!1,scene:!1,camera:!1}},created:function(){},mounted:function(){function e(){t.rAFID=window.requestAnimationFrame(e),t.renderWebGL()}var t=this;t.rAFID=window.requestAnimationFrame(e)}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/layout/Player.vue\\\",[\\\"exports\\\",\\\"@/webgl/Bundle.js\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/webgl/Bundle.js\\\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs),e.webglLayoutPlayerVue=n.exports}}(this,function(e,t){\\\"use strict\\\";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){return null!=t&&\\\"undefined\\\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function r(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\\\" \\\"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\\\"\\\"))});var a=o.join(\\\",\\\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(i(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\\\"load\\\",function t(){e.removeEventListener(\\\"load\\\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var s=n(t),o=\\\"\\\\n.hidden{\\\\n  display: none;\\\\n}\\\\n.full{\\\\n  width: 100%;\\\\n  height: 100%;\\\\n}\\\\n\\\",a=document.head||document.getElementsByTagName(\\\"head\\\")[0],u=document.createElement(\\\"style\\\");u.type=\\\"text/css\\\",u.styleSheet?u.styleSheet.cssText=o:u.appendChild(document.createTextNode(o)),a.appendChild(u),r(u,\\\"[data-s-1qs0]\\\"),e.default={template:'\\\\n  <div class=\\\"full\\\" ref=\\\"full\\\"data-s-1qs0>\\\\n\\\\n    <Renderer\\\\n      :alpha=\\\"true\\\"\\\\n      ref=\\\"renderer\\\"\\\\n      :size=\\\"size\\\"\\\\n      @renderer=\\\"(v) => { renderer = v }\\\"\\\\n      @toucher=\\\"(v) => { toucher = v }\\\"\\\\n    >\\\\n    </Renderer>\\\\n    \\\\n    <keep-alive>\\\\n      <component\\\\n        class=\\\"hidden\\\"\\\\n        :is=\\\"\\\\'router-view\\\\'\\\"\\\\n        v-if=\\\"renderer\\\"\\\\n        :size=\\\"size\\\"\\\\n        :toucher=\\\"toucher\\\"\\\\n        :renderer=\\\"renderer\\\"\\\\n      >\\\\n      </component>\\\\n    </keep-alive>\\\\n\\\\n  </div>\\\\n',components:Object.assign({},s.default),computed:{},methods:{},data:function(){return{toucher:!1,resizer:function(){},renderer:!1,size:{width:100,height:100,aspect:1}}},created:function(){},mounted:function(){var e=this,t=this.resizer=function(){e.$nextTick(function(){var t=e.$refs.full.getBoundingClientRect();e.size={width:t.width,height:t.height,aspect:t.width/t.height}})};window.addEventListener(\\\"resize\\\",t.bind(this)),t()}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/pages/Home.vue\\\",[\\\"exports\\\",\\\"@/webgl/Bundle.js\\\",\\\"@/shader/Simple/vs.vert\\\",\\\"@/shader/Simple/fs.frag\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/webgl/Bundle.js\\\"),require(\\\"@/shader/Simple/vs.vert\\\"),require(\\\"@/shader/Simple/fs.frag\\\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs,e.shaderSimpleVsVert,e.shaderSimpleFsFrag),e.webglPagesHomeVue=n.exports}}(this,function(e,t,n,i){\\\"use strict\\\";function r(e){return e&&e.__esModule?e:{default:e}}function s(e,t){return null!=t&&\\\"undefined\\\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function o(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\\\" \\\"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\\\"\\\"))});var a=o.join(\\\",\\\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(s(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\\\"load\\\",function t(){e.removeEventListener(\\\"load\\\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var a=r(t),u=r(n),d=r(i),c=\\\"\\\\n.full{\\\\n  width: 100%;\\\\n  height: 100%;\\\\n}\\\\n\\\",l=document.head||document.getElementsByTagName(\\\"head\\\")[0],p=document.createElement(\\\"style\\\");p.type=\\\"text/css\\\",p.styleSheet?p.styleSheet.cssText=c:p.appendChild(document.createTextNode(c)),l.appendChild(p),o(p,\\\"[data-s-4j6]\\\"),e.default={template:'\\\\n  <div class=\\\"\\\"data-s-4j6>\\\\n    <PerspectiveCamera\\\\n      :fov=\\\"75\\\"\\\\n      :aspect=\\\"size.aspect\\\"\\\\n      :near=\\\"1\\\"\\\\n      :far=\\\"1000\\\"\\\\n      :position=\\\"{ x: 0, y: 0, z: 15 }\\\"\\\\n      @camera=\\\"(v) => { camera = v; }\\\"\\\\n    />\\\\n    \\\\n    <Scene @scene=\\\"(v) => { scene = v; }\\\">\\\\n      <Object3D pz=\\\"10\\\">\\\\n        <PointLight />\\\\n      </Object3D>\\\\n      \\\\n      <Object3D pz=\\\"0\\\">\\\\n        <Mesh>\\\\n          <SphereBufferGeometry />\\\\n          <ShaderMaterial :vs=\\\"simpleVS\\\" :fs=\\\"simpleFS\\\" :uniforms=\\\"animatable\\\" />\\\\n        </Mesh>\\\\n      </Object3D>\\\\n    </Scene>\\\\n    \\\\n    <Raycaster v-if=\\\"camera && toucher && scene\\\" :scene=\\\"scene\\\" :toucher=\\\"toucher\\\" :camera=\\\"camera\\\" @found=\\\"(v) => { found = v; }\\\" @click=\\\"onClick\\\">\\\\n    </Raycaster>\\\\n    \\\\n  </div>\\\\n',name:\\\"Home\\\",props:{toucher:{},size:{},renderer:{},doc:{}},components:Object.assign({},a.default),computed:{},data:function(){return{cam:{pos:{x:3,y:5,z:10}},ready:!1,cubeCamera:!1,visible:!0,resizer:function(){},scene:!1,camera:!1,found:[],animatable:{time:{value:0}},simpleVS:u.default,simpleFS:d.default}},methods:{onClick:function(e){e.event,e.intersects;this.$router.push({path:\\\"/happy\\\"}),this.$forceUpdate(),console.log(\\\"Click to happy\\\")},setup:function(){},renderWebGL:function(){TWEEN.update(),this.animatable.time.value+=.01,this.scene&&this.camera&&this.renderer&&this.renderer.render(this.scene,this.camera)}},watch:{camera:function(){this.camera&&this.renderer&&(this.ready=!0)},renderer:function(){this.camera&&this.renderer&&(this.ready=!0)},ready:function(){this.ready&&this.setup()}},created:function(){},activated:function(){function e(n){t.rAFID=window.requestAnimationFrame(e),t.renderWebGL(n)}var t=this;t.rAFID=window.requestAnimationFrame(e)},deactivated:function(){window.cancelAnimationFrame(this.rAFID)}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/pages/Happy.vue\\\",[\\\"exports\\\",\\\"@/webgl/Bundle.js\\\",\\\"@/shader/Fling/vs.vert\\\",\\\"@/shader/Simple/vs.vert\\\",\\\"@/shader/Simple/fs.frag\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/webgl/Bundle.js\\\"),require(\\\"@/shader/Fling/vs.vert\\\"),require(\\\"@/shader/Simple/vs.vert\\\"),require(\\\"@/shader/Simple/fs.frag\\\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs,e.shaderFlingVsVert,e.shaderSimpleVsVert,e.shaderSimpleFsFrag),e.webglPagesHappyVue=n.exports}}(this,function(e,t,n,i,r){\\\"use strict\\\";function s(e){return e&&e.__esModule?e:{default:e}}function o(e,t){return null!=t&&\\\"undefined\\\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function a(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\\\" \\\"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\\\"\\\"))});var a=o.join(\\\",\\\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(o(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\\\"load\\\",function t(){e.removeEventListener(\\\"load\\\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var u=s(t),d=s(n),c=s(i),l=s(r),p=\\\"\\\\n.full{\\\\n  width: 100%;\\\\n  height: 100%;\\\\n}\\\\n\\\",f=document.head||document.getElementsByTagName(\\\"head\\\")[0],h=document.createElement(\\\"style\\\");h.type=\\\"text/css\\\",h.styleSheet?h.styleSheet.cssText=p:h.appendChild(document.createTextNode(p)),f.appendChild(h),a(h,\\\"[data-s-lc4]\\\"),e.default={template:'\\\\n  <div class=\\\"\\\"data-s-lc4>\\\\n\\\\n    <PerspectiveCamera\\\\n      :fov=\\\"75\\\"\\\\n      :aspect=\\\"size.aspect\\\"\\\\n      :near=\\\"1\\\"\\\\n      :far=\\\"1000\\\"\\\\n      :position=\\\"{ x: 0, y: 0, z: 10 }\\\"\\\\n      @camera=\\\"(v) => { camera = v; }\\\"\\\\n    />\\\\n    \\\\n    <Scene @scene=\\\"(v) => { scene = v }\\\">\\\\n      <Object3D pz=\\\"10\\\">\\\\n        <PointLight />\\\\n      </Object3D>\\\\n      \\\\n      <Object3D pz=\\\"0\\\">\\\\n        <Points @element=\\\"(v) => { v.$skipRayCast = true }\\\">\\\\n          <SphereBufferGeometry />\\\\n          <ShaderMaterial :vs=\\\"simpleVS2\\\" :fs=\\\"simpleFS\\\" :uniforms=\\\"animatable\\\" />\\\\n        </Points>\\\\n      </Object3D>\\\\n      \\\\n      <Object3D pz=\\\"1\\\">\\\\n        <Mesh>\\\\n          <SphereBufferGeometry />\\\\n          <ShaderMaterial :vs=\\\"simpleVS\\\" :fs=\\\"simpleFS\\\" :uniforms=\\\"animatable\\\" />\\\\n        </Mesh>\\\\n      </Object3D>\\\\n    </Scene>\\\\n    \\\\n    <Raycaster v-if=\\\"renderer && camera && toucher && scene\\\" :scene=\\\"scene\\\" :toucher=\\\"toucher\\\" :camera=\\\"camera\\\" @found=\\\"(v) => { found = v; }\\\" @click=\\\"onClick\\\">\\\\n    </Raycaster>\\\\n\\\\n  </div>\\\\n',name:\\\"Happy\\\",props:{toucher:{},size:{},renderer:{},doc:{}},components:Object.assign({},u.default),computed:{},data:function(){return{cam:{pos:{x:3,y:5,z:10}},ready:!1,cubeCamera:!1,visible:!0,resizer:function(){},scene:!1,camera:!1,found:[],animatable:{time:{value:0}},simpleVS:c.default,simpleFS:l.default,simpleVS2:d.default}},methods:{onClick:function(e){var t=e.event,n=e.intersects;console.log(t,n),this.$router.push(\\\"/\\\")},setup:function(){},renderWebGL:function(){TWEEN.update(),this.animatable.time.value+=.01,this.scene&&this.camera&&this.renderer&&this.renderer.render(this.scene,this.camera)}},watch:{camera:function(){this.camera&&this.renderer&&(this.ready=!0)},renderer:function(){this.camera&&this.renderer&&(this.ready=!0)},ready:function(){this.ready&&this.setup()}},created:function(){},activated:function(){function e(n){t.rAFID=window.requestAnimationFrame(e),t.renderWebGL(n)}var t=this;t.rAFID=window.requestAnimationFrame(e)},deactivated:function(){window.cancelAnimationFrame(this.rAFID),console.log(\\\"cancel animation frame\\\")}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/sample.vue\\\",[\\\"exports\\\",\\\"@/webgl/Bundle.js\\\",\\\"@/shader/Simple/vs.vert\\\",\\\"@/shader/Simple/fs.frag\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/webgl/Bundle.js\\\"),require(\\\"@/shader/Simple/vs.vert\\\"),require(\\\"@/shader/Simple/fs.frag\\\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs,e.shaderSimpleVsVert,e.shaderSimpleFsFrag),e.webglSampleVue=n.exports}}(this,function(e,t,n,i){\\\"use strict\\\";function r(e){return e&&e.__esModule?e:{default:e}}function s(e,t){return null!=t&&\\\"undefined\\\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function o(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\\\" \\\"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\\\"\\\"))});var a=o.join(\\\",\\\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(s(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\\\"load\\\",function t(){e.removeEventListener(\\\"load\\\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var a=r(t),u=r(n),d=r(i),c=\\\"\\\\n.full{\\\\n  width: 100%;\\\\n  height: 100%;\\\\n}\\\\n.touch-surface{\\\\n  position: absolute;\\\\n  top: 0px;\\\\n  left: 0px;\\\\n}\\\\n\\\",l=document.head||document.getElementsByTagName(\\\"head\\\")[0],p=document.createElement(\\\"style\\\");p.type=\\\"text/css\\\",p.styleSheet?p.styleSheet.cssText=c:p.appendChild(document.createTextNode(c)),l.appendChild(p),o(p,\\\"[data-s-622]\\\"),e.default={template:'\\\\n  <div class=\\\"full\\\"data-s-622>\\\\n\\\\n    <Renderer\\\\n      ref=\\\"renderer\\\"\\\\n      :size=\\\"size\\\"\\\\n      @renderer=\\\"(v) => { renderer = v }\\\"\\\\n    >\\\\n    </Renderer>\\\\n    \\\\n    <div class=\\\"full touch-surface\\\"></div>\\\\n\\\\n    <PerspectiveCamera\\\\n      :fov=\\\"75\\\"\\\\n      :aspect=\\\"size.aspect\\\"\\\\n      :near=\\\"1\\\"\\\\n      :far=\\\"1000\\\"\\\\n      :position=\\\"{ x: 0, y: 0, z: 10 }\\\"\\\\n      @camera=\\\"(v) => { camera = v; }\\\"\\\\n    />\\\\n\\\\n    <Scene @scene=\\\"(v) => { scene = v }\\\">\\\\n      <Object3D pz=\\\"10\\\">\\\\n        <PointLight />\\\\n      </Object3D>\\\\n      \\\\n      <Object3D pz=\\\"0\\\">\\\\n        <Points>\\\\n          <SphereBufferGeometry />\\\\n          <ShaderMaterial :vs=\\\"simpleVS\\\" :fs=\\\"simpleFS\\\" :uniforms=\\\"animatable\\\" />\\\\n        </Points>\\\\n      </Object3D>\\\\n      \\\\n    </Scene>\\\\n\\\\n  </div>\\\\n',components:Object.assign({},a.default),computed:{},methods:{renderWebGL:function(){this.animatable.time.value=.001*window.performance.now(),this.scene&&this.camera&&this.renderer&&this.renderer.render(this.scene,this.camera)}},data:function(){return{animatable:{time:{value:0}},simpleVS:u.default,simpleFS:d.default,size:{width:window.innerWidth,height:window.innerHeight,aspect:window.innerWidth/window.innerHeight},renderer:!1,scene:!1,camera:!1}},created:function(){},mounted:function(){function e(){t.rAFID=window.requestAnimationFrame(e),t.renderWebGL()}var t=this;t.rAFID=window.requestAnimationFrame(e)}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/Bundle.js\\\",[\\\"exports\\\",\\\"@/webgl/System/Renderer.vue\\\",\\\"@/webgl/System/Scene.vue\\\",\\\"@/webgl/System/PerspectiveCamera.vue\\\",\\\"@/webgl/System/Raycaster.vue\\\",\\\"@/webgl/Material/MeshPhongMaterial.vue\\\",\\\"@/webgl/Material/ShaderMaterial.vue\\\",\\\"@/webgl/Element/Object3D.vue\\\",\\\"@/webgl/Element/Mesh.vue\\\",\\\"@/webgl/Element/Points.vue\\\",\\\"@/webgl/Element/PointLight.vue\\\",\\\"@/webgl/Geo/SphereBufferGeometry.vue\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/webgl/System/Renderer.vue\\\"),require(\\\"@/webgl/System/Scene.vue\\\"),require(\\\"@/webgl/System/PerspectiveCamera.vue\\\"),require(\\\"@/webgl/System/Raycaster.vue\\\"),require(\\\"@/webgl/Material/MeshPhongMaterial.vue\\\"),require(\\\"@/webgl/Material/ShaderMaterial.vue\\\"),require(\\\"@/webgl/Element/Object3D.vue\\\"),require(\\\"@/webgl/Element/Mesh.vue\\\"),require(\\\"@/webgl/Element/Points.vue\\\"),require(\\\"@/webgl/Element/PointLight.vue\\\"),require(\\\"@/webgl/Geo/SphereBufferGeometry.vue\\\"));else{var n={exports:{}};t(n.exports,e.webglSystemRendererVue,e.webglSystemSceneVue,e.webglSystemPerspectiveCameraVue,e.webglSystemRaycasterVue,e.webglMaterialMeshPhongMaterialVue,e.webglMaterialShaderMaterialVue,e.webglElementObject3DVue,e.webglElementMeshVue,e.webglElementPointsVue,e.webglElementPointLightVue,e.webglGeoSphereBufferGeometryVue),e.webglBundleJs=n.exports}}(this,function(e,t,n,i,r,s,o,a,u,d,c,l){\\\"use strict\\\";function p(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var f=p(t),h=p(n),m=p(i),v=p(r),g=p(s),x=p(o),y=p(a),b=p(u),w=p(d),S=p(c),E=p(l);e.default={MeshPhongMaterial:g.default,ShaderMaterial:x.default,Renderer:f.default,Scene:h.default,PerspectiveCamera:m.default,Raycaster:v.default,PointLight:S.default,Points:w.default,Object3D:y.default,Mesh:b.default,SphereBufferGeometry:E.default}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/System/Renderer.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglSystemRendererVue=n.exports}}(this,function(e){\\\"use strict\\\";function t(e,t){return null!=t&&\\\"undefined\\\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function n(e,n){function i(){for(var t=e.sheet,i=t.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(n+\\\" \\\"+e);var t=e.match(/([^ :]+)(.+)?/);o.push(t[1]+n+(t[2]||\\\"\\\"))});var a=o.join(\\\",\\\")+s.cssText.substr(s.selectorText.length);t.deleteRule(r),t.insertRule(a,r)}}}try{i()}catch(n){if(t(n,DOMException)&&n.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\\\"load\\\",function t(){e.removeEventListener(\\\"load\\\",t),setTimeout(function(){i(),e.sheet.disabled=!1})});throw n}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var i=\\\"\\\\n.full{\\\\n  width: 100%;\\\\n  height: 100%;\\\\n}\\\\n.pos-rel{\\\\n  position: relative;\\\\n}\\\\n.layer{\\\\n  position: absolute;\\\\n  top: 0px;\\\\n  left: 0px;\\\\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\\\\n}\\\\n\\\\n\\\",r=document.head||document.getElementsByTagName(\\\"head\\\")[0],s=document.createElement(\\\"style\\\");s.type=\\\"text/css\\\",s.styleSheet?s.styleSheet.cssText=i:s.appendChild(document.createTextNode(i)),r.appendChild(s),n(s,\\\"[data-s-naf]\\\");var o=window.THREE;e.default={template:'\\\\n  <div class=\\\"full pos-rel\\\"data-s-naf>\\\\n    <div class=\\\"full layer\\\" ref=\\\"mounter\\\"></div>\\\\n    <div class=\\\"full layer\\\" ref=\\\"toucher\\\"><slot></slot></div>\\\\n  </div>\\\\n',data:function(){return{renderer:!1}},props:{size:{default:function(){return{width:500,height:500}}},alpha:{default:!0},antialias:{default:!0}},mounted:function(){this.renderer=new o.WebGLRenderer({alpha:this.alpha,antialias:this.antialias}),this.resize(),this.renderer.domElement.style.marginBottom=\\\"-6px\\\",this.renderer.domElement.addEventListener(\\\"touchstart\\\",function(){},!0),this.$refs.mounter.appendChild(this.renderer.domElement),this.$emit(\\\"toucher\\\",this.$refs.toucher),this.$emit(\\\"renderer\\\",this.renderer)},beforeDestroy:function(){this.$refs.mounter.removeChild(this.renderer.domElement)},watch:{size:function(){this.resize()}},methods:{resize:function(){var e=window.devicePixelRatio||1;this.renderer.setPixelRatio(e),this.renderer.setSize(this.size.width,this.size.height)}}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/System/Scene.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglSystemSceneVue=n.exports}}(this,function(e){\\\"use strict\\\";function t(e,t){return null!=t&&\\\"undefined\\\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function n(e,n){function i(){for(var t=e.sheet,i=t.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(n+\\\" \\\"+e);var t=e.match(/([^ :]+)(.+)?/);o.push(t[1]+n+(t[2]||\\\"\\\"))});var a=o.join(\\\",\\\")+s.cssText.substr(s.selectorText.length);t.deleteRule(r),t.insertRule(a,r)}}}try{i()}catch(n){if(t(n,DOMException)&&n.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\\\"load\\\",function t(){e.removeEventListener(\\\"load\\\",t),setTimeout(function(){i(),e.sheet.disabled=!1})});throw n}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var i=\\\"\\\\n.mounter {\\\\n  display: none;\\\\n}\\\\n\\\",r=document.head||document.getElementsByTagName(\\\"head\\\")[0],s=document.createElement(\\\"style\\\");s.type=\\\"text/css\\\",s.styleSheet?s.styleSheet.cssText=i:s.appendChild(document.createTextNode(i)),r.appendChild(s),n(s,\\\"[data-s-avi]\\\");var o=window.THREE;e.default={template:'\\\\n  <div ref=\\\"mounter\\\" class=\\\"mounter\\\"data-s-avi><slot></slot></div>\\\\n',data:function(){return{scene:!1}},props:{size:{default:function(){return{width:500,height:500}}},alpha:{default:!0},antialias:{default:!0}},created:function(){var e=this;this.scene=new o.Scene,this.$on(\\\"add\\\",function(t){e.scene.add(t)}),this.$on(\\\"remove\\\",function(t){e.scene.remove(t)})},mounted:function(){this.$emit(\\\"scene\\\",this.scene)}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/System/PerspectiveCamera.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglSystemPerspectiveCameraVue=n.exports}}(this,function(e){\\\"use strict\\\";function t(e,t){return null!=t&&\\\"undefined\\\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function n(e,n){function i(){for(var t=e.sheet,i=t.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(n+\\\" \\\"+e);var t=e.match(/([^ :]+)(.+)?/);o.push(t[1]+n+(t[2]||\\\"\\\"))});var a=o.join(\\\",\\\")+s.cssText.substr(s.selectorText.length);t.deleteRule(r),t.insertRule(a,r)}}}try{i()}catch(n){if(t(n,DOMException)&&n.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\\\"load\\\",function t(){e.removeEventListener(\\\"load\\\",t),setTimeout(function(){i(),e.sheet.disabled=!1})});throw n}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var i=\\\"\\\\n.perspective-camera{\\\\n  display: none;\\\\n}\\\\n\\\",r=document.head||document.getElementsByTagName(\\\"head\\\")[0],s=document.createElement(\\\"style\\\");s.type=\\\"text/css\\\",s.styleSheet?s.styleSheet.cssText=i:s.appendChild(document.createTextNode(i)),r.appendChild(s),n(s,\\\"[data-s-j3g]\\\");var o=window.THREE;e.default={template:\\\"\\\",abstract:!0,render:function(){return null},props:[\\\"fov\\\",\\\"aspect\\\",\\\"near\\\",\\\"far\\\",\\\"position\\\"],data:function(){return{camera:null}},created:function(){this.camera=new o.PerspectiveCamera(this.fov,this.aspect,this.near,this.far),this.position&&(this.camera.position.x=this.position.x,this.camera.position.y=this.position.y,this.camera.position.z=this.position.z),this.$emit(\\\"camera\\\",this.camera)},watch:{position:function(){this.position&&(this.camera.position.x=this.position.x,this.camera.position.y=this.position.y,this.camera.position.z=this.position.z)},aspect:function(){this.camera&&(this.camera.aspect=this.aspect,this.camera.updateProjectionMatrix())}}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/System/Raycaster.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglSystemRaycasterVue=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var t=\\\"\\\\n\\\\n\\\",n=document.head||document.getElementsByTagName(\\\"head\\\")[0],i=document.createElement(\\\"style\\\");i.type=\\\"text/css\\\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i),e.default={template:\\\"\\\\n<divdata-s-exk></div>\\\\n\\\",data:function(){return{rAFID:0,mouse:null,raycast:function(){},clean:function(){},intersects:[]}},props:{scene:{},camera:{},toucher:{}},created:function(){},activated:function(){var e=this,t=new THREE.Raycaster;this.mouse=new THREE.Vector2,this.toucher.addEventListener(\\\"mousemove\\\",this.handleMV,!1),this.toucher.addEventListener(\\\"click\\\",this.handleClick,!1),this.clean=function(){e.toucher.removeEventListener(\\\"click\\\",e.handleClick,!1),e.toucher.removeEventListener(\\\"mousemove\\\",e.handleMV)};var n=function(){var n=e.mouse,i=e.scene,r=e.camera,s=[];e.scene.traverse(function(e){e.$skipRayCast&&(s.push({parent:e.parent,ele:e}),e.parent.remove(e))}),t.setFromCamera(n,r);var o=t.intersectObjects(i.children,!0);return s.forEach(function(e){e.parent.add(e.ele)}),o};this.raycast=n;var i=function t(){e.rAFID=window.requestAnimationFrame(t)};this.rAFID=window.requestAnimationFrame(i)},deactivated:function(){window.cancelAnimationFrame(this.rAFID),this.clean()},methods:{handleClick:function(e){this.$emit(\\\"click\\\",{event:e,intersects:this.raycast()})},handleMV:function(e){this.mouse.x=e.clientX/window.innerWidth*2-1,this.mouse.y=-e.clientY/window.innerHeight*2+1}}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/Material/MeshPhongMaterial.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglMaterialMeshPhongMaterialVue=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var t=\\\"\\\\n\\\\n\\\",n=document.head||document.getElementsByTagName(\\\"head\\\")[0],i=document.createElement(\\\"style\\\");i.type=\\\"text/css\\\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\\\n<div class=\\\"mesh-phong-material\\\"data-s-17bg></div>\\\\n',props:{color:{default:function(){return 16777215*Math.random()}}},data:function(){return{material:!1}},created:function(){this.material=new r.MeshPhongMaterial({color:new r.Color(this.color),specular:new r.Color(1118481),shininess:50}),this.$parent.$emit(\\\"material\\\",this.material)}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/Material/ShaderMaterial.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglMaterialShaderMaterialVue=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var t=\\\"\\\\n\\\\n\\\",n=document.head||document.getElementsByTagName(\\\"head\\\")[0],i=document.createElement(\\\"style\\\");i.type=\\\"text/css\\\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\\\n<div class=\\\"mesh-basic-material\\\"data-s-zxp></div>\\\\n',data:function(){return{material:!1}},props:{vs:{default:\\\"void main ( void ) {\\\\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\\n  vec4 outputPos = projectionMatrix * mvPosition;\\\\n  gl_Position = outputPos;\\\\n}\\\"},fs:{default:\\\"void main () {\\\\n  gl_FragColor = vec4(vec3(0.5), 1.0);\\\\n}\\\"},uniforms:{default:function(){return{}}}},watch:{vs:function(){this.initShader()},fs:function(){this.initShader()},uniforms:function(){this.initShader()}},mounted:function(){this.initShader()},methods:{initShader:function(){try{this.material=new r.ShaderMaterial({uniforms:Object.assign({},this.uniforms),vertexShader:this.vs||this.$options.props.vs.default,fragmentShader:this.fs||this.$options.props.fs.default}),this.$parent.$emit(\\\"material\\\",this.material)}catch(e){console.log(e)}}}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/Element/PointLight.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglElementPointLightVue=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var t=\\\"\\\\n\\\\n\\\",n=document.head||document.getElementsByTagName(\\\"head\\\")[0],i=document.createElement(\\\"style\\\");i.type=\\\"text/css\\\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\\\n  <div class=\\\"light-point\\\"data-s-3k3></div>\\\\n',props:{color:{default:function(){return 16777215}}},data:function(){return{light:!1}},mounted:function(){this.light=new r.PointLight({color:new r.Color(this.color)}),this.$emit(\\\"element\\\",this.light),this.$parent.$emit(\\\"add\\\",this.light)},beforeDestroy:function(){this.$parent.$emit(\\\"remove\\\",this.light)}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/Element/Object3D.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglElementObject3DVue=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var t=\\\"\\\\n\\\\n\\\",n=document.head||document.getElementsByTagName(\\\"head\\\")[0],i=document.createElement(\\\"style\\\");i.type=\\\"text/css\\\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\\\n<div class=\\\"object-3d\\\"data-s-fcu><slot></slot></div>\\\\n',data:function(){return{object3d:!1}},props:{visible:{default:!0},px:{default:0},py:{default:0},pz:{default:0},sx:{default:1},sy:{default:1},sz:{default:1},rx:{default:0},ry:{default:0},rz:{default:0}},watch:{visible:function(){this.object3d.setVisible(this.visible)},px:function(){this.updatePosition(\\\"x\\\",this.px)},py:function(){this.updatePosition(\\\"y\\\",this.py)},pz:function(){this.updatePosition(\\\"z\\\",this.pz)},sx:function(){this.updateScale(\\\"x\\\",this.sx)},sy:function(){this.updateScale(\\\"y\\\",this.sy)},sz:function(){this.updateScale(\\\"z\\\",this.sz)},rx:function(){this.updateRotation(\\\"x\\\",this.rx)},ry:function(){this.updateRotation(\\\"y\\\",this.ry)},rz:function(){this.updateRotation(\\\"z\\\",this.rz)}},created:function(){var e=this;this.object3d=new r.Object3D,this.$emit(\\\"element\\\",this.object3d),this.object3d.visible=!0,this.updatePosition(),this.updateScale(),this.updateRotation(),this.$on(\\\"add\\\",function(t){e.object3d.add(t)}),this.$on(\\\"remove\\\",function(t){e.object3d.remove(t)})},mounted:function(){this.$parent.$emit(\\\"add\\\",this.object3d)},beforeDestroy:function(){this.$parent.$emit(\\\"remove\\\",this.object3d)},methods:{updatePosition:function(e,t){e?this.object3d.position[e]=t:this.object3d.position.set(this.px,this.py,this.pz)},updateScale:function(e,t){e?this.object3d.scale[e]=t:this.object3d.scale.set(this.sx,this.sy,this.sz)},updateRotation:function(e,t){e?this.object3d.rotation[e]=t:this.object3d.rotation.set(this.rx,this.ry,this.rz)}}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/Element/Points.vue\\\",[\\\"exports\\\",\\\"@/three.js\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports,require(\\\"@/three.js\\\"));else{var n={exports:{}};t(n.exports,e.threeJs),e.webglElementPointsVue=n.exports}}(this,function(e,t){\\\"use strict\\\";function n(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var i=n(t),r=\\\"\\\\n\\\\n\\\",s=document.head||document.getElementsByTagName(\\\"head\\\")[0],o=document.createElement(\\\"style\\\");o.type=\\\"text/css\\\",o.styleSheet?o.styleSheet.cssText=r:o.appendChild(document.createTextNode(r)),s.appendChild(o),e.default={template:'\\\\n  <div class=\\\"points\\\"data-s-24l1>\\\\n    <slot>\\\\n    </slot>\\\\n  </div>\\\\n',props:{position:{}},data:function(){return{element:!1,points:!1,material:!1,geometry:!1}},created:function(){var e=this;this.element=this.points=new i.default.Points,this.$parent.$emit(\\\"add\\\",this.points),this.$emit(\\\"element\\\",this.points),this.$on(\\\"material\\\",function(t){e.material=t,e.tryUpdateMaterial()}),this.$on(\\\"geometry\\\",function(t){e.geometry=t,e.tryUpdateGeometry()})},beforeDestroy:function(){this.uninstall()},methods:{tryUpdateGeometry:function(e){this.points&&(this.points.geometry=this.geometry)},tryUpdateMaterial:function(e){this.points&&(this.points.material=this.material)},uninstall:function(){this.$parent.$emit(\\\"remove\\\",this.points)}}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/Element/Mesh.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglElementMeshVue=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var t=\\\"\\\\n\\\\n\\\",n=document.head||document.getElementsByTagName(\\\"head\\\")[0],i=document.createElement(\\\"style\\\");i.type=\\\"text/css\\\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\\\n  <div class=\\\"mesh\\\"data-s-18qt>\\\\n    <slot>\\\\n    </slot>\\\\n  </div>\\\\n',props:{},data:function(){return{element:!1,mesh:!1,material:!1,geometry:!1}},created:function(){var e=this;this.element=this.mesh=new r.Mesh,this.$parent.$emit(\\\"add\\\",this.mesh),this.$emit(\\\"element\\\",this.mesh),this.$on(\\\"material\\\",function(t){e.material=t,e.tryUpdateMaterial()}),this.$on(\\\"geometry\\\",function(t){e.geometry=t,e.tryUpdateGeometry()})},beforeDestroy:function(){this.uninstall()},methods:{tryUpdateGeometry:function(e){this.mesh&&(this.mesh.geometry=this.geometry)},tryUpdateMaterial:function(e){this.mesh&&(this.mesh.material=this.material)},uninstall:function(){this.$parent.$emit(\\\"remove\\\",this.mesh)}}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/webgl/Geo/SphereBufferGeometry.vue\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglGeoSphereBufferGeometryVue=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var t=\\\"\\\\n\\\\n\\\",n=document.head||document.getElementsByTagName(\\\"head\\\")[0],i=document.createElement(\\\"style\\\");i.type=\\\"text/css\\\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\\\n  <div class=\\\"geo-sphere\\\"data-s-bg></div>\\\\n',data:function(){return{geometry:!1}},mounted:function(){var e=new r.SphereBufferGeometry(2,256,256);this.$parent.$emit(\\\"geometry\\\",e)}}}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/shader/Simple/vs.vert\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.shaderSimpleVsVert=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0}),e.default=\\\"varying vec3 vPos;\\\\nuniform float time;\\\\n\\\\nvoid main (void) {\\\\n  vPos = position;\\\\n  vPos.x = vPos.x + sin(vPos.x + time);\\\\n  vPos.y = vPos.y + cos(vPos.y + time);\\\\n  vPos.z = vPos.z + tan(vPos.z + time);\\\\n  \\\\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\\\n  vec4 outputPos = projectionMatrix * mvPosition;\\\\n  gl_Position = outputPos;\\\\n  gl_PointSize = 1.0;\\\\n}\\\"}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/shader/Simple/fs.frag\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.shaderSimpleFsFrag=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0}),e.default=\\\"varying vec3 vPos;\\\\n\\\\nvoid main () {\\\\n  gl_FragColor = vec4(vec3(vPos), 1.0);\\\\n}\\\"}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/shader/Fling/vs.vert\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.shaderFlingVsVert=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0}),e.default=\\\"varying vec3 vPos;\\\\nuniform float time;\\\\n\\\\nvoid main (void) {\\\\n  vPos = position;\\\\n  vPos.x = vPos.x + sin(vPos.x + time);\\\\n  vPos.y = vPos.y + cos(vPos.y + time);\\\\n  vPos.z = vPos.z + tan(vPos.z + time);\\\\n  \\\\n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\\\\n  vec4 outputPos = projectionMatrix * mvPosition;\\\\n  gl_Position = outputPos;\\\\n  gl_PointSize = 1.0;\\\\n}\\\\n\\\"}),function(e,t){if(\\\"function\\\"==typeof define&&define.amd)define(\\\"@/three.js\\\",[\\\"exports\\\"],t);else if(\\\"undefined\\\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.threeJs=n.exports}}(this,function(e){\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0});var t=window.THREE;e.default=t});\\n\\n    var deps = [\\\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\\\",\\\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\\\",\\\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\\\",\\\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\\\",\\\"https://threejs.org/examples/js/GPUComputationRenderer.js\\\"];\\n\\n    function preload (deps, done) {\\n      if (deps[0]) {\\n        var script = document.createElement('script');\\n        script.onload = function () {\\n          deps.shift();\\n          preload(deps, done);\\n        };\\n        script.src = deps[0];\\n        document.body.appendChild(script);\\n      } else {\\n        done();\\n      }\\n    }\\n    preload(deps, function () {});\\n    preload(deps, function() {\\n      requireJSRequire(['@/main.js'], function () {\\n        setTimeout(() => {\\n\\n          window.addEventListener('message', (e) => {\\n            // is from main window to this iframe window\\n            if (\\n              (e.source === window.top) &&\\n              e.data &&\\n              e.data.type\\n            ) {\\n              console.log('iFrame Got Main Message: ', e.data)\\n              console.log('iFrame Dispatching Custom Event: ', e.data)\\n              let customEvent = new CustomEvent(e.data.type, { detail: e.data });\\n              window.dispatchEvent(customEvent);\\n            }\\n          });\\n\\n          (window.opener || window.top).postMessage({ type: 'iframe-system-ready', detail: { status: 'ok' } }, window.location.origin);\\n        }, 10);\\n      });\\n    });\\n\\n  }\\n  new OMG_KCsVcjjednlGSjCajzecXtVY();\\n}());\\n\";\n\n    function addBlobScript(js) {\n      var url = URL.createObjectURL(new Blob([js], { type: 'script/javascript' }));\n      var newJS = document.createElement('script');\n      newJS.src = url;\n      document.body.appendChild(newJS);\n    }\n\n    addBlobScript(app);\n\n  }());\n  </script></body>\n</html>\n","origHtml":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n","js":"\n\n(function(){\n  var requireJSRequire,require,define;!function(global,setTimeout){function commentReplace(e,t){return t||\"\"}function isFunction(e){return\"[object Function]\"===ostring.call(e)}function isArray(e){return\"[object Array]\"===ostring.call(e)}function each(e,t){if(e){var n;for(n=0;n<e.length&&(!e[n]||!t(e[n],n,e));n+=1);}}function eachReverse(e,t){if(e){var n;for(n=e.length-1;n>-1&&(!e[n]||!t(e[n],n,e));n-=1);}}function hasProp(e,t){return hasOwn.call(e,t)}function getOwn(e,t){return hasProp(e,t)&&e[t]}function eachProp(e,t){var n;for(n in e)if(hasProp(e,n)&&t(e[n],n))break}function mixin(e,t,n,i){return t&&eachProp(t,function(t,r){!n&&hasProp(e,r)||(!i||\"object\"!=typeof t||!t||isArray(t)||isFunction(t)||t instanceof RegExp?e[r]=t:(e[r]||(e[r]={}),mixin(e[r],t,n,i)))}),e}function bind(e,t){return function(){return t.apply(e,arguments)}}function scripts(){return document.getElementsByTagName(\"script\")}function defaultOnError(e){throw e}function getGlobal(e){if(!e)return e;var t=global;return each(e.split(\".\"),function(e){t=t[e]}),t}function makeError(e,t,n,i){var r=new Error(t+\"\\nhttp://requirejs.org/docs/errors.html#\"+e);return r.requireType=e,r.requireModules=i,n&&(r.originalError=n),r}function newContext(e){function t(e){var t,n;for(t=0;t<e.length;t++)if(\".\"===(n=e[t]))e.splice(t,1),t-=1;else if(\"..\"===n){if(0===t||1===t&&\"..\"===e[2]||\"..\"===e[t-1])continue;t>0&&(e.splice(t-1,2),t-=2)}}function n(e,n,i){var r,s,o,a,u,c,d,l,p,f,h,m=n&&n.split(\"/\"),g=E.map,v=g&&g[\"*\"];if(e&&(e=e.split(\"/\"),c=e.length-1,E.nodeIdCompat&&jsSuffixRegExp.test(e[c])&&(e[c]=e[c].replace(jsSuffixRegExp,\"\")),\".\"===e[0].charAt(0)&&m&&(h=m.slice(0,m.length-1),e=h.concat(e)),t(e),e=e.join(\"/\")),i&&g&&(m||v)){s=e.split(\"/\");e:for(o=s.length;o>0;o-=1){if(u=s.slice(0,o).join(\"/\"),m)for(a=m.length;a>0;a-=1)if((r=getOwn(g,m.slice(0,a).join(\"/\")))&&(r=getOwn(r,u))){d=r,l=o;break e}!p&&v&&getOwn(v,u)&&(p=getOwn(v,u),f=o)}!d&&p&&(d=p,l=f),d&&(s.splice(0,l,d),e=s.join(\"/\"))}return getOwn(E.pkgs,e)||e}function i(e){isBrowser&&each(scripts(),function(t){if(t.getAttribute(\"data-requiremodule\")===e&&t.getAttribute(\"data-requirecontext\")===b.contextName)return t.parentNode.removeChild(t),!0})}function r(e){var t=getOwn(E.paths,e);if(t&&isArray(t)&&t.length>1)return t.shift(),b.require.undef(e),b.makeRequire(null,{skipMap:!0})([e]),!0}function s(e){var t,n=e?e.indexOf(\"!\"):-1;return n>-1&&(t=e.substring(0,n),e=e.substring(n+1,e.length)),[t,e]}function o(e,t,i,r){var o,a,u,c,d=null,l=t?t.name:null,p=e,f=!0,h=\"\";return e||(f=!1,e=\"_@r\"+(R+=1)),c=s(e),d=c[0],e=c[1],d&&(d=n(d,l,r),a=getOwn(P,d)),e&&(d?h=i?e:a&&a.normalize?a.normalize(e,function(e){return n(e,l,r)}):-1===e.indexOf(\"!\")?n(e,l,r):e:(h=n(e,l,r),c=s(h),d=c[0],h=c[1],i=!0,o=b.nameToUrl(h))),u=!d||a||i?\"\":\"_unnormalized\"+(T+=1),{prefix:d,name:h,parentMap:t,unnormalized:!!u,url:o,originalName:p,isDefine:f,id:(d?d+\"!\"+h:h)+u}}function a(e){var t=e.id,n=getOwn(S,t);return n||(n=S[t]=new b.Module(e)),n}function u(e,t,n){var i=e.id,r=getOwn(S,i);!hasProp(P,i)||r&&!r.defineEmitComplete?(r=a(e),r.error&&\"error\"===t?n(r.error):r.on(t,n)):\"defined\"===t&&n(P[i])}function c(e,t){var n=e.requireModules,i=!1;t?t(e):(each(n,function(t){var n=getOwn(S,t);n&&(n.error=e,n.events.error&&(i=!0,n.emit(\"error\",e)))}),i||req.onError(e))}function d(){globalDefQueue.length&&(each(globalDefQueue,function(e){var t=e[0];\"string\"==typeof t&&(b.defQueueMap[t]=!0),O.push(e)}),globalDefQueue=[])}function l(e){delete S[e],delete q[e]}function p(e,t,n){var i=e.map.id;e.error?e.emit(\"error\",e.error):(t[i]=!0,each(e.depMaps,function(i,r){var s=i.id,o=getOwn(S,s);!o||e.depMatched[r]||n[s]||(getOwn(t,s)?(e.defineDep(r,P[s]),e.check()):p(o,t,n))}),n[i]=!0)}function f(){var e,t,n=1e3*E.waitSeconds,s=n&&b.startTime+n<(new Date).getTime(),o=[],a=[],u=!1,d=!0;if(!v){if(v=!0,eachProp(q,function(e){var n=e.map,c=n.id;if(e.enabled&&(n.isDefine||a.push(e),!e.error))if(!e.inited&&s)r(c)?(t=!0,u=!0):(o.push(c),i(c));else if(!e.inited&&e.fetched&&n.isDefine&&(u=!0,!n.prefix))return d=!1}),s&&o.length)return e=makeError(\"timeout\",\"Load timeout for modules: \"+o,null,o),e.contextName=b.contextName,c(e);d&&each(a,function(e){p(e,{},{})}),s&&!t||!u||!isBrowser&&!isWebWorker||w||(w=setTimeout(function(){w=0,f()},50)),v=!1}}function h(e){hasProp(P,e[0])||a(o(e[0],null,!0)).init(e[1],e[2])}function m(e){var t=e.currentTarget||e.srcElement;return{node:t,id:t&&t.getAttribute(\"data-requiremodule\")}}function g(){var e;for(d();O.length;){if(e=O.shift(),null===e[0])return c(makeError(\"mismatch\",\"Mismatched anonymous define() module: \"+e[e.length-1]));h(e)}b.defQueueMap={}}var v,x,b,y,w,E={waitSeconds:7,baseUrl:\"./\",paths:{},bundles:{},pkgs:{},shim:{},config:{}},S={},q={},M={},O=[],P={},j={},k={},R=1,T=1;return y={require:function(e){return e.require?e.require:e.require=b.makeRequire(e.map)},exports:function(e){if(e.usingExports=!0,e.map.isDefine)return e.exports?P[e.map.id]=e.exports:e.exports=P[e.map.id]={}},module:function(e){return e.module?e.module:e.module={id:e.map.id,uri:e.map.url,config:function(){return getOwn(E.config,e.map.id)||{}},exports:e.exports||(e.exports={})}}},x=function(e){this.events=getOwn(M,e.id)||{},this.map=e,this.shim=getOwn(E.shim,e.id),this.depExports=[],this.depMaps=[],this.depMatched=[],this.pluginMaps={},this.depCount=0},x.prototype={init:function(e,t,n,i){i=i||{},this.inited||(this.factory=t,n?this.on(\"error\",n):this.events.error&&(n=bind(this,function(e){this.emit(\"error\",e)})),this.depMaps=e&&e.slice(0),this.errback=n,this.inited=!0,this.ignore=i.ignore,i.enabled||this.enabled?this.enable():this.check())},defineDep:function(e,t){this.depMatched[e]||(this.depMatched[e]=!0,this.depCount-=1,this.depExports[e]=t)},fetch:function(){if(!this.fetched){this.fetched=!0,b.startTime=(new Date).getTime();var e=this.map;if(!this.shim)return e.prefix?this.callPlugin():this.load();b.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],bind(this,function(){return e.prefix?this.callPlugin():this.load()}))}},load:function(){var e=this.map.url;j[e]||(j[e]=!0,b.load(this.map.id,e))},check:function(){if(this.enabled&&!this.enabling){var e,t,n=this.map.id,i=this.depExports,r=this.exports,s=this.factory;if(this.inited){if(this.error)this.emit(\"error\",this.error);else if(!this.defining){if(this.defining=!0,this.depCount<1&&!this.defined){if(isFunction(s)){if(this.events.error&&this.map.isDefine||req.onError!==defaultOnError)try{r=b.execCb(n,s,i,r)}catch(t){e=t}else r=b.execCb(n,s,i,r);if(this.map.isDefine&&void 0===r&&(t=this.module,t?r=t.exports:this.usingExports&&(r=this.exports)),e)return e.requireMap=this.map,e.requireModules=this.map.isDefine?[this.map.id]:null,e.requireType=this.map.isDefine?\"define\":\"require\",c(this.error=e)}else r=s;if(this.exports=r,this.map.isDefine&&!this.ignore&&(P[n]=r,req.onResourceLoad)){var o=[];each(this.depMaps,function(e){o.push(e.normalizedMap||e)}),req.onResourceLoad(b,this.map,o)}l(n),this.defined=!0}this.defining=!1,this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit(\"defined\",this.exports),this.defineEmitComplete=!0)}}else hasProp(b.defQueueMap,n)||this.fetch()}},callPlugin:function(){var e=this.map,t=e.id,i=o(e.prefix);this.depMaps.push(i),u(i,\"defined\",bind(this,function(i){var r,s,d,p=getOwn(k,this.map.id),f=this.map.name,h=this.map.parentMap?this.map.parentMap.name:null,m=b.makeRequire(e.parentMap,{enableBuildCallback:!0});return this.map.unnormalized?(i.normalize&&(f=i.normalize(f,function(e){return n(e,h,!0)})||\"\"),s=o(e.prefix+\"!\"+f,this.map.parentMap,!0),u(s,\"defined\",bind(this,function(e){this.map.normalizedMap=s,this.init([],function(){return e},null,{enabled:!0,ignore:!0})})),void((d=getOwn(S,s.id))&&(this.depMaps.push(s),this.events.error&&d.on(\"error\",bind(this,function(e){this.emit(\"error\",e)})),d.enable()))):p?(this.map.url=b.nameToUrl(p),void this.load()):(r=bind(this,function(e){this.init([],function(){return e},null,{enabled:!0})}),r.error=bind(this,function(e){this.inited=!0,this.error=e,e.requireModules=[t],eachProp(S,function(e){0===e.map.id.indexOf(t+\"_unnormalized\")&&l(e.map.id)}),c(e)}),r.fromText=bind(this,function(n,i){var s=e.name,u=o(s),d=useInteractive;i&&(n=i),d&&(useInteractive=!1),a(u),hasProp(E.config,t)&&(E.config[s]=E.config[t]);try{req.exec(n)}catch(e){return c(makeError(\"fromtexteval\",\"fromText eval for \"+t+\" failed: \"+e,e,[t]))}d&&(useInteractive=!0),this.depMaps.push(u),b.completeLoad(s),m([s],r)}),void i.load(e.name,m,r,E))})),b.enable(i,this),this.pluginMaps[i.id]=i},enable:function(){q[this.map.id]=this,this.enabled=!0,this.enabling=!0,each(this.depMaps,bind(this,function(e,t){var n,i,r;if(\"string\"==typeof e){if(e=o(e,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap),this.depMaps[t]=e,r=getOwn(y,e.id))return void(this.depExports[t]=r(this));this.depCount+=1,u(e,\"defined\",bind(this,function(e){this.undefed||(this.defineDep(t,e),this.check())})),this.errback?u(e,\"error\",bind(this,this.errback)):this.events.error&&u(e,\"error\",bind(this,function(e){this.emit(\"error\",e)}))}n=e.id,i=S[n],hasProp(y,n)||!i||i.enabled||b.enable(e,this)})),eachProp(this.pluginMaps,bind(this,function(e){var t=getOwn(S,e.id);t&&!t.enabled&&b.enable(e,this)})),this.enabling=!1,this.check()},on:function(e,t){var n=this.events[e];n||(n=this.events[e]=[]),n.push(t)},emit:function(e,t){each(this.events[e],function(e){e(t)}),\"error\"===e&&delete this.events[e]}},b={config:E,contextName:e,registry:S,defined:P,urlFetched:j,defQueue:O,defQueueMap:{},Module:x,makeModuleMap:o,nextTick:req.nextTick,onError:c,configure:function(e){if(e.baseUrl&&\"/\"!==e.baseUrl.charAt(e.baseUrl.length-1)&&(e.baseUrl+=\"/\"),\"string\"==typeof e.urlArgs){var t=e.urlArgs;e.urlArgs=function(e,n){return(-1===n.indexOf(\"?\")?\"?\":\"&\")+t}}var n=E.shim,i={paths:!0,bundles:!0,config:!0,map:!0};eachProp(e,function(e,t){i[t]?(E[t]||(E[t]={}),mixin(E[t],e,!0,!0)):E[t]=e}),e.bundles&&eachProp(e.bundles,function(e,t){each(e,function(e){e!==t&&(k[e]=t)})}),e.shim&&(eachProp(e.shim,function(e,t){isArray(e)&&(e={deps:e}),!e.exports&&!e.init||e.exportsFn||(e.exportsFn=b.makeShimExports(e)),n[t]=e}),E.shim=n),e.packages&&each(e.packages,function(e){var t,n;e=\"string\"==typeof e?{name:e}:e,n=e.name,t=e.location,t&&(E.paths[n]=e.location),E.pkgs[n]=e.name+\"/\"+(e.main||\"main\").replace(currDirRegExp,\"\").replace(jsSuffixRegExp,\"\")}),eachProp(S,function(e,t){e.inited||e.map.unnormalized||(e.map=o(t,null,!0))}),(e.deps||e.callback)&&b.require(e.deps||[],e.callback)},makeShimExports:function(e){function t(){var t;return e.init&&(t=e.init.apply(global,arguments)),t||e.exports&&getGlobal(e.exports)}return t},makeRequire:function(t,r){function s(n,i,u){var d,l,p;return r.enableBuildCallback&&i&&isFunction(i)&&(i.__requireJsBuild=!0),\"string\"==typeof n?isFunction(i)?c(makeError(\"requireargs\",\"Invalid require call\"),u):t&&hasProp(y,n)?y[n](S[t.id]):req.get?req.get(b,n,t,s):(l=o(n,t,!1,!0),d=l.id,hasProp(P,d)?P[d]:c(makeError(\"notloaded\",'Module name \"'+d+'\" has not been loaded yet for context: '+e+(t?\"\":\". Use require([])\")))):(g(),b.nextTick(function(){g(),p=a(o(null,t)),p.skipMap=r.skipMap,p.init(n,i,u,{enabled:!0}),f()}),s)}return r=r||{},mixin(s,{isBrowser:isBrowser,toUrl:function(e){var i,r=e.lastIndexOf(\".\"),s=e.split(\"/\")[0],o=\".\"===s||\"..\"===s;return-1!==r&&(!o||r>1)&&(i=e.substring(r,e.length),e=e.substring(0,r)),b.nameToUrl(n(e,t&&t.id,!0),i,!0)},defined:function(e){return hasProp(P,o(e,t,!1,!0).id)},specified:function(e){return e=o(e,t,!1,!0).id,hasProp(P,e)||hasProp(S,e)}}),t||(s.undef=function(e){d();var n=o(e,t,!0),r=getOwn(S,e);r.undefed=!0,i(e),delete P[e],delete j[n.url],delete M[e],eachReverse(O,function(t,n){t[0]===e&&O.splice(n,1)}),delete b.defQueueMap[e],r&&(r.events.defined&&(M[e]=r.events),l(e))}),s},enable:function(e){getOwn(S,e.id)&&a(e).enable()},completeLoad:function(e){var t,n,i,s=getOwn(E.shim,e)||{},o=s.exports;for(d();O.length;){if(n=O.shift(),null===n[0]){if(n[0]=e,t)break;t=!0}else n[0]===e&&(t=!0);h(n)}if(b.defQueueMap={},i=getOwn(S,e),!t&&!hasProp(P,e)&&i&&!i.inited){if(!(!E.enforceDefine||o&&getGlobal(o)))return r(e)?void 0:c(makeError(\"nodefine\",\"No define call for \"+e,null,[e]));h([e,s.deps||[],s.exportsFn])}f()},nameToUrl:function(e,t,n){var i,r,s,o,a,u,c,d=getOwn(E.pkgs,e);if(d&&(e=d),c=getOwn(k,e))return b.nameToUrl(c,t,n);if(req.jsExtRegExp.test(e))a=e+(t||\"\");else{for(i=E.paths,r=e.split(\"/\"),s=r.length;s>0;s-=1)if(o=r.slice(0,s).join(\"/\"),u=getOwn(i,o)){isArray(u)&&(u=u[0]),r.splice(0,s,u);break}a=r.join(\"/\"),a+=t||(/^data\\:|^blob\\:|\\?/.test(a)||n?\"\":\".js\"),a=(\"/\"===a.charAt(0)||a.match(/^[\\w\\+\\.\\-]+:/)?\"\":E.baseUrl)+a}return E.urlArgs&&!/^blob\\:/.test(a)?a+E.urlArgs(e,a):a},load:function(e,t){req.load(b,e,t)},execCb:function(e,t,n,i){return t.apply(i,n)},onScriptLoad:function(e){if(\"load\"===e.type||readyRegExp.test((e.currentTarget||e.srcElement).readyState)){interactiveScript=null;var t=m(e);b.completeLoad(t.id)}},onScriptError:function(e){var t=m(e);if(!r(t.id)){var n=[];return eachProp(S,function(e,i){0!==i.indexOf(\"_@r\")&&each(e.depMaps,function(e){if(e.id===t.id)return n.push(i),!0})}),c(makeError(\"scripterror\",'Script error for \"'+t.id+(n.length?'\", needed by: '+n.join(\", \"):'\"'),e,[t.id]))}}},b.require=b.makeRequire(),b}function getInteractiveScript(){return interactiveScript&&\"interactive\"===interactiveScript.readyState?interactiveScript:(eachReverse(scripts(),function(e){if(\"interactive\"===e.readyState)return interactiveScript=e}),interactiveScript)}var req,s,head,baseElement,dataMain,src,interactiveScript,currentlyAddingScript,mainScript,subPath,version=\"2.3.5\",commentRegExp=/\\/\\*[\\s\\S]*?\\*\\/|([^:\"'=]|^)\\/\\/.*$/gm,cjsRequireRegExp=/[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g,jsSuffixRegExp=/\\.js$/,currDirRegExp=/^\\.\\//,op=Object.prototype,ostring=op.toString,hasOwn=op.hasOwnProperty,isBrowser=!(\"undefined\"==typeof window||\"undefined\"==typeof navigator||!window.document),isWebWorker=!isBrowser&&\"undefined\"!=typeof importScripts,readyRegExp=isBrowser&&\"PLAYSTATION 3\"===navigator.platform?/^complete$/:/^(complete|loaded)$/,defContextName=\"_\",isOpera=\"undefined\"!=typeof opera&&\"[object Opera]\"===opera.toString(),contexts={},cfg={},globalDefQueue=[],useInteractive=!1;if(void 0===define){if(\"undefined\"!=typeof requirejs){if(isFunction(requirejs))return;cfg=requirejs,requirejs=void 0}void 0===require||isFunction(require)||(cfg=require,require=void 0),req=requirejs=function(e,t,n,i){var r,s,o=defContextName;return isArray(e)||\"string\"==typeof e||(s=e,isArray(t)?(e=t,t=n,n=i):e=[]),s&&s.context&&(o=s.context),r=getOwn(contexts,o),r||(r=contexts[o]=req.s.newContext(o)),s&&r.configure(s),r.require(e,t,n)},req.config=function(e){return req(e)},req.nextTick=void 0!==setTimeout?function(e){setTimeout(e,4)}:function(e){e()},requireJSRequire||(requireJSRequire=req),req.version=version,req.jsExtRegExp=/^\\/|:|\\?|\\.js$/,req.isBrowser=isBrowser,s=req.s={contexts:contexts,newContext:newContext},req({}),each([\"toUrl\",\"undef\",\"defined\",\"specified\"],function(e){req[e]=function(){var t=contexts[defContextName];return t.require[e].apply(t,arguments)}}),isBrowser&&(head=s.head=document.getElementsByTagName(\"head\")[0],(baseElement=document.getElementsByTagName(\"base\")[0])&&(head=s.head=baseElement.parentNode)),req.onError=defaultOnError,req.createNode=function(e,t,n){var i=e.xhtml?document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"html:script\"):document.createElement(\"script\");return i.type=e.scriptType||\"text/javascript\",i.charset=\"utf-8\",i.async=!0,i},req.load=function(e,t,n){var i,r=e&&e.config||{};if(isBrowser)return i=req.createNode(r,t,n),i.setAttribute(\"data-requirecontext\",e.contextName),i.setAttribute(\"data-requiremodule\",t),!i.attachEvent||i.attachEvent.toString&&i.attachEvent.toString().indexOf(\"[native code\")<0||isOpera?(i.addEventListener(\"load\",e.onScriptLoad,!1),i.addEventListener(\"error\",e.onScriptError,!1)):(useInteractive=!0,i.attachEvent(\"onreadystatechange\",e.onScriptLoad)),i.src=n,r.onNodeCreated&&r.onNodeCreated(i,r,t,n),currentlyAddingScript=i,currentlyAddingScript=null,e.onScriptLoad({type:\"load\"}),i;if(isWebWorker)try{setTimeout(function(){},0),importScripts(n),e.completeLoad(t)}catch(i){e.onError(makeError(\"importscripts\",\"importScripts failed for \"+t+\" at \"+n,i,[t]))}},isBrowser&&!cfg.skipDataMain&&eachReverse(scripts(),function(e){if(head||(head=e.parentNode),dataMain=e.getAttribute(\"data-main\"))return mainScript=dataMain,cfg.baseUrl||-1!==mainScript.indexOf(\"!\")||(src=mainScript.split(\"/\"),mainScript=src.pop(),subPath=src.length?src.join(\"/\")+\"/\":\"./\",cfg.baseUrl=subPath),mainScript=mainScript.replace(jsSuffixRegExp,\"\"),req.jsExtRegExp.test(mainScript)&&(mainScript=dataMain),cfg.deps=cfg.deps?cfg.deps.concat(mainScript):[mainScript],!0}),define=function(e,t,n){var i,r;\"string\"!=typeof e&&(n=t,t=e,e=null),isArray(t)||(n=t,t=null),!t&&isFunction(n)&&(t=[],n.length&&(n.toString().replace(commentRegExp,commentReplace).replace(cjsRequireRegExp,function(e,n){t.push(n)}),t=(1===n.length?[\"require\"]:[\"require\",\"exports\",\"module\"]).concat(t))),useInteractive&&(i=currentlyAddingScript||getInteractiveScript())&&(e||(e=i.getAttribute(\"data-requiremodule\")),r=contexts[i.getAttribute(\"data-requirecontext\")]),r?(r.defQueue.push([e,t,n]),r.defQueueMap[e]=!0):globalDefQueue.push([e,t,n])},define.amd={jQuery:!0},req.exec=function(text){return eval(text)},req(cfg)}}(this,\"undefined\"==typeof setTimeout?void 0:setTimeout);\n\n  function OMG_KCsVcjjednlGSjCajzecXtVY () {\n    var self = this;\n\n    !function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/style.css\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.styleCss=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=\"html, body {\\n  width: 100%;\\n  height: 100%;\\n  margin: 0px;\\n  padding: 0px;\\n}\\nhtml, body, #app {\\n  box-sizing: border-box;\\n  width: 100%;\\n  height: 100%;\\n  overflow: hidden;\\n}\\n.full{\\n  width: 100%;\\n  height: 100%;\\n}\",n=document.head||document.getElementsByTagName(\"head\")[0],i=document.createElement(\"style\");i.type=\"text/css\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i),e.default=\"html, body {\\n  width: 100%;\\n  height: 100%;\\n  margin: 0px;\\n  padding: 0px;\\n}\\nhtml, body, #app {\\n  box-sizing: border-box;\\n  width: 100%;\\n  height: 100%;\\n  overflow: hidden;\\n}\\n.full{\\n  width: 100%;\\n  height: 100%;\\n}\"}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/main.js\",[\"exports\",\"@/app.vue\",\"@/router.js\",\"@/style.css\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/app.vue\"),require(\"@/router.js\"),require(\"@/style.css\"));else{var n={exports:{}};t(n.exports,e.appVue,e.routerJs,e.styleCss),e.mainJs=n.exports}}(this,function(e,t,n){\"use strict\";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\"__esModule\",{value:!0});var r=i(t),s=i(n),o=document.querySelector(\"#app-attach-point\"),a=document.createElement(\"div\"),u=o||a;o||(a.id=\"#app-attach-point\",document.body.appendChild(a));var d=new Vue({router:s.default,el:u,components:{App:r.default},template:'<div id=\"app\"><App /></div>'});window.addEventListener(\"main-system-ready\",function(e){var t=e.detail;console.log(\"App Got Custom Event:\",t)},!1),e.default=d}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/router.js\",[\"exports\",\"@/webgl/layout/Player.vue\",\"@/webgl/pages/Home.vue\",\"@/webgl/pages/Happy.vue\",\"@/webgl/pages/Sample.vue\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/webgl/layout/Player.vue\"),require(\"@/webgl/pages/Home.vue\"),require(\"@/webgl/pages/Happy.vue\"),require(\"@/webgl/pages/Sample.vue\"));else{var n={exports:{}};t(n.exports,e.webglLayoutPlayerVue,e.webglPagesHomeVue,e.webglPagesHappyVue,e.webglPagesSampleVue),e.routerJs=n.exports}}(this,function(e,t,n,i,r){\"use strict\";function s(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\"__esModule\",{value:!0});var o=s(t),a=s(n),u=s(i),d=s(r),c=new VueRouter({mode:\"hash\",routes:[{path:\"/\",component:d.default},{path:\"/sub\",component:o.default,children:[{path:\"\",component:a.default},{path:\"happy\",component:u.default}]}]});e.default=c}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/app.vue\",[\"exports\",\"@/three.js\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/three.js\"));else{var n={exports:{}};t(n.exports,e.threeJs),e.appVue=n.exports}}(this,function(e,t){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\"__esModule\",{value:!0});var i=(n(t),\"\\n\\n\"),r=document.head||document.getElementsByTagName(\"head\")[0],s=document.createElement(\"style\");s.type=\"text/css\",s.styleSheet?s.styleSheet.cssText=i:s.appendChild(document.createTextNode(i)),r.appendChild(s),e.default={template:\"\\n  <divdata-s-hih>\\n    <router-view></router-view>\\n  </div>\\n\",data:function(){return{}},created:function(){},beforeDestroy:function(){},methods:{}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/pages/Sample.vue\",[\"exports\",\"@/webgl/Bundle.js\",\"@/shader/Fling/vs.vert\",\"@/shader/Simple/fs.frag\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/webgl/Bundle.js\"),require(\"@/shader/Fling/vs.vert\"),require(\"@/shader/Simple/fs.frag\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs,e.shaderFlingVsVert,e.shaderSimpleFsFrag),e.webglPagesSampleVue=n.exports}}(this,function(e,t,n,i){\"use strict\";function r(e){return e&&e.__esModule?e:{default:e}}function s(e,t){return null!=t&&\"undefined\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function o(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\" \"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\"\"))});var a=o.join(\",\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(s(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\"load\",function t(){e.removeEventListener(\"load\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\"__esModule\",{value:!0});var a=r(t),u=r(n),d=r(i),c=\"\\n.pos-rel{\\n  position: relative;\\n}\\n.full{\\n  width: 100%;\\n  height: 100%;\\n}\\n.renderer{\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n}\\n.touch-surface{\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  z-index: 100;\\n}\\n\",l=document.head||document.getElementsByTagName(\"head\")[0],p=document.createElement(\"style\");p.type=\"text/css\",p.styleSheet?p.styleSheet.cssText=c:p.appendChild(document.createTextNode(c)),l.appendChild(p),o(p,\"[data-s-1i2e]\"),e.default={template:'\\n  <div class=\"full\"data-s-1i2e>\\n\\n    <Renderer\\n      class=\"pos-rel full\"\\n      ref=\"renderer\"\\n      :size=\"size\"\\n      @renderer=\"(v) => { renderer = v }\"\\n    >\\n      \\n    </Renderer>\\n    \\n    \\x3c!-- <div class=\"full touch-surface\" @click=\"wonder\">\\n      12345\\n    </div> --\\x3e\\n    \\n    <div class=\"layout\">\\n      \\n    </div>\\n\\n    <PerspectiveCamera\\n      :fov=\"75\"\\n      :aspect=\"size.aspect\"\\n      :near=\"1\"\\n      :far=\"1000\"\\n      :position=\"{ x: 0, y: 0, z: 10 }\"\\n      \\n      @camera=\"(v) => { camera = v; }\"\\n    />\\n\\n    <Scene @scene=\"(v) => { scene = v }\">\\n      <Object3D pz=\"10\">\\n        <PointLight />\\n      </Object3D>\\n      \\n      <Object3D pz=\"0\">\\n        <Points>\\n          <SphereBufferGeometry />\\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\\n        </Points>\\n      </Object3D>\\n      \\n    </Scene>\\n\\n  </div>\\n',components:Object.assign({},a.default),computed:{},methods:{renderWebGL:function(){this.animatable.time.value=.001*window.performance.now(),this.scene&&this.camera&&this.renderer&&this.renderer.render(this.scene,this.camera)},wonder:function(){window.alert(\"click\")}},data:function(){return{animatable:{time:{value:0}},simple:{vs:u.default,fs:d.default},size:{width:window.innerWidth,height:window.innerHeight,aspect:window.innerWidth/window.innerHeight},renderer:!1,scene:!1,camera:!1}},created:function(){},mounted:function(){function e(){t.rAFID=window.requestAnimationFrame(e),t.renderWebGL()}var t=this;t.rAFID=window.requestAnimationFrame(e)}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/layout/Player.vue\",[\"exports\",\"@/webgl/Bundle.js\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/webgl/Bundle.js\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs),e.webglLayoutPlayerVue=n.exports}}(this,function(e,t){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){return null!=t&&\"undefined\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function r(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\" \"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\"\"))});var a=o.join(\",\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(i(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\"load\",function t(){e.removeEventListener(\"load\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\"__esModule\",{value:!0});var s=n(t),o=\"\\n.hidden{\\n  display: none;\\n}\\n.full{\\n  width: 100%;\\n  height: 100%;\\n}\\n\",a=document.head||document.getElementsByTagName(\"head\")[0],u=document.createElement(\"style\");u.type=\"text/css\",u.styleSheet?u.styleSheet.cssText=o:u.appendChild(document.createTextNode(o)),a.appendChild(u),r(u,\"[data-s-1qs0]\"),e.default={template:'\\n  <div class=\"full\" ref=\"full\"data-s-1qs0>\\n\\n    <Renderer\\n      :alpha=\"true\"\\n      ref=\"renderer\"\\n      :size=\"size\"\\n      @renderer=\"(v) => { renderer = v }\"\\n      @toucher=\"(v) => { toucher = v }\"\\n    >\\n    </Renderer>\\n    \\n    <keep-alive>\\n      <component\\n        class=\"hidden\"\\n        :is=\"\\'router-view\\'\"\\n        v-if=\"renderer\"\\n        :size=\"size\"\\n        :toucher=\"toucher\"\\n        :renderer=\"renderer\"\\n      >\\n      </component>\\n    </keep-alive>\\n\\n  </div>\\n',components:Object.assign({},s.default),computed:{},methods:{},data:function(){return{toucher:!1,resizer:function(){},renderer:!1,size:{width:100,height:100,aspect:1}}},created:function(){},mounted:function(){var e=this,t=this.resizer=function(){e.$nextTick(function(){var t=e.$refs.full.getBoundingClientRect();e.size={width:t.width,height:t.height,aspect:t.width/t.height}})};window.addEventListener(\"resize\",t.bind(this)),t()}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/pages/Home.vue\",[\"exports\",\"@/webgl/Bundle.js\",\"@/shader/Simple/vs.vert\",\"@/shader/Simple/fs.frag\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/webgl/Bundle.js\"),require(\"@/shader/Simple/vs.vert\"),require(\"@/shader/Simple/fs.frag\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs,e.shaderSimpleVsVert,e.shaderSimpleFsFrag),e.webglPagesHomeVue=n.exports}}(this,function(e,t,n,i){\"use strict\";function r(e){return e&&e.__esModule?e:{default:e}}function s(e,t){return null!=t&&\"undefined\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function o(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\" \"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\"\"))});var a=o.join(\",\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(s(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\"load\",function t(){e.removeEventListener(\"load\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\"__esModule\",{value:!0});var a=r(t),u=r(n),d=r(i),c=\"\\n.full{\\n  width: 100%;\\n  height: 100%;\\n}\\n\",l=document.head||document.getElementsByTagName(\"head\")[0],p=document.createElement(\"style\");p.type=\"text/css\",p.styleSheet?p.styleSheet.cssText=c:p.appendChild(document.createTextNode(c)),l.appendChild(p),o(p,\"[data-s-4j6]\"),e.default={template:'\\n  <div class=\"\"data-s-4j6>\\n    <PerspectiveCamera\\n      :fov=\"75\"\\n      :aspect=\"size.aspect\"\\n      :near=\"1\"\\n      :far=\"1000\"\\n      :position=\"{ x: 0, y: 0, z: 15 }\"\\n      @camera=\"(v) => { camera = v; }\"\\n    />\\n    \\n    <Scene @scene=\"(v) => { scene = v; }\">\\n      <Object3D pz=\"10\">\\n        <PointLight />\\n      </Object3D>\\n      \\n      <Object3D pz=\"0\">\\n        <Mesh>\\n          <SphereBufferGeometry />\\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\\n        </Mesh>\\n      </Object3D>\\n    </Scene>\\n    \\n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\\n    </Raycaster>\\n    \\n  </div>\\n',name:\"Home\",props:{toucher:{},size:{},renderer:{},doc:{}},components:Object.assign({},a.default),computed:{},data:function(){return{cam:{pos:{x:3,y:5,z:10}},ready:!1,cubeCamera:!1,visible:!0,resizer:function(){},scene:!1,camera:!1,found:[],animatable:{time:{value:0}},simpleVS:u.default,simpleFS:d.default}},methods:{onClick:function(e){e.event,e.intersects;this.$router.push({path:\"/happy\"}),this.$forceUpdate(),console.log(\"Click to happy\")},setup:function(){},renderWebGL:function(){TWEEN.update(),this.animatable.time.value+=.01,this.scene&&this.camera&&this.renderer&&this.renderer.render(this.scene,this.camera)}},watch:{camera:function(){this.camera&&this.renderer&&(this.ready=!0)},renderer:function(){this.camera&&this.renderer&&(this.ready=!0)},ready:function(){this.ready&&this.setup()}},created:function(){},activated:function(){function e(n){t.rAFID=window.requestAnimationFrame(e),t.renderWebGL(n)}var t=this;t.rAFID=window.requestAnimationFrame(e)},deactivated:function(){window.cancelAnimationFrame(this.rAFID)}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/pages/Happy.vue\",[\"exports\",\"@/webgl/Bundle.js\",\"@/shader/Fling/vs.vert\",\"@/shader/Simple/vs.vert\",\"@/shader/Simple/fs.frag\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/webgl/Bundle.js\"),require(\"@/shader/Fling/vs.vert\"),require(\"@/shader/Simple/vs.vert\"),require(\"@/shader/Simple/fs.frag\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs,e.shaderFlingVsVert,e.shaderSimpleVsVert,e.shaderSimpleFsFrag),e.webglPagesHappyVue=n.exports}}(this,function(e,t,n,i,r){\"use strict\";function s(e){return e&&e.__esModule?e:{default:e}}function o(e,t){return null!=t&&\"undefined\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function a(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\" \"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\"\"))});var a=o.join(\",\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(o(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\"load\",function t(){e.removeEventListener(\"load\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\"__esModule\",{value:!0});var u=s(t),d=s(n),c=s(i),l=s(r),p=\"\\n.full{\\n  width: 100%;\\n  height: 100%;\\n}\\n\",f=document.head||document.getElementsByTagName(\"head\")[0],h=document.createElement(\"style\");h.type=\"text/css\",h.styleSheet?h.styleSheet.cssText=p:h.appendChild(document.createTextNode(p)),f.appendChild(h),a(h,\"[data-s-lc4]\"),e.default={template:'\\n  <div class=\"\"data-s-lc4>\\n\\n    <PerspectiveCamera\\n      :fov=\"75\"\\n      :aspect=\"size.aspect\"\\n      :near=\"1\"\\n      :far=\"1000\"\\n      :position=\"{ x: 0, y: 0, z: 10 }\"\\n      @camera=\"(v) => { camera = v; }\"\\n    />\\n    \\n    <Scene @scene=\"(v) => { scene = v }\">\\n      <Object3D pz=\"10\">\\n        <PointLight />\\n      </Object3D>\\n      \\n      <Object3D pz=\"0\">\\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\\n          <SphereBufferGeometry />\\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\\n        </Points>\\n      </Object3D>\\n      \\n      <Object3D pz=\"1\">\\n        <Mesh>\\n          <SphereBufferGeometry />\\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\\n        </Mesh>\\n      </Object3D>\\n    </Scene>\\n    \\n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\\n    </Raycaster>\\n\\n  </div>\\n',name:\"Happy\",props:{toucher:{},size:{},renderer:{},doc:{}},components:Object.assign({},u.default),computed:{},data:function(){return{cam:{pos:{x:3,y:5,z:10}},ready:!1,cubeCamera:!1,visible:!0,resizer:function(){},scene:!1,camera:!1,found:[],animatable:{time:{value:0}},simpleVS:c.default,simpleFS:l.default,simpleVS2:d.default}},methods:{onClick:function(e){var t=e.event,n=e.intersects;console.log(t,n),this.$router.push(\"/\")},setup:function(){},renderWebGL:function(){TWEEN.update(),this.animatable.time.value+=.01,this.scene&&this.camera&&this.renderer&&this.renderer.render(this.scene,this.camera)}},watch:{camera:function(){this.camera&&this.renderer&&(this.ready=!0)},renderer:function(){this.camera&&this.renderer&&(this.ready=!0)},ready:function(){this.ready&&this.setup()}},created:function(){},activated:function(){function e(n){t.rAFID=window.requestAnimationFrame(e),t.renderWebGL(n)}var t=this;t.rAFID=window.requestAnimationFrame(e)},deactivated:function(){window.cancelAnimationFrame(this.rAFID),console.log(\"cancel animation frame\")}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/sample.vue\",[\"exports\",\"@/webgl/Bundle.js\",\"@/shader/Simple/vs.vert\",\"@/shader/Simple/fs.frag\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/webgl/Bundle.js\"),require(\"@/shader/Simple/vs.vert\"),require(\"@/shader/Simple/fs.frag\"));else{var n={exports:{}};t(n.exports,e.webglBundleJs,e.shaderSimpleVsVert,e.shaderSimpleFsFrag),e.webglSampleVue=n.exports}}(this,function(e,t,n,i){\"use strict\";function r(e){return e&&e.__esModule?e:{default:e}}function s(e,t){return null!=t&&\"undefined\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function o(e,t){function n(){for(var n=e.sheet,i=n.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(t+\" \"+e);var n=e.match(/([^ :]+)(.+)?/);o.push(n[1]+t+(n[2]||\"\"))});var a=o.join(\",\")+s.cssText.substr(s.selectorText.length);n.deleteRule(r),n.insertRule(a,r)}}}try{n()}catch(t){if(s(t,DOMException)&&t.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\"load\",function t(){e.removeEventListener(\"load\",t),setTimeout(function(){n(),e.sheet.disabled=!1})});throw t}}Object.defineProperty(e,\"__esModule\",{value:!0});var a=r(t),u=r(n),d=r(i),c=\"\\n.full{\\n  width: 100%;\\n  height: 100%;\\n}\\n.touch-surface{\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n}\\n\",l=document.head||document.getElementsByTagName(\"head\")[0],p=document.createElement(\"style\");p.type=\"text/css\",p.styleSheet?p.styleSheet.cssText=c:p.appendChild(document.createTextNode(c)),l.appendChild(p),o(p,\"[data-s-622]\"),e.default={template:'\\n  <div class=\"full\"data-s-622>\\n\\n    <Renderer\\n      ref=\"renderer\"\\n      :size=\"size\"\\n      @renderer=\"(v) => { renderer = v }\"\\n    >\\n    </Renderer>\\n    \\n    <div class=\"full touch-surface\"></div>\\n\\n    <PerspectiveCamera\\n      :fov=\"75\"\\n      :aspect=\"size.aspect\"\\n      :near=\"1\"\\n      :far=\"1000\"\\n      :position=\"{ x: 0, y: 0, z: 10 }\"\\n      @camera=\"(v) => { camera = v; }\"\\n    />\\n\\n    <Scene @scene=\"(v) => { scene = v }\">\\n      <Object3D pz=\"10\">\\n        <PointLight />\\n      </Object3D>\\n      \\n      <Object3D pz=\"0\">\\n        <Points>\\n          <SphereBufferGeometry />\\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\\n        </Points>\\n      </Object3D>\\n      \\n    </Scene>\\n\\n  </div>\\n',components:Object.assign({},a.default),computed:{},methods:{renderWebGL:function(){this.animatable.time.value=.001*window.performance.now(),this.scene&&this.camera&&this.renderer&&this.renderer.render(this.scene,this.camera)}},data:function(){return{animatable:{time:{value:0}},simpleVS:u.default,simpleFS:d.default,size:{width:window.innerWidth,height:window.innerHeight,aspect:window.innerWidth/window.innerHeight},renderer:!1,scene:!1,camera:!1}},created:function(){},mounted:function(){function e(){t.rAFID=window.requestAnimationFrame(e),t.renderWebGL()}var t=this;t.rAFID=window.requestAnimationFrame(e)}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/Bundle.js\",[\"exports\",\"@/webgl/System/Renderer.vue\",\"@/webgl/System/Scene.vue\",\"@/webgl/System/PerspectiveCamera.vue\",\"@/webgl/System/Raycaster.vue\",\"@/webgl/Material/MeshPhongMaterial.vue\",\"@/webgl/Material/ShaderMaterial.vue\",\"@/webgl/Element/Object3D.vue\",\"@/webgl/Element/Mesh.vue\",\"@/webgl/Element/Points.vue\",\"@/webgl/Element/PointLight.vue\",\"@/webgl/Geo/SphereBufferGeometry.vue\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/webgl/System/Renderer.vue\"),require(\"@/webgl/System/Scene.vue\"),require(\"@/webgl/System/PerspectiveCamera.vue\"),require(\"@/webgl/System/Raycaster.vue\"),require(\"@/webgl/Material/MeshPhongMaterial.vue\"),require(\"@/webgl/Material/ShaderMaterial.vue\"),require(\"@/webgl/Element/Object3D.vue\"),require(\"@/webgl/Element/Mesh.vue\"),require(\"@/webgl/Element/Points.vue\"),require(\"@/webgl/Element/PointLight.vue\"),require(\"@/webgl/Geo/SphereBufferGeometry.vue\"));else{var n={exports:{}};t(n.exports,e.webglSystemRendererVue,e.webglSystemSceneVue,e.webglSystemPerspectiveCameraVue,e.webglSystemRaycasterVue,e.webglMaterialMeshPhongMaterialVue,e.webglMaterialShaderMaterialVue,e.webglElementObject3DVue,e.webglElementMeshVue,e.webglElementPointsVue,e.webglElementPointLightVue,e.webglGeoSphereBufferGeometryVue),e.webglBundleJs=n.exports}}(this,function(e,t,n,i,r,s,o,a,u,d,c,l){\"use strict\";function p(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\"__esModule\",{value:!0});var f=p(t),h=p(n),m=p(i),v=p(r),g=p(s),x=p(o),y=p(a),b=p(u),w=p(d),S=p(c),E=p(l);e.default={MeshPhongMaterial:g.default,ShaderMaterial:x.default,Renderer:f.default,Scene:h.default,PerspectiveCamera:m.default,Raycaster:v.default,PointLight:S.default,Points:w.default,Object3D:y.default,Mesh:b.default,SphereBufferGeometry:E.default}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/System/Renderer.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglSystemRendererVue=n.exports}}(this,function(e){\"use strict\";function t(e,t){return null!=t&&\"undefined\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function n(e,n){function i(){for(var t=e.sheet,i=t.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(n+\" \"+e);var t=e.match(/([^ :]+)(.+)?/);o.push(t[1]+n+(t[2]||\"\"))});var a=o.join(\",\")+s.cssText.substr(s.selectorText.length);t.deleteRule(r),t.insertRule(a,r)}}}try{i()}catch(n){if(t(n,DOMException)&&n.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\"load\",function t(){e.removeEventListener(\"load\",t),setTimeout(function(){i(),e.sheet.disabled=!1})});throw n}}Object.defineProperty(e,\"__esModule\",{value:!0});var i=\"\\n.full{\\n  width: 100%;\\n  height: 100%;\\n}\\n.pos-rel{\\n  position: relative;\\n}\\n.layer{\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\\n}\\n\\n\",r=document.head||document.getElementsByTagName(\"head\")[0],s=document.createElement(\"style\");s.type=\"text/css\",s.styleSheet?s.styleSheet.cssText=i:s.appendChild(document.createTextNode(i)),r.appendChild(s),n(s,\"[data-s-naf]\");var o=window.THREE;e.default={template:'\\n  <div class=\"full pos-rel\"data-s-naf>\\n    <div class=\"full layer\" ref=\"mounter\"></div>\\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\\n  </div>\\n',data:function(){return{renderer:!1}},props:{size:{default:function(){return{width:500,height:500}}},alpha:{default:!0},antialias:{default:!0}},mounted:function(){this.renderer=new o.WebGLRenderer({alpha:this.alpha,antialias:this.antialias}),this.resize(),this.renderer.domElement.style.marginBottom=\"-6px\",this.renderer.domElement.addEventListener(\"touchstart\",function(){},!0),this.$refs.mounter.appendChild(this.renderer.domElement),this.$emit(\"toucher\",this.$refs.toucher),this.$emit(\"renderer\",this.renderer)},beforeDestroy:function(){this.$refs.mounter.removeChild(this.renderer.domElement)},watch:{size:function(){this.resize()}},methods:{resize:function(){var e=window.devicePixelRatio||1;this.renderer.setPixelRatio(e),this.renderer.setSize(this.size.width,this.size.height)}}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/System/Scene.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglSystemSceneVue=n.exports}}(this,function(e){\"use strict\";function t(e,t){return null!=t&&\"undefined\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function n(e,n){function i(){for(var t=e.sheet,i=t.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(n+\" \"+e);var t=e.match(/([^ :]+)(.+)?/);o.push(t[1]+n+(t[2]||\"\"))});var a=o.join(\",\")+s.cssText.substr(s.selectorText.length);t.deleteRule(r),t.insertRule(a,r)}}}try{i()}catch(n){if(t(n,DOMException)&&n.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\"load\",function t(){e.removeEventListener(\"load\",t),setTimeout(function(){i(),e.sheet.disabled=!1})});throw n}}Object.defineProperty(e,\"__esModule\",{value:!0});var i=\"\\n.mounter {\\n  display: none;\\n}\\n\",r=document.head||document.getElementsByTagName(\"head\")[0],s=document.createElement(\"style\");s.type=\"text/css\",s.styleSheet?s.styleSheet.cssText=i:s.appendChild(document.createTextNode(i)),r.appendChild(s),n(s,\"[data-s-avi]\");var o=window.THREE;e.default={template:'\\n  <div ref=\"mounter\" class=\"mounter\"data-s-avi><slot></slot></div>\\n',data:function(){return{scene:!1}},props:{size:{default:function(){return{width:500,height:500}}},alpha:{default:!0},antialias:{default:!0}},created:function(){var e=this;this.scene=new o.Scene,this.$on(\"add\",function(t){e.scene.add(t)}),this.$on(\"remove\",function(t){e.scene.remove(t)})},mounted:function(){this.$emit(\"scene\",this.scene)}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/System/PerspectiveCamera.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglSystemPerspectiveCameraVue=n.exports}}(this,function(e){\"use strict\";function t(e,t){return null!=t&&\"undefined\"!=typeof Symbol&&t[Symbol.hasInstance]?t[Symbol.hasInstance](e):e instanceof t}function n(e,n){function i(){for(var t=e.sheet,i=t.cssRules,r=0;r<i.length;++r){var s=i[r];if(1===s.type){var o=[];s.selectorText.split(/s*,s*/).forEach(function(e){o.push(n+\" \"+e);var t=e.match(/([^ :]+)(.+)?/);o.push(t[1]+n+(t[2]||\"\"))});var a=o.join(\",\")+s.cssText.substr(s.selectorText.length);t.deleteRule(r),t.insertRule(a,r)}}}try{i()}catch(n){if(t(n,DOMException)&&n.code===DOMException.INVALID_ACCESS_ERR)return e.sheet.disabled=!0,void e.addEventListener(\"load\",function t(){e.removeEventListener(\"load\",t),setTimeout(function(){i(),e.sheet.disabled=!1})});throw n}}Object.defineProperty(e,\"__esModule\",{value:!0});var i=\"\\n.perspective-camera{\\n  display: none;\\n}\\n\",r=document.head||document.getElementsByTagName(\"head\")[0],s=document.createElement(\"style\");s.type=\"text/css\",s.styleSheet?s.styleSheet.cssText=i:s.appendChild(document.createTextNode(i)),r.appendChild(s),n(s,\"[data-s-j3g]\");var o=window.THREE;e.default={template:\"\",abstract:!0,render:function(){return null},props:[\"fov\",\"aspect\",\"near\",\"far\",\"position\"],data:function(){return{camera:null}},created:function(){this.camera=new o.PerspectiveCamera(this.fov,this.aspect,this.near,this.far),this.position&&(this.camera.position.x=this.position.x,this.camera.position.y=this.position.y,this.camera.position.z=this.position.z),this.$emit(\"camera\",this.camera)},watch:{position:function(){this.position&&(this.camera.position.x=this.position.x,this.camera.position.y=this.position.y,this.camera.position.z=this.position.z)},aspect:function(){this.camera&&(this.camera.aspect=this.aspect,this.camera.updateProjectionMatrix())}}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/System/Raycaster.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglSystemRaycasterVue=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=\"\\n\\n\",n=document.head||document.getElementsByTagName(\"head\")[0],i=document.createElement(\"style\");i.type=\"text/css\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i),e.default={template:\"\\n<divdata-s-exk></div>\\n\",data:function(){return{rAFID:0,mouse:null,raycast:function(){},clean:function(){},intersects:[]}},props:{scene:{},camera:{},toucher:{}},created:function(){},activated:function(){var e=this,t=new THREE.Raycaster;this.mouse=new THREE.Vector2,this.toucher.addEventListener(\"mousemove\",this.handleMV,!1),this.toucher.addEventListener(\"click\",this.handleClick,!1),this.clean=function(){e.toucher.removeEventListener(\"click\",e.handleClick,!1),e.toucher.removeEventListener(\"mousemove\",e.handleMV)};var n=function(){var n=e.mouse,i=e.scene,r=e.camera,s=[];e.scene.traverse(function(e){e.$skipRayCast&&(s.push({parent:e.parent,ele:e}),e.parent.remove(e))}),t.setFromCamera(n,r);var o=t.intersectObjects(i.children,!0);return s.forEach(function(e){e.parent.add(e.ele)}),o};this.raycast=n;var i=function t(){e.rAFID=window.requestAnimationFrame(t)};this.rAFID=window.requestAnimationFrame(i)},deactivated:function(){window.cancelAnimationFrame(this.rAFID),this.clean()},methods:{handleClick:function(e){this.$emit(\"click\",{event:e,intersects:this.raycast()})},handleMV:function(e){this.mouse.x=e.clientX/window.innerWidth*2-1,this.mouse.y=-e.clientY/window.innerHeight*2+1}}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/Material/MeshPhongMaterial.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglMaterialMeshPhongMaterialVue=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=\"\\n\\n\",n=document.head||document.getElementsByTagName(\"head\")[0],i=document.createElement(\"style\");i.type=\"text/css\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\n<div class=\"mesh-phong-material\"data-s-17bg></div>\\n',props:{color:{default:function(){return 16777215*Math.random()}}},data:function(){return{material:!1}},created:function(){this.material=new r.MeshPhongMaterial({color:new r.Color(this.color),specular:new r.Color(1118481),shininess:50}),this.$parent.$emit(\"material\",this.material)}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/Material/ShaderMaterial.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglMaterialShaderMaterialVue=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=\"\\n\\n\",n=document.head||document.getElementsByTagName(\"head\")[0],i=document.createElement(\"style\");i.type=\"text/css\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\n<div class=\"mesh-basic-material\"data-s-zxp></div>\\n',data:function(){return{material:!1}},props:{vs:{default:\"void main ( void ) {\\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n  vec4 outputPos = projectionMatrix * mvPosition;\\n  gl_Position = outputPos;\\n}\"},fs:{default:\"void main () {\\n  gl_FragColor = vec4(vec3(0.5), 1.0);\\n}\"},uniforms:{default:function(){return{}}}},watch:{vs:function(){this.initShader()},fs:function(){this.initShader()},uniforms:function(){this.initShader()}},mounted:function(){this.initShader()},methods:{initShader:function(){try{this.material=new r.ShaderMaterial({uniforms:Object.assign({},this.uniforms),vertexShader:this.vs||this.$options.props.vs.default,fragmentShader:this.fs||this.$options.props.fs.default}),this.$parent.$emit(\"material\",this.material)}catch(e){console.log(e)}}}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/Element/PointLight.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglElementPointLightVue=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=\"\\n\\n\",n=document.head||document.getElementsByTagName(\"head\")[0],i=document.createElement(\"style\");i.type=\"text/css\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\n  <div class=\"light-point\"data-s-3k3></div>\\n',props:{color:{default:function(){return 16777215}}},data:function(){return{light:!1}},mounted:function(){this.light=new r.PointLight({color:new r.Color(this.color)}),this.$emit(\"element\",this.light),this.$parent.$emit(\"add\",this.light)},beforeDestroy:function(){this.$parent.$emit(\"remove\",this.light)}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/Element/Object3D.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglElementObject3DVue=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=\"\\n\\n\",n=document.head||document.getElementsByTagName(\"head\")[0],i=document.createElement(\"style\");i.type=\"text/css\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\n<div class=\"object-3d\"data-s-fcu><slot></slot></div>\\n',data:function(){return{object3d:!1}},props:{visible:{default:!0},px:{default:0},py:{default:0},pz:{default:0},sx:{default:1},sy:{default:1},sz:{default:1},rx:{default:0},ry:{default:0},rz:{default:0}},watch:{visible:function(){this.object3d.setVisible(this.visible)},px:function(){this.updatePosition(\"x\",this.px)},py:function(){this.updatePosition(\"y\",this.py)},pz:function(){this.updatePosition(\"z\",this.pz)},sx:function(){this.updateScale(\"x\",this.sx)},sy:function(){this.updateScale(\"y\",this.sy)},sz:function(){this.updateScale(\"z\",this.sz)},rx:function(){this.updateRotation(\"x\",this.rx)},ry:function(){this.updateRotation(\"y\",this.ry)},rz:function(){this.updateRotation(\"z\",this.rz)}},created:function(){var e=this;this.object3d=new r.Object3D,this.$emit(\"element\",this.object3d),this.object3d.visible=!0,this.updatePosition(),this.updateScale(),this.updateRotation(),this.$on(\"add\",function(t){e.object3d.add(t)}),this.$on(\"remove\",function(t){e.object3d.remove(t)})},mounted:function(){this.$parent.$emit(\"add\",this.object3d)},beforeDestroy:function(){this.$parent.$emit(\"remove\",this.object3d)},methods:{updatePosition:function(e,t){e?this.object3d.position[e]=t:this.object3d.position.set(this.px,this.py,this.pz)},updateScale:function(e,t){e?this.object3d.scale[e]=t:this.object3d.scale.set(this.sx,this.sy,this.sz)},updateRotation:function(e,t){e?this.object3d.rotation[e]=t:this.object3d.rotation.set(this.rx,this.ry,this.rz)}}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/Element/Points.vue\",[\"exports\",\"@/three.js\"],t);else if(\"undefined\"!=typeof exports)t(exports,require(\"@/three.js\"));else{var n={exports:{}};t(n.exports,e.threeJs),e.webglElementPointsVue=n.exports}}(this,function(e,t){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(e,\"__esModule\",{value:!0});var i=n(t),r=\"\\n\\n\",s=document.head||document.getElementsByTagName(\"head\")[0],o=document.createElement(\"style\");o.type=\"text/css\",o.styleSheet?o.styleSheet.cssText=r:o.appendChild(document.createTextNode(r)),s.appendChild(o),e.default={template:'\\n  <div class=\"points\"data-s-24l1>\\n    <slot>\\n    </slot>\\n  </div>\\n',props:{position:{}},data:function(){return{element:!1,points:!1,material:!1,geometry:!1}},created:function(){var e=this;this.element=this.points=new i.default.Points,this.$parent.$emit(\"add\",this.points),this.$emit(\"element\",this.points),this.$on(\"material\",function(t){e.material=t,e.tryUpdateMaterial()}),this.$on(\"geometry\",function(t){e.geometry=t,e.tryUpdateGeometry()})},beforeDestroy:function(){this.uninstall()},methods:{tryUpdateGeometry:function(e){this.points&&(this.points.geometry=this.geometry)},tryUpdateMaterial:function(e){this.points&&(this.points.material=this.material)},uninstall:function(){this.$parent.$emit(\"remove\",this.points)}}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/Element/Mesh.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglElementMeshVue=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=\"\\n\\n\",n=document.head||document.getElementsByTagName(\"head\")[0],i=document.createElement(\"style\");i.type=\"text/css\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\n  <div class=\"mesh\"data-s-18qt>\\n    <slot>\\n    </slot>\\n  </div>\\n',props:{},data:function(){return{element:!1,mesh:!1,material:!1,geometry:!1}},created:function(){var e=this;this.element=this.mesh=new r.Mesh,this.$parent.$emit(\"add\",this.mesh),this.$emit(\"element\",this.mesh),this.$on(\"material\",function(t){e.material=t,e.tryUpdateMaterial()}),this.$on(\"geometry\",function(t){e.geometry=t,e.tryUpdateGeometry()})},beforeDestroy:function(){this.uninstall()},methods:{tryUpdateGeometry:function(e){this.mesh&&(this.mesh.geometry=this.geometry)},tryUpdateMaterial:function(e){this.mesh&&(this.mesh.material=this.material)},uninstall:function(){this.$parent.$emit(\"remove\",this.mesh)}}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/webgl/Geo/SphereBufferGeometry.vue\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.webglGeoSphereBufferGeometryVue=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=\"\\n\\n\",n=document.head||document.getElementsByTagName(\"head\")[0],i=document.createElement(\"style\");i.type=\"text/css\",i.styleSheet?i.styleSheet.cssText=t:i.appendChild(document.createTextNode(t)),n.appendChild(i);var r=window.THREE;e.default={template:'\\n  <div class=\"geo-sphere\"data-s-bg></div>\\n',data:function(){return{geometry:!1}},mounted:function(){var e=new r.SphereBufferGeometry(2,256,256);this.$parent.$emit(\"geometry\",e)}}}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/shader/Simple/vs.vert\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.shaderSimpleVsVert=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.default=\"varying vec3 vPos;\\nuniform float time;\\n\\nvoid main (void) {\\n  vPos = position;\\n  vPos.x = vPos.x + sin(vPos.x + time);\\n  vPos.y = vPos.y + cos(vPos.y + time);\\n  vPos.z = vPos.z + tan(vPos.z + time);\\n  \\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n  vec4 outputPos = projectionMatrix * mvPosition;\\n  gl_Position = outputPos;\\n  gl_PointSize = 1.0;\\n}\"}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/shader/Simple/fs.frag\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.shaderSimpleFsFrag=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.default=\"varying vec3 vPos;\\n\\nvoid main () {\\n  gl_FragColor = vec4(vec3(vPos), 1.0);\\n}\"}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/shader/Fling/vs.vert\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.shaderFlingVsVert=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.default=\"varying vec3 vPos;\\nuniform float time;\\n\\nvoid main (void) {\\n  vPos = position;\\n  vPos.x = vPos.x + sin(vPos.x + time);\\n  vPos.y = vPos.y + cos(vPos.y + time);\\n  vPos.z = vPos.z + tan(vPos.z + time);\\n  \\n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\\n  vec4 outputPos = projectionMatrix * mvPosition;\\n  gl_Position = outputPos;\\n  gl_PointSize = 1.0;\\n}\\n\"}),function(e,t){if(\"function\"==typeof define&&define.amd)define(\"@/three.js\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.threeJs=n.exports}}(this,function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=window.THREE;e.default=t});\n\n    var deps = [\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\",\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\",\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\",\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\",\"https://threejs.org/examples/js/GPUComputationRenderer.js\"];\n\n    function preload (deps, done) {\n      if (deps[0]) {\n        var script = document.createElement('script');\n        script.onload = function () {\n          deps.shift();\n          preload(deps, done);\n        };\n        script.src = deps[0];\n        document.body.appendChild(script);\n      } else {\n        done();\n      }\n    }\n    preload(deps, function () {});\n    preload(deps, function() {\n      requireJSRequire(['@/main.js'], function () {\n        setTimeout(() => {\n\n          window.addEventListener('message', (e) => {\n            // is from main window to this iframe window\n            if (\n              (e.source === window.top) &&\n              e.data &&\n              e.data.type\n            ) {\n              console.log('iFrame Got Main Message: ', e.data)\n              console.log('iFrame Dispatching Custom Event: ', e.data)\n              let customEvent = new CustomEvent(e.data.type, { detail: e.data });\n              window.dispatchEvent(customEvent);\n            }\n          });\n\n          (window.opener || window.top).postMessage({ type: 'iframe-system-ready', detail: { status: 'ok' } }, window.location.origin);\n        }, 10);\n      });\n    });\n\n  }\n  new OMG_KCsVcjjednlGSjCajzecXtVY();\n}());\n"},"now":{"currentFilePath":"@/webgl/pages/Sample.vue","openedFiles":[{"path":"@/router.js"},{"path":"@/index.html"},{"path":"@/main.js"},{"path":"@/style.css"},{"path":"@/webgl/pages/Sample.vue"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\n\nvar target = oldDOM || newDOM;\n\nif (!oldDOM) {\n  newDOM.id = '#app-attach-point';\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n});\n\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <!-- <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div> -->\n    \n    <div class=\"layout\">\n      \n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Fling/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 07:39:58 GMT+0800 (Hong Kong Standard Time)"},"backups":[{"currentFilePath":"@/webgl/pages/Sample.vue","openedFiles":[{"path":"@/router.js"},{"path":"@/index.html"},{"path":"@/main.js"},{"path":"@/style.css"},{"path":"@/webgl/pages/Sample.vue"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\n\nvar target = oldDOM || newDOM;\n\nif (!oldDOM) {\n  newDOM.id = '#app-attach-point';\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n});\n\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <!-- <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div> -->\n    \n    <div class=\"layout\">\n      \n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Fling/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 07:50:21 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Sample.vue","openedFiles":[{"path":"@/router.js"},{"path":"@/index.html"},{"path":"@/main.js"},{"path":"@/style.css"},{"path":"@/webgl/pages/Sample.vue"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\n\nvar target = oldDOM || newDOM;\n\nif (!oldDOM) {\n  newDOM.id = '#app-attach-point';\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n});\n\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <!-- <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div> -->\n    \n    <div class=\"layout\">\n      \n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Fling/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 07:50:19 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/router.js","openedFiles":[{"path":"@/router.js"},{"path":"@/index.html"},{"path":"@/main.js"},{"path":"@/style.css"},{"path":"@/webgl/pages/Sample.vue"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\n\nvar target = oldDOM || newDOM;\n\nif (!oldDOM) {\n  newDOM.id = '#app-attach-point';\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n});\n\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 07:41:15 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/router.js","openedFiles":[{"path":"@/router.js"},{"path":"@/index.html"},{"path":"@/main.js"},{"path":"@/style.css"},{"path":"@/webgl/pages/Sample.vue"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\n\nvar target = oldDOM || newDOM;\n\nif (!oldDOM) {\n  newDOM.id = '#app-attach-point';\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n});\n\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 07:39:58 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Sample.vue","openedFiles":[{"path":"@/webgl/pages/Sample.vue"},{"path":"@/index.html"},{"path":"@/main.js"},{"path":"@/style.css"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\n\nvar target = oldDOM || newDOM;\n\nif (!oldDOM) {\n  newDOM.id = '#app-attach-point';\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n});\n\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 07:33:57 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Sample.vue","openedFiles":[{"path":"@/webgl/pages/Sample.vue"},{"path":"@/index.html"},{"path":"@/main.js"},{"path":"@/style.css"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\n\nvar target = oldDOM || newDOM;\n\nif (!oldDOM) {\n  newDOM.id = '#app-attach-point';\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n});\n\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 07:26:57 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/main.js","openedFiles":[{"path":"@/main.js"},{"path":"@/router.js"},{"path":"@/three.js"},{"path":"@/webgl/pages/Sample.vue"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\n\nvar target = oldDOM || newDOM;\n\nif (!oldDOM) {\n  newDOM.id = '#app-attach-point';\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n});\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 06:58:14 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/main.js","openedFiles":[{"path":"@/main.js"},{"path":"@/router.js"},{"path":"@/three.js"},{"path":"@/webgl/pages/Sample.vue"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\n\nvar target = oldDOM || newDOM;\n\nif (!oldDOM) {\n  newDOM.id = '#app-attach-point';\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n});\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 06:58:10 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/main.js","openedFiles":[{"path":"@/main.js"},{"path":"@/router.js"},{"path":"@/three.js"},{"path":"@/webgl/pages/Sample.vue"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 06:18:36 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/main.js","openedFiles":[{"path":"@/main.js"},{"path":"@/router.js"},{"path":"@/three.js"},{"path":"@/webgl/pages/Sample.vue"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Jun 22 2018 05:56:38 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Sample.vue","openedFiles":[{"path":"@/webgl/pages/Sample.vue"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:44:16 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Sample.vue","openedFiles":[{"path":"@/webgl/pages/Sample.vue"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:37:14 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Sample.vue","openedFiles":[{"path":"@/webgl/pages/Sample.vue"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n      \n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:31:53 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/router.js","openedFiles":[{"path":"@/src/pages/sample.vue"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/webgl/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      }.\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:29:34 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/src/pages/sample.vue","openedFiles":[{"path":"@/src/pages/sample.vue"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/src/pages/sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/src/pages/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      // window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      }.\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:27:45 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/src/pages/sample.vue","openedFiles":[{"path":"@/src/pages/sample.vue"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/src/pages/sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/src/pages/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      // window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      }.\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:27:28 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/src/pages/sample.vue","openedFiles":[{"path":"@/src/pages/sample.vue"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/src/pages/sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/src/pages/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      // window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:23:45 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/src/pages/sample.vue","openedFiles":[{"path":"@/src/pages/sample.vue"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/src/pages/sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/src/pages/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      // window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:23:43 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/src/pages/sample.vue","openedFiles":[{"path":"@/src/pages/sample.vue"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/src/pages/sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/src/pages/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:18:35 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/src/pages/sample.vue","openedFiles":[{"path":"@/src/pages/sample.vue"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/webgl/sample.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\nimport Sample from '@/src/pages/sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Sample\n    },\n    {\n      path: '/sub',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/src/pages/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\" @click=\"wonder\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:18:34 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/sample.vue","openedFiles":[{"path":"@/webgl/sample.vue"},{"path":"@/webgl/Bundle.js"},{"path":"@/app.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:13:56 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/sample.vue","openedFiles":[{"path":"@/webgl/sample.vue"},{"path":"@/webgl/Bundle.js"},{"path":"@/app.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 22:13:55 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/layout/Player.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 21:46:00 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 08:03:22 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/index.html","openedFiles":[],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos + 0.5), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 07:53:43 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/Bundle.js","openedFiles":[{"path":"@/webgl/Bundle.js"},{"path":"@/router.js"},{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos + 0.5), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 07:48:25 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/Bundle.js","openedFiles":[{"path":"@/webgl/Bundle.js"},{"path":"@/router.js"},{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos + 0.5), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 07:43:34 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/Bundle.js","openedFiles":[{"path":"@/webgl/Bundle.js"},{"path":"@/router.js"},{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos + 0.5), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 07:43:32 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/router.js","openedFiles":[{"path":"@/router.js"},{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos + 0.5), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 07:35:39 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Simple/fs.frag","openedFiles":[{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos + 0.5), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 07:27:34 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Simple/fs.frag","openedFiles":[{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Jun 21 2018 07:19:15 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Simple/fs.frag","openedFiles":[{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 10:07:17 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 10:00:17 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 07:27:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 07:20:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 07:13:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 07:06:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Simple/fs.frag"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 06:59:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 06:52:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 06:45:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 06:38:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 06:31:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 06:24:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 06:17:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 06:10:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 06:03:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 05:56:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 05:49:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 05:42:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 05:35:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 05:28:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 05:21:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 05:14:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 05:07:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 05:00:11 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 04:54:30 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/shader/Fling/vs.vert","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 04:54:29 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/webgl/System/Scene.vue"},{"path":"@/webgl/Bundle.js"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 04:48:49 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/webgl/System/Scene.vue"},{"path":"@/webgl/Bundle.js"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 04:41:49 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/webgl/System/Scene.vue"},{"path":"@/webgl/Bundle.js"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 04:34:48 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/webgl/System/Scene.vue"},{"path":"@/webgl/Bundle.js"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 04:27:47 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/webgl/System/Scene.vue"},{"path":"@/webgl/Bundle.js"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 04:24:57 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/webgl/System/Scene.vue"},{"path":"@/webgl/Bundle.js"},{"path":"@/router.js"},{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Wed Jun 20 2018 04:22:16 GMT+0800 (Hong Kong Standard Time)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 10:36:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 10:29:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 10:22:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 10:15:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 10:08:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 10:01:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 09:54:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 09:47:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 09:40:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 09:33:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 09:26:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 09:19:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 09:12:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 09:05:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 08:58:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 08:51:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 08:44:30 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Sun Apr 08 2018 08:40:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 20:53:21 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 20:46:21 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 20:39:21 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 20:32:21 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 20:19:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 20:12:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 20:05:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 19:58:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 19:51:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 19:44:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 19:37:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 19:30:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 19:23:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 19:16:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 19:09:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 19:02:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 18:55:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 18:48:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 18:41:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 18:34:12 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 18:07:33 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 17:57:03 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 17:52:26 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/pages/Happy.vue","openedFiles":[{"path":"@/app.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 17:52:24 GMT+0800 (HKT)"},{"currentFilePath":"@/router.js","openedFiles":[{"path":"@/router.js"},{"path":"@/webgl/System/Renderer.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Tue Apr 03 2018 14:51:39 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/System/Renderer.vue","openedFiles":[{"path":"@/webgl/System/Renderer.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Feb 16 2018 14:50:39 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/System/Renderer.vue","openedFiles":[{"path":"@/webgl/System/Renderer.vue"},{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Feb 16 2018 14:50:37 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/layout/Player.vue","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Feb 16 2018 09:46:59 GMT+0800 (HKT)"},{"currentFilePath":"@/webgl/layout/Player.vue","openedFiles":[{"path":"@/shader/Fling/vs.vert"},{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      // this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Feb 16 2018 06:07:43 GMT+0800 (HKT)"},{"currentFilePath":"@/shader/Simple/vs.vert","openedFiles":[{"path":"@/shader/Simple/vs.vert"},{"path":"@/webgl/pages/Happy.vue"},{"path":"@/webgl/pages/Home.vue"},{"path":"@/webgl/layout/Player.vue"},{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"false\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v; }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Feb 16 2018 05:59:49 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Feb 16 2018 05:36:54 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Feb 16 2018 05:36:27 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Feb 16 2018 05:36:25 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Fri Feb 16 2018 05:33:22 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    \n    \n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Feb 15 2018 22:02:54 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    \n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Feb 15 2018 22:02:45 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    \n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Feb 15 2018 22:02:40 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    \n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Feb 15 2018 21:55:07 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    \n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Feb 15 2018 16:39:02 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    \n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Feb 15 2018 16:38:52 GMT+0800 (HKT)"},{"currentFilePath":"@/index.html","openedFiles":[{"path":"@/index.html"}],"files":[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    \n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n  </body>\n</html>\n"},{"path":"@/style.css","src":"html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}"},{"path":"@/main.js","src":"import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = '#app-attach-point';\ndocument.body.appendChild(newDOM);\nvar target = oldDOM || newDOM;\n\nvar app = new Vue({\n  router,\n  el: target,\n  components: {\n    App\n  },\n  template: '<div id=\"app\"><App /></div>'\n})\n\nwindow.addEventListener('message', (evt) => {\n  var { type, data } = evt.data;\n  window.dispatchEvent(new CustomEvent(type, { detail: data }))\n}, false);\n\nwindow.addEventListener('slider', ({ detail }) => {\n  console.log(detail);\n  (window.opener || window.top).dispatchEvent(new CustomEvent('loklok', { detail: { rand: Math.random() } }))\n});\n\nexport default app;\n"},{"path":"@/router.js","src":"import Player from '@/webgl/layout/Player.vue'\nimport Home from '@/webgl/pages/Home.vue'\nimport Happy from '@/webgl/pages/Happy.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Home\n        },\n        {\n          path: 'happy',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"},{"path":"@/app.vue","src":"<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n      \n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/layout/Player.vue","src":"<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Home.vue","src":"<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/pages/Happy.vue","src":"<template>\n  <div class=\"\">\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n      <Object3D pz=\"1\">\n        <Mesh>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Mesh>\n      </Object3D>\n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/sample.vue","src":"<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"},{"path":"@/webgl/Bundle.js","src":"import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\n\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //Geo\n  SphereBufferGeometry\n}\n"},{"path":"@/webgl/System/Renderer.vue","src":"<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"},{"path":"@/webgl/System/Scene.vue","src":"<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/PerspectiveCamera.vue","src":"<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"},{"path":"@/webgl/System/Raycaster.vue","src":"<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/MeshPhongMaterial.vue","src":"<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Material/ShaderMaterial.vue","src":"<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/PointLight.vue","src":"<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Object3D.vue","src":"<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Points.vue","src":"<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Element/Mesh.vue","src":"<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/webgl/Geo/SphereBufferGeometry.vue","src":"<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"},{"path":"@/shader/Simple/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/shader/Simple/fs.frag","src":"varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(vPos), 1.0);\n}"},{"path":"@/shader/Fling/vs.vert","src":"varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}"},{"path":"@/three.js","src":"var THREE = window.THREE\nexport default THREE\n"}],"date":"Thu Feb 15 2018 16:32:46 GMT+0800 (HKT)"}]}