{
	"now": {
		"currentFilePath": "@/pages/Sample.vue",
		"openedFiles": [
			{
				"path": "@/lib/scroller.js"
			},
			{
				"path": "@/hot-data.hydrate.json"
			},
			{
				"path": "@/pages/PALMS.vue"
			},
			{
				"path": "@/pages/Sample.vue"
			},
			{
				"path": "@/layout/Player.vue"
			}
		],
		"files": [
			{
				"path": "@/index.html",
				"src": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n\n    <title>WebGL</title>\n\n    <meta name=\"author\" content=\"loklok\">\n    <meta name=\"description\" content=\"WebGL Art\">\n    <meta name=\"keywords\" content=\"WebGL, Art\">\n\n    <style type=\"text/css\">\n    </style>\n\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    \n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n    <script required src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n    <script required src=\"https://cdnjs.cloudflare.com/ajax/libs/expr-eval/1.2.1/bundle.min.js\"></script>\n  </body>\n</html>\n"
			},
			{
				"path": "@/style.css",
				"src": "@import url('https://fonts.googleapis.com/css?family=Quicksand');\n\nhtml, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\n#app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  font-family: 'Quicksand', sans-serif;\n  background-color: white;\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n"
			},
			{
				"path": "@/main.js",
				"src": "import '@/style.css'\nimport App from '@/app.vue'\nimport router from '@/router.js'\n\nvar vpDOM = document.querySelector('#app-vp');\nvar oldDOM = document.querySelector('#app-attach-point');\nvar newDOM = document.createElement('div');\nnewDOM.id = 'app';\n\nvar target = vpDOM || oldDOM || newDOM;\n\nif (!oldDOM && !vpDOM) {\n  document.body.appendChild(newDOM);\n}\n\nvar app = new Vue({\n  router,\n  el: target,\n  data: {\n    vp: vpDOM\n  },\n  components: {\n    App\n  },\n  methods: {\n    getStyle () {\n      if (vpDOM) {\n        return {\n          width: '100vw',\n          height: '100vh'\n        }\n      } else {\n        return {}\n      }\n    }\n  },\n  template: '<div id=\"app\" :style=\"getStyle()\"><App /></div>'\n});\n\n\nwindow.addEventListener('main-system-ready', (evt) => {\n  var data = evt.detail\n  console.log('App Got Custom Event:', data)\n}, false);\n\nexport default app;\n\n"
			},
			{
				"path": "@/router.js",
				"src": "import Player from '@/layout/Player.vue'\nimport Home from '@/pages/Home.vue'\nimport Happy from '@/pages/Happy.vue'\nimport PALMS from '@/pages/PALMS.vue'\nimport OM3D from '@/pages/OM3D.vue'\nimport YO2 from '@/pages/YO2.vue'\nimport Sample from '@/pages/Sample.vue'\n\nconst router = new VueRouter({\n  mode: 'hash',\n  routes: [\n    {\n      path: '/',\n      component: PALMS\n    },\n    {\n      path: '/om3d',\n      component: OM3D\n    },\n    {\n      path: '/yo2',\n      component: YO2\n    },\n    \n    {\n      path: '/sample',\n      component: Sample\n    },\n    {\n      path: '/v1',\n      component: Player,\n      children: [\n        {\n          path: '',\n          component: Happy\n        }\n      ]\n    }\n  ]\n})\n\nexport default router\n"
			},
			{
				"path": "@/app.vue",
				"src": "<template>\n  <div>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  data () {\n    return {\n    }\n  },\n  created () {\n    \n  },\n  beforeDestroy () {\n    \n  },\n  methods: {\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/layout/Player.vue",
				"src": "<template>\n  <div class=\"full\" ref=\"full\">\n\n    <Renderer\n      :alpha=\"true\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n      @toucher=\"(v) => { toucher = v }\"\n    >\n    </Renderer>\n    \n    <keep-alive>\n      <component\n        class=\"hidden\"\n        :is=\"'router-view'\"\n        v-if=\"renderer\"\n        :size=\"size\"\n        :toucher=\"toucher\"\n        :renderer=\"renderer\"\n      >\n      </component>\n    </keep-alive>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    \n  },\n  data () {\n    return {\n      toucher: false,\n      resizer: () => {},\n      renderer: false,\n      size: {\n        width: 100,\n        height: 100,\n        aspect: 1\n      }\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.$nextTick(() => {\n        var rect = this.$refs.full.getBoundingClientRect()\n        this.size = {\n          width: rect.width,\n          height: rect.height,\n          aspect: rect.width / rect.height\n        }\n      })\n    }\n    window.addEventListener('resize', resizer.bind(this))\n    resizer()\n  }\n}\n</script>\n\n<style scoped>\n.hidden{\n  display: none;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"
			},
			{
				"path": "@/pages/Sample.vue",
				"src": "<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\" ref=\"touchSurface\">\n      Scroll Down\n      <router-link to=\"/\">home</router-link>\n    </div>\n    \n    <!--\n    <div class=\"full layer\">\n    </div>\n    -->\n    \n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      \n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D v-if=\"fuller\" @element=\"(v) => { scroller = v; }\">\n        <Object3D :pz=\"0\">\n          <Points @element=\"(v) => { elements.push(v); }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        <Object3D :py=\"-fuller.height\">\n          <Points @element=\"(v) => { elements.push(v); }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        <Object3D :py=\"-fuller.height * 2\">\n          <Points @element=\"(v) => { elements.push(v); }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nimport { DomToucher, fuller } from '@/general-tools.js'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera);\n      }\n    \n      this.animatable.time.value = window.performance.now() * 0.001;\n    },\n    wonder () {\n      window.alert('click');\n    },\n    setupScene () {\n      this.scene.background = new THREE.Color(0x000000);\n    },\n    setupToucher () {\n      let touchSurface = this.$refs['touchSurface']\n      \n      var self = this\n      var sizer = {\n        get elements () {\n          return self.elements\n        },\n        reduceMaxX: (accu, eg, key) => {\n          if (!eg || !eg.parent || !eg.parent.position) { return accu }\n          let length = Math.abs(eg.parent.position.x)\n          if (length >= accu) {\n            accu = length\n          }\n          return accu\n        },\n        reduceMaxY: (accu, eg, key) => {\n          if (!eg || !eg.parent || !eg.parent.position) { return accu }\n          let length = Math.abs(eg.parent.position.y)\n          if (length >= accu) {\n            accu = length\n          }\n          return accu\n        },\n        get totalX () {\n          return this.elements.reduce(this.reduceMaxX, 0)\n        },\n        get totalY () {\n          if (!self.fuller) {\n            return 0\n          }\n          return this.elements.reduce(this.reduceMaxY, 0)// - self.fuller.height * 0.5 + this.lastItemHalf\n        }\n        /*,\n        get lastItemHalf () {\n          // if there is no last item then return 0\n          if (!this.elements[this.elements.length - 1]) { return 0 }\n          return this.elements[this.elements.length - 1].geometry.parameters.height * 0.5\n        }\n        */\n      }\n      \n      this.domToucher = new DomToucher({ toucher: touchSurface });\n      this.domToucher.addEventListener('update', (evt) => {\n        // Scroll X\n        let maxX = 0\n        let minX = -sizer.totalX\n        let maxY = sizer.totalY\n        let minY = 0\n\n        // let moveAmountX = evt.state.inX * 0.25\n        let moveAmountY = evt.state.inY * 0.25\n        let scroller = this.scroller\n        if (scroller) {\n          // if (this.fs) {\n          //   // if one row\n          //   if (this.fs.aspect <= 1) {\n          //     scroller.position.x += moveAmountY + moveAmountX\n          //   } else {\n          //     // if 2x2\n          //     scroller.position.x += moveAmountX\n          //     scroller.position.y += -moveAmountY\n          //   }\n          // } else {\n          //   // if no fullscreen detected\n          //   scroller.position.x += moveAmountX\n          //   scroller.position.y += -moveAmountY\n          // }\n\n          scroller.position.y -= moveAmountY\n\n          if (scroller.position.x > maxX) {\n            let dv = { ...scroller.position }\n            dv.x -= (dv.x - maxX) * 0.35\n            scroller.position.set(dv.x, dv.y, dv.z)\n          }\n          if (scroller.position.x < minX) {\n            let dv = { ...scroller.position }\n            dv.x -= (dv.x - minX) * 0.35\n            scroller.position.set(dv.x, dv.y, dv.z)\n          }\n\n          if (scroller.position.y > maxY) {\n            let dv = { ...scroller.position }\n            dv.y -= (dv.y - maxY) * 0.35\n            scroller.position.set(dv.x, dv.y, dv.z)\n          }\n          if (scroller.position.y < minY) {\n            let dv = { ...scroller.position }\n            dv.y -= (dv.y - minY) * 0.35\n            scroller.position.set(dv.x, dv.y, dv.z)\n          }\n        }\n      });\n      var resizer = this.resizer = () => {\n        this.fuller = fuller({ planeZ: 0, camera: this.camera })\n      }\n      window.addEventListener('resize', resizer, false)\n      resizer()\n      this.$nextTick(resizer)\n    }\n  },\n  data () {\n    return {\n      fuller: false,\n      elements: [],\n      scroller: false,\n      DomToucher,\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false,\n      domToucher: false\n    }\n  },\n  created () {\n  },\n  mounted () {\n    this.setupScene()\n    this.setupToucher()\n    \n    window.addEventListener('resize', () => {\n      this.size = {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      }\n    })\n    \n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  beforeDestroy () {\n    if (this.domToucher) {\n      this.domToucher.clean()\n    }\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.layer {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.taller{\n  height: 200vh;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"
			},
			{
				"path": "@/pages/Home.vue",
				"src": "<template>\n  <div class=\"\">\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000.0\"\n      :position=\"{ x: 0, y: 0, z: 15 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v; }\">\n\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n\n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n    \n    <Raycaster v-if=\"camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n    \n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Home',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      this.$router.push({\n        path: '/happy'\n      })\n      this.$forceUpdate()\n      console.log('Click to happy');\n    },\n    setup () {\n      //this.scene.background = new THREE.Color(0xffffff);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"
			},
			{
				"path": "@/pages/Happy.vue",
				"src": "<template>\n  <div class=\"\">\n    \n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n    \n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      <Object3D pz=\"0.3\">\n        <Points @element=\"(v) => { v.$skipRayCast = true }\">\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS2\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n    \n    <Raycaster v-if=\"renderer && camera && toucher && scene\" :scene=\"scene\" :toucher=\"toucher\" :camera=\"camera\" @found=\"(v) => { found = v; }\" @click=\"onClick\">\n    </Raycaster>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\n\nimport simpleVS2 from '@/shader/Fling/vs.vert'\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  name: 'Happy',\n  props: {\n    toucher: {},\n    size: {},\n    renderer: {},\n    doc: {}\n  },\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  data () {\n    return {\n      cam: {\n        pos: { x: 3, y: 5, z: 10 }\n      },\n      ready: false,\n      cubeCamera: false,\n      visible: true,\n      resizer: () => {},\n      scene: false,\n      camera: false,\n      \n      found: [],\n      \n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      simpleVS2\n      \n    }\n  },\n  methods: {\n    onClick ({ event, intersects }) {\n      console.log(event, intersects)\n      this.$router.push('/')\n    },\n    setup () {\n      this.scene.background = new THREE.Color(0x000000);\n    },\n    renderWebGL () {\n      TWEEN.update()\n      \n      this.animatable.time.value += 0.01;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  watch: {\n    camera () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    renderer () {\n      if (this.camera && this.renderer) {\n        this.ready = true\n      }\n    },\n    ready () {\n      if (this.ready) {\n        this.setup()\n      }\n    }\n  },\n  created () {\n    \n  },\n  activated () {\n    var self = this\n    function loop (rAFT) {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL(rAFT)\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    console.log('cancel animation frame')\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n</style>\n"
			},
			{
				"path": "@/pages/PALMS.vue",
				"src": "<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <!--\n    <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div>\n    -->\n    \n    <div class=\"full layer\" ref=\"domScroller\" @scroll=\"scl.onScroll\">\n      <div class=\"dom-content\" ref=\"domContent\">\n        <h1 class=\"center\">\n          3D Projects \n        </h1>\n        \n        <h2 class=\"center\">\n          by LokLok\n        </h2>\n        \n        <div class=\"center\">\n          <div class=\"max-width\" v-html=\"getArticleHTML({ eID: 'iremember' })\"></div>\n        </div>\n        \n        <ol class=\"shadow\">\n          <li>\n            <router-link to=\"/om3d\">Oh My 3D Math Tools</router-link>\n          </li>\n          <li>\n            <router-link to=\"/yo2\">Yo Teach 2.0 (3D SpaceBoaHot)</router-link>\n          </li>\n        </ol>\n        \n        \n        \n        <div class=\"taller\"></div>\n    \n        <div class=\"center\">\n          Scroll Down to see some animation....\n        </div>        \n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n        <div class=\"taller\"></div>\n\n\n        <div class=\"center\">\n          Thanks for viewing my site. :D\n        </div>\n        <div class=\"taller\"></div>\n        \n        <!-- \n        {{ Hot.state.root.rotation }}\n        <b>\n          <router-link to=\"/v1/\">/v1</router-link>\n        </b>\n        <router-link to=\"/sample\">sample</router-link></b>\n        <br />\n        {{ Hot.state.root.note }}\n        <div class=\"taller\"></div>\n        Oh My 3D Math Tools\n        <div class=\"taller\"></div>\n        323\n        <div class=\"taller\"></div>\n        323\n        <div class=\"taller\"></div>\n        323\n        <div class=\"taller\"></div>\n        323\n        <div class=\"taller\"></div>\n        323 -->\n      </div>\n    </div>\n    \n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 20 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D v-if=\"scl\" :py=\"scl.state.progress * 10 * 2 * 1.3\">\n        \n        <Object3D :ry=\"scl.state.progress * PI * 2.0\" :px=\"-5.553\" :py=\"10 * -1 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"getWakanda().vertexShader\" :fs=\"getWakanda().fragmentShader\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :px=\"5.553\" :py=\"10 * 0 * -1.3\" :pz=\"-10\" :ry=\"scl.state.progress * PI * 2.0\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :rx=\"scl.state.progress * PI * 2.0\" :px=\"-5.553\" :py=\"10 * 1 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :rx=\"scl.state.progress * PI * 2.0\" :rx=\"scl.state.progress * PI * 2.0\"  :px=\"5.553\" :py=\"10 * 2 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :rx=\"scl.state.progress * PI * 2.0\" :px=\"-5.553\" :py=\"10 * 3 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n\n\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nimport * as Hot from '@/hot-data.access.js'\nimport * as Scroller from '@/lib/scroller.js'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  methods: {\n    promise () {\n      return Promise.resolve('haha')\n    },\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.0001;\n\n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    },\n    getArticleHTML ({ eID }) {\n      let item = Hot.getBycIDeID({ cID: 'articles', eID: eID })\n      if (!item) {\n        item = {\n          data: {\n            html: ''\n          }\n        }\n      }\n      return item.data.html\n    },\n    getWakanda () {\n      let item = Hot.getBycIDeID({ cID: 'shaders', eID: 'box1' })\n      if (!item) {\n        item = {\n          data: {}\n        }\n      }\n      return item.data\n    }\n  },\n  computed: {\n  },\n  data () {\n    return {\n      scl: false,\n      Hot,\n      progress: 0,\n      PI: Math.PI,\n      animatable: {\n        time: { value: 0 },\n        progress: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    this.scl = Scroller.make({ scroller: this.$refs['domScroller'], content: this.$refs['domContent'] })\n    \n    window.addEventListener('resize', () => {\n      this.size = {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      }\n    })\n    this.scene.background = new THREE.Color(0x000000);\n    \n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  beforeDestroy () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.taller{\n  height: 15vh;\n}\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.layer {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n.dom-content{\n  max-width: 375px;\n  margin: 0px auto;\n  color: white;\n}\n.dom-content a {\n  color: white;\n}\n\n.center{\n  display: flex;\n  justify-content: center;\n}\n.shadow{\n  text-shadow: 1px 1px 0px black;\n}\n\n.max-width{\n  max-width: 320px;\n}\n\n</style>\n"
			},
			{
				"path": "@/pages/OM3D.vue",
				"src": "<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full layer\" ref=\"domScroller\" @scroll=\"scl.onScroll\">\n      <div class=\"dom-content\" ref=\"domContent\">\n        <h1  class=\"center\">\n          Oh My 3D Math tools\n        </h1>\n        \n        <div class=\"center\">\n          <router-link to=\"/\">Back</router-link>\n        </div>\n        <br />\n        \n        <div class=\"center\">\n            <iframe style=\"width: 80vw; height: 80vh;\" width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/YqDGzKILOfo\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n        </div>\n        \n      </div>\n    </div>\n    \n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 20 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D v-if=\"scl\" :py=\"scl.state.progress * 10 * 2 * 1.3\">\n        \n        <Object3D :ry=\"scl.state.progress * PI * 2.0\" :px=\"-5.553\" :py=\"10 * -1 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :px=\"5.553\" :py=\"10 * 0 * -1.3\" :pz=\"-10\" :ry=\"scl.state.progress * PI * 2.0\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :rx=\"scl.state.progress * PI * 2.0\" :px=\"-5.553\" :py=\"10 * 1 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :rx=\"scl.state.progress * PI * 2.0\" :rx=\"scl.state.progress * PI * 2.0\"  :px=\"5.553\" :py=\"10 * 2 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n\n\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nimport * as Scroller from '@/lib/scroller.js'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.0001;\n\n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  computed: {\n  },\n  data () {\n    return {\n      onScroll () {},\n      updateScroller () {},\n      scl: false,\n      progress: 0,\n      PI: Math.PI,\n      animatable: {\n        time: { value: 0 },\n        progress: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    this.scl = Scroller.make({ scroller: this.$refs['domScroller'], content: this.$refs['domContent'] })\n    \n    window.addEventListener('resize', () => {\n      this.size = {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      }\n    })\n    this.scene.background = new THREE.Color(0x000000);\n    \n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  beforeDestroy () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.taller{\n  height: 15vh;\n}\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.layer {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n.dom-content{\n  max-width: 375px;\n  margin: 0px auto;\n  color: white;\n}\n.dom-content a {\n  color: white;\n}\n\n.center{\n  display: flex;\n  justify-content: center;\n}\n.shadow{\n  text-shadow: 1px 1px 0px black;\n}\n\n</style>\n\n\n"
			},
			{
				"path": "@/webgl/Bundle.js",
				"src": "import Renderer from '@/webgl/System/Renderer.vue';\nimport Scene from '@/webgl/System/Scene.vue';\nimport PerspectiveCamera from '@/webgl/System/PerspectiveCamera.vue';\nimport Raycaster from '@/webgl/System/Raycaster.vue';\n\nimport MeshPhongMaterial from '@/webgl/Material/MeshPhongMaterial.vue';\nimport ShaderMaterial from '@/webgl/Material/ShaderMaterial.vue';\n\nimport Object3D from '@/webgl/Element/Object3D.vue';\nimport Mesh from '@/webgl/Element/Mesh.vue';\nimport Points from '@/webgl/Element/Points.vue';\nimport PointLight from '@/webgl/Element/PointLight.vue';\n\nimport SphereBufferGeometry from '@/webgl/Geo/SphereBufferGeometry.vue';\nimport BoxBufferGeometry from '@/webgl/Geo/BoxBufferGeometry.vue';\n\nimport LayoutNode from '@/webgl/System/LayoutNode.vue';\n\nexport default {\n  //materials\n  MeshPhongMaterial,\n  ShaderMaterial,\n  \n  //system\n  Renderer,\n  Scene,\n  PerspectiveCamera,\n  Raycaster,\n  \n  //Elemnts\n  PointLight,\n  Points,\n  Object3D,\n  Mesh,\n  \n  //helper\n  LayoutNode,\n  \n  //Geo\n  SphereBufferGeometry,\n  BoxBufferGeometry\n}\n"
			},
			{
				"path": "@/webgl/System/LayoutNode.vue",
				"src": "<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\nimport Parser from '@/math-parser.js'\nexport default {\n  props: {\n    camera: {},\n    planeZ: {},\n    page: {},\n    formulas: {}\n  },\n  data () {\n    return {\n      fs: false,\n      info: {\n        position: { x: 0, y: 0, z: 0 },\n        size: { width: 10, height: 10, depth: 0 }\n      }\n    }\n  },\n  created () {\n    this.$on('add', (v) => {\n      this.$parent.$emit('add', v)\n    })\n    this.$on('remove', (v) => {\n      this.$parent.$emit('remove', v)\n    })\n    this.$on('geometry', (v) => {\n      this.$parent.$emit('geometry', v)\n    })\n  },\n  methods: {\n    tellKids (m, v) {\n      this.$children.forEach((kid) => {\n        kid.$emit(m, v)\n      })\n    }\n  },\n  watch: {\n    fs () {\n      \n    }\n  },\n  mounted () {\n    var resizer = this.resizer = () => {\n      this.fs = fullScreener({ planeZ: this.planeZ || 0, camera: this.camera })\n    }\n    window.addEventListener('resize', resizer, false)\n    resizer()\n    this.$nextTick(resizer)\n    \n    //Parser.evaluate(expr, vars)\n    //let geometry = new THREE.SphereBufferGeometry(2, 256, 256)\n    //this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/webgl/System/Renderer.vue",
				"src": "<template>\n  <div class=\"full pos-rel\">\n    <div class=\"full layer\" ref=\"mounter\"></div>\n    <div class=\"full layer\" ref=\"toucher\"><slot></slot></div>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE\n\nexport default {\n  data () {\n    return {\n      // THREE,\n      renderer: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  mounted () {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: this.alpha,\n      antialias: this.antialias\n    })\n    this.resize()\n    this.renderer.domElement.style.marginBottom = '-6px'\n    this.renderer.domElement.addEventListener('touchstart', () => {}, true)\n    this.$refs.mounter.appendChild(this.renderer.domElement)\n    \n    this.$emit('toucher', this.$refs['toucher'])\n    this.$emit('renderer', this.renderer)\n  },\n  beforeDestroy () {\n    this.$refs.mounter.removeChild(this.renderer.domElement)\n  },\n  watch: {\n    size () {\n      this.resize()\n    }\n  },\n  methods: {\n    resize () {\n      let ratio = window.devicePixelRatio || 1\n      this.renderer.setPixelRatio(ratio)\n      this.renderer.setSize(this.size.width, this.size.height)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.pos-rel{\n  position: relative;\n}\n.layer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n</style>\n"
			},
			{
				"path": "@/webgl/System/Scene.vue",
				"src": "<template>\n  <div ref=\"mounter\" class=\"mounter\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      scene: false\n    }\n  },\n  props: {\n    size: { default () { return { width: 500, height: 500 } } },\n    alpha: { default: true },\n    antialias: { default: true }\n  },\n  created () {\n    this.scene = new THREE.Scene()\n    this.$on('add', (v) => {\n      this.scene.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.scene.remove(v)\n    })\n  },\n  mounted () {\n    this.$emit('scene', this.scene)\n  }\n}\n</script>\n\n<style scoped>\n.mounter {\n  display: none;\n}\n</style>\n"
			},
			{
				"path": "@/webgl/System/PerspectiveCamera.vue",
				"src": "<script>\nvar THREE = window.THREE;\nexport default {\n  abstract: true,\n  render () {\n    return null\n  },\n  props: ['fov', 'aspect', 'near', 'far', 'position'],\n  data () {\n    return {\n      camera: null\n    }\n  },\n  created () {\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far)\n\n    if (this.position) {\n      this.camera.position.x = this.position.x\n      this.camera.position.y = this.position.y\n      this.camera.position.z = this.position.z\n    }\n    this.$emit('camera', this.camera)\n  },\n  watch: {\n    position () {\n      if (this.position) {\n        this.camera.position.x = this.position.x\n        this.camera.position.y = this.position.y\n        this.camera.position.z = this.position.z\n      }\n    },\n    aspect () {\n      if (this.camera) {\n        this.camera.aspect = this.aspect\n        this.camera.updateProjectionMatrix()\n      }\n    }\n  }\n}\n</script>\n\n<style scoped>\n.perspective-camera{\n  display: none;\n}\n</style>\n"
			},
			{
				"path": "@/webgl/System/Raycaster.vue",
				"src": "<template>\n<div></div>\n</template>\n\n<script>\n\nexport default {\n  data () {\n    return {\n      rAFID: 0,\n      mouse: null,\n      raycast () {},\n      clean () {},\n      intersects: []\n    }\n  },\n  props: {\n    scene: {},\n    camera: {},\n    toucher: {}\n  },\n  created () {\n  },\n  activated () {\n    var raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    \n    this.toucher.addEventListener('mousemove', this.handleMV, false);\n    this.toucher.addEventListener('click', this.handleClick, false);\n    this.clean = () => {\n      this.toucher.removeEventListener('click', this.handleClick, false);\n      this.toucher.removeEventListener('mousemove', this.handleMV);\n    }\n    \n    var raycast = () => {\n      var mouse = this.mouse;\n      var scene = this.scene;\n      var camera = this.camera;\n      \n      var restore = [];\n      this.scene.traverse((ele) => {\n        if (ele.$skipRayCast) {\n          restore.push({\n            parent: ele.parent,\n            ele: ele\n          })\n          ele.parent.remove(ele);\n        }\n      })\n      \n      \n    \t// update the picking ray with the camera and mouse position\n    \traycaster.setFromCamera( mouse, camera );\n    \t// calculate objects intersecting the picking ray\n    \tvar intersects = raycaster.intersectObjects( scene.children, true );\n    \t\n    \trestore.forEach((item) => {\n        item.parent.add(item.ele);\n      })\n    \t\n    \treturn intersects\n  \t};\n    this.raycast = raycast; \n    \n    var rAF = () => {\n      this.rAFID = window.requestAnimationFrame(rAF);\n      // this.raycast();\n    }\n    this.rAFID = window.requestAnimationFrame(rAF);\n  },\n  deactivated () {\n    window.cancelAnimationFrame(this.rAFID);\n    this.clean();\n  },\n  methods: {\n    handleClick (event) {\n      this.$emit('click', {\n        event,\n        intersects: this.raycast()\n      })\n    },\n    handleMV (event) {\n      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t    this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    }\n    \n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/webgl/Material/MeshPhongMaterial.vue",
				"src": "<template>\n<div class=\"mesh-phong-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return Math.random() * 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  created () {\n    this.material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(this.color),\n      specular: new THREE.Color(0x111111),\n      shininess: 50\n    })\n    this.$parent.$emit('material', this.material)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/webgl/Material/ShaderMaterial.vue",
				"src": "<template>\n<div class=\"mesh-basic-material\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  data () {\n    return {\n      material: false\n    }\n  },\n  props: {\n    vs: {\n      default:\n`void main ( void ) {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n}`\n    },\n    fs: {\n      default:\n`void main () {\n  gl_FragColor = vec4(vec3(0.5), 1.0);\n}`\n    },\n    uniforms: {\n      default () {\n        return {}\n      }\n    }\n  },\n  watch: {\n    vs () { this.initShader() },\n    fs () { this.initShader() },\n    uniforms () { this.initShader() }\n  },\n  mounted () {\n    this.initShader()\n  },\n  methods: {\n    initShader () {\n      try {\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            ...this.uniforms// ,\n            // ...THREE.UniformsUtils.merge([\n            //   THREE.UniformsLib.common,\n            //   THREE.UniformsLib.aomap,\n            //   THREE.UniformsLib.lightmap,\n            //   THREE.UniformsLib.emissivemap,\n            //   THREE.UniformsLib.bumpmap,\n            //   THREE.UniformsLib.normalmap,\n            //   THREE.UniformsLib.displacementmap,\n            //   THREE.UniformsLib.fog,\n            //   THREE.UniformsLib.lights,\n            //   THREE.UniformsLib.shadowmap,\n            //   {\n            //     flipEnvMap: {\n            //       value: 1\n            //     },\n            //     emissive: {\n            //       value: new THREE.Color(0x000000)\n            //     },\n            //     specular: {\n            //       value: new THREE.Color(0x111111)\n            //     },\n            //     shininess: {\n            //       value: 30\n            //     },\n            //     envMap: {\n            //       // value: cubeCamera.renderTarget\n            //     }\n            //   }\n            // ])\n          },\n          vertexShader: this.vs || this.$options.props.vs.default,\n          fragmentShader: this.fs || this.$options.props.fs.default\n        })\n        this.$parent.$emit('material', this.material)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/webgl/Element/PointLight.vue",
				"src": "<template>\n  <div class=\"light-point\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\n\nexport default {\n  props: {\n    color: {\n      default () {\n        return 0xffffff\n      }\n    }\n  },\n  data () {\n    return {\n      light: false\n    }\n  },\n  mounted () {\n    this.light = new THREE.PointLight({ color: new THREE.Color(this.color) })\n    this.$emit('element', this.light)\n    this.$parent.$emit('add', this.light)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.light)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/webgl/Element/Object3D.vue",
				"src": "<template>\n<div class=\"object-3d\"><slot></slot></div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  data () {\n    return {\n      object3d: false\n    }\n  },\n  props: {\n    visible: { default: true },\n    px: { default: 0 },\n    py: { default: 0 },\n    pz: { default: 0 },\n\n    sx: { default: 1 },\n    sy: { default: 1 },\n    sz: { default: 1 },\n\n    rx: { default: 0 },\n    ry: { default: 0 },\n    rz: { default: 0 }\n  },\n  watch: {\n    visible () { this.object3d.setVisible(this.visible) },\n    px () { this.updatePosition('x', this.px) },\n    py () { this.updatePosition('y', this.py) },\n    pz () { this.updatePosition('z', this.pz) },\n\n    sx () { this.updateScale('x', this.sx) },\n    sy () { this.updateScale('y', this.sy) },\n    sz () { this.updateScale('z', this.sz) },\n\n    rx () { this.updateRotation('x', this.rx) },\n    ry () { this.updateRotation('y', this.ry) },\n    rz () { this.updateRotation('z', this.rz) }\n  },\n  created () {\n    this.object3d = new THREE.Object3D()\n    this.$emit('element', this.object3d)\n    this.object3d.visible = true\n    this.updatePosition()\n    this.updateScale()\n    this.updateRotation()\n    this.$on('add', (v) => {\n      this.object3d.add(v)\n    })\n    this.$on('remove', (v) => {\n      this.object3d.remove(v)\n    })\n  },\n  mounted () {\n    this.$parent.$emit('add', this.object3d)\n  },\n  beforeDestroy () {\n    this.$parent.$emit('remove', this.object3d)\n  },\n  methods: {\n    updatePosition (key, val) {\n      if (key) {\n        this.object3d.position[key] = val\n      } else {\n        this.object3d.position.set(this.px, this.py, this.pz)\n      }\n    },\n    updateScale (key, val) {\n      if (key) {\n        this.object3d.scale[key] = val\n      } else {\n        this.object3d.scale.set(this.sx, this.sy, this.sz)\n      }\n    },\n    updateRotation (key, val) {\n      if (key) {\n        this.object3d.rotation[key] = val\n      } else {\n        this.object3d.rotation.set(this.rx, this.ry, this.rz)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/webgl/Element/Points.vue",
				"src": "<template>\n  <div class=\"points\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\n\nexport default {\n  props: {\n    position: {}\n  },\n  data () {\n    return {\n      element: false,\n      points: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.points = new THREE.Points()\n    this.$parent.$emit('add', this.points)\n    this.$emit('element', this.points)\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.points) {\n        this.points.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.points) {\n        this.points.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.points)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/webgl/Element/Mesh.vue",
				"src": "<template>\n  <div class=\"mesh\">\n    <slot>\n    </slot>\n  </div>\n</template>\n\n<script>\nvar THREE = window.THREE;\nexport default {\n  props: {\n  },\n  data () {\n    return {\n      element: false,\n      mesh: false,\n      material: false,\n      geometry: false\n    }\n  },\n  created () {\n    this.element = this.mesh = new THREE.Mesh()\n    this.$parent.$emit('add', this.mesh)\n    this.$emit('element', this.mesh)\n\n    this.$on('material', (v) => {\n      this.material = v\n      this.tryUpdateMaterial()\n    })\n    this.$on('geometry', (v) => {\n      this.geometry = v\n      this.tryUpdateGeometry()\n    })\n  },\n  beforeDestroy () {\n    this.uninstall()\n  },\n  methods: {\n    tryUpdateGeometry (v) {\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry\n      }\n    },\n    tryUpdateMaterial (v) {\n      if (this.mesh) {\n        this.mesh.material = this.material\n      }\n    },\n    uninstall () {\n      this.$parent.$emit('remove', this.mesh)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/webgl/Geo/SphereBufferGeometry.vue",
				"src": "<template>\n  <div class=\"geo-sphere\"></div>\n</template>\n\n<script>\nvar THREE = window.THREE\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.SphereBufferGeometry(2, 64, 64)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/webgl/Geo/BoxBufferGeometry.vue",
				"src": "<template>\n  <div class=\"geo-box\"></div>\n</template>\n\n<script>\nimport THREE from '@/three.js'\nexport default {\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  mounted () {\n    let geometry = new THREE.BoxBufferGeometry(2, 2, 2, 50, 50, 50)\n    this.$parent.$emit('geometry', geometry)\n  }\n}\n</script>\n\n<style>\n\n</style>\n"
			},
			{
				"path": "@/shader/Simple/vs.vert",
				"src": "varying vec3 vPos;\nuniform float time;\n\nmat3 rotateX(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n}\n\nmat3 rotateY(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\n\nmat3 rotateZ(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, s, 0.0,\n        -s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nvoid main (void) {\n  vec3 newPos = position;\n  newPos.x += tan(newPos.x * 10.0 + time);\n  newPos.y += tan(newPos.y * 10.0 + time);\n  \n  newPos = rotateZ(time) * newPos;\n  \n  vPos = position;\n  \n  vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}"
			},
			{
				"path": "@/shader/Simple/fs.frag",
				"src": "varying vec3 vPos;\n\nvoid main () {\n  gl_FragColor = vec4(vec3(1.0 - vPos), 1.0);\n}"
			},
			{
				"path": "@/shader/Fling/vs.vert",
				"src": "varying vec3 vPos;\nuniform float time;\n\nvoid main (void) {\n  vPos = position;\n  vPos.x = vPos.x + sin(vPos.x + time);\n  vPos.y = vPos.y + cos(vPos.y + time);\n  vPos.z = vPos.z + tan(vPos.z + time);\n  \n  vec4 mvPosition = modelViewMatrix * vec4(vPos, 1.0);\n  vec4 outputPos = projectionMatrix * mvPosition;\n  gl_Position = outputPos;\n  gl_PointSize = 1.0;\n}\n"
			},
			{
				"path": "@/three.js",
				"src": "var THREE = window.THREE\nexport default THREE\n"
			},
			{
				"path": "@/math-parser.js",
				"src": "var Parser = window.Parser\nexport default Parser\n"
			},
			{
				"path": "@/event-dispatcher.js",
				"src": "/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nfunction EventDispatcher() {}\n\nObject.assign( EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tvar array = listenerArray.slice( 0 );\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { EventDispatcher };\n"
			},
			{
				"path": "@/general-tools.js",
				"src": "import { EventDispatcher } from '@/event-dispatcher.js'\n\nexport const fuller = ({ planeZ, camera }) => {\n  var cameraZ = camera.position.z\n  var distance = cameraZ - planeZ\n  var aspect = window.innerWidth / window.innerHeight\n  var vFov = camera.fov * Math.PI / 180\n  var planeHeightAtDistance = 2 * Math.tan(vFov / 2) * distance\n  var planeWidthAtDistance = planeHeightAtDistance * aspect\n  /*\n  let dist = camera.position.z - mesh.position.z\n  let height = ... // desired height to fit\n  camera.fov = 2 * Math.atan(height / (2 * dist)) * (180 / Math.PI)\n  camera.updateProjectionMatrix()\n  */\n  return {\n    aspect: planeWidthAtDistance / planeHeightAtDistance,\n    vmin: Math.min(planeWidthAtDistance, planeHeightAtDistance),\n    vmax: Math.max(planeWidthAtDistance, planeHeightAtDistance),\n    width: planeWidthAtDistance,\n    height: planeHeightAtDistance\n  }\n}\n\nexport const makeOri = () => {\n  var ori = {\n    sx: 0,\n    sy: 0,\n    dx: 0,\n    dy: 0,\n    x: 0,\n    y: 0,\n    xx: 0,\n    yy: 0\n  }\n  function handleOrientation (event) {\n    var x = event.beta - 45// In degree in the range [-180,180]\n    var y = event.gamma // In degree in the range [-90,90]\n\n    if (window.innerWidth > window.innerHeight) {\n      var t = x\n      x = y\n      y = t\n    }\n\n    if (!ori.sx) {\n      ori.sx = x\n      ori.sy = y\n    }\n\n    ori.dx = x - ori.sx\n    ori.dy = y - ori.sy\n\n    ori.sx = x\n    ori.sy = y\n\n    ori.xx = (x / 180) % 1\n    ori.yy = (y / 90) % 1\n  }\n\n  window.addEventListener('deviceorientation', handleOrientation, false)\n\n  return ori\n}\n\nexport function DomToucher ({ toucher }) {\n  this.toucher = toucher\n  var ui = this.state = {\n    disabled: false,\n    deltaX: -0.0,\n    deltaY: -0.0,\n    addon: 0.0016667,\n    mass: 5.0,\n    inertia: 1.0,\n    inc: 0,\n    aX: 0,\n    aY: 0,\n    inX: 0,\n    inY: 0,\n    isMD: false,\n\n    _: {\n      tsTheta: 0,\n      tsX: 0,\n      tsY: 0\n    },\n    throttleID: 0\n  }\n  var update = { type: 'update', state: this.state }\n  var end = { type: 'end', state: this.state }\n  var click = { type: 'click', state: this.state }\n  var throttledSim = { type: 'throttledSim', state: this.state }\n  var loop = { type: 'loop', state: this.state }\n  this.onWHL = (evt) => {\n    if (ui.disabled) { return }\n    evt.preventDefault()\n\n    ui.deltaX = -event.deltaX * 0.02\n    ui.deltaY = -event.deltaY * 0.02\n\n    // if (event.deltaX) {\n    //   ui.deltaTheta = -event.deltaX * 0.02 / (Math.PI * 2)\n    // }\n    // if (event.deltaY) {\n    //   ui.deltaTheta = -event.deltaY * 0.02 / (Math.PI * 2)\n    // }\n\n    // initia speed\n    ui.inertia = ui.mass\n  }\n\n  this.onMD = (evt) => {\n    ui.isMD = true\n    \n    onPanStart(evt)\n  }\n  this.onMU = (evt) => {\n    ui.isMD = false\n    \n    onPanEnd(evt)\n  }\n\n  var onPointerMove = (ppp) => {\n    ui.pX = ppp.clientX\n    ui.pY = ppp.clientY\n    ui.cX = (ui.pX / ui.conW) * 2 - 1\n    ui.cY = (ui.pY / ui.conH) * 2 - 1\n\n    if (ui.conW >= ui.conH) {\n      let a = ui.conW / ui.conH\n      ui.cX = ui.cX * a\n      ui.cY = ui.cY\n    } else {\n      let a = ui.conH / ui.conW\n      ui.cX = ui.cX\n      ui.cY = ui.cY * a\n    }\n  }\n  // pan around\n  var onPanStart = (t1) => {\n  // var t1 = touch[0]\n  // var x = t1.pageX\n  // var y = t1.pageY\n    var x = t1.clientX\n    var y = t1.clientY\n\n    // ui.cX = (x / window.innerWidth) * 2 - 1\n    // ui.cY = (y / window.innerHeight) * 2 - 1\n\n    // var w = ui.conW\n    // var h = ui.conH\n    // var cX = (x - (w / 2)) / w\n    // var cY = (y - (h / 2)) / h\n    // var theta = Math.atan2(cY, cX)\n\n    // pan\n    ui._.tsX = x\n    ui._.tsY = y\n\n    // ui.inertia *= 0.05\n    ui.isIn = true\n  }\n\n  var onPanMove = (t1) => {\n    // var t1 = touch[0]\n    // var x = t1.pageX\n    // var y = t1.pageY\n    \n    var x = t1.clientX\n    var y = t1.clientY\n\n    // ui.cX = (x / window.innerWidth) * 2 - 1\n    // ui.cY = (y / window.innerHeight) * 2 - 1\n\n    //\n    ui.deltaX = (x - ui._.tsX) * 0.05\n    ui.deltaY = (y - ui._.tsY) * 0.05\n\n    ui._.tsX = x\n    ui._.tsY = y\n\n    ui.aX += ui.deltaX\n    ui.aY += ui.deltaY\n\n    ui.inertia = ui.mass\n  }\n\n  var onPanEnd = (t1) => {\n    ui.isIn = false\n  }\n\n  this.onMM = (evt) => {\n    if (ui.disabled) { return }\n    onPointerMove(evt)\n  \n    if (!ui.isMD) { return }\n    onPanMove(evt)\n  }\n  this.onTS = (evt) => {\n    if (ui.disabled) { return }\n    // console.log(evt)\n    // evt.target.style.outline = 'red solid 3px'\n    // if (evt.target === toucher) {\n    //   evt.preventDefault()\n    // }\n    var t = evt.touches\n    if (t.length >= 1) {\n      onPanStart(t[0])\n      // onThetaStart(t[0])\n    }\n    ui.touches = t.length\n  }\n  this.onTM = (evt) => {\n    if (ui.disabled) { return }\n    evt.preventDefault()\n    var t = evt.touches\n\n    if (t.length >= 1) {\n      onPanMove(t[0])\n      // onThetaMove(t[0])\n      onPointerMove(t[0])\n    }\n  }\n  this.onTE = (evt) => {\n    if (ui.disabled) { return }\n    // evt.preventDefault()\n    var t = evt.touches\n\n    if (t.length === 1) {\n      onPanEnd(t[0])\n      this.dispatchEvent(click)\n    }\n    ui.touches = t.length\n  }\n  this.onResize = () => {\n    ui.conW = toucher.clientWidth\n    ui.conH = toucher.clientHeight\n  }\n  var sim = () => {\n    if (ui.disabled) { return }\n    ui.inc += ui.addon\n    if (ui.inertia > 0.01) {\n      //\n      ui.inX = (ui.deltaX * ui.inertia)\n      ui.inY = (ui.deltaY * ui.inertia)\n      ui.aX += ui.inX\n      ui.aY += ui.inY\n\n      //\n      // ui.inTheta = ((ui.deltaTheta * ui.inertia) * 0.45)\n      // ui.aTheta += ui.inTheta\n\n      // inertia\n      ui.inertia *= 0.98\n\n      ui.canFireEnd = true\n      this.dispatchEvent(update)\n    }\n    if (ui.inertia < 0.9 && ui.canFireEnd) {\n      ui.canFireEnd = false\n      this.dispatchEvent(end)\n    }\n\n    this.dispatchEvent(loop)\n    ui.throttleID++\n    if (ui.throttleID % 16 === 0) {\n      this.dispatchEvent(throttledSim)\n    }\n  }\n  this.setup = () => {\n    var rAFID = 0\n    var rAF = () => {\n      rAFID = window.requestAnimationFrame(rAF)\n      sim()\n    }\n    rAFID = window.requestAnimationFrame(rAF)\n\n    this.onResize()\n\n    toucher.addEventListener('mousedown', this.onMD, false)\n    toucher.addEventListener('mousemove', this.onMM, false)\n    toucher.addEventListener('mouseup', this.onMU, false)\n\n    toucher.addEventListener('touchstart', this.onTS, false)\n    toucher.addEventListener('touchmove', this.onTM, false)\n    toucher.addEventListener('touchend', this.onTE, false)\n\n    window.addEventListener('wheel', this.onWHL, false)\n    window.addEventListener('resize', this.onResize, false)\n\n    return {\n      clean: () => {\n        toucher.removeEventListener('mousemove', this.onMM)\n        toucher.removeEventListener('mousedown', this.onMD)\n        toucher.removeEventListener('mouseup', this.onMU)\n\n        toucher.removeEventListener('touchstart', this.onTS)\n        toucher.removeEventListener('touchmove', this.onTM)\n        toucher.removeEventListener('touchend', this.onTE)\n\n        window.removeEventListener('wheel', this.onWHL)\n\n        window.removeEventListener('resize', this.onResize)\n        window.cancelAnimationFrame(rAFID)\n      }\n    }\n  }\n\n  var { clean } = this.setup()\n  this.clean = clean\n}\n\n// Mixing the EventDispatcher.prototype with the custom object prototype\nObject.assign(DomToucher.prototype, EventDispatcher.prototype)\n"
			},
			{
				"path": "@/webgl/sample.vue",
				"src": "<template>\n  <div class=\"full\">\n\n    <Renderer\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full touch-surface\"></div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simpleVS\" :fs=\"simpleFS\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simpleVS,\n      simpleFS,\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.full{\n  width: 100%;\n  height: 100%;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n</style>\n"
			},
			{
				"path": "@/archive/sample.vue",
				"src": "<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    \n    </Renderer>\n    \n    <!-- <div class=\"full touch-surface\" @click=\"wonder\">\n      12345\n    </div> -->\n    \n    <div class=\"full layer\">\n      12345\n    </div>\n\n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 10 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D pz=\"0\">\n        <Points>\n          <SphereBufferGeometry />\n          <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n        </Points>\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Fling/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  computed: {\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.001;\n      \n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  data () {\n    return {\n      animatable: {\n        time: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  }\n}\n</script>\n\n<style scoped>\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.layer {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n</style>\n"
			},
			{
				"path": "@/lib/scroller.js",
				"src": "export const make = ({ scroller,  content }) => {\n  var api = {}\n  \n  var scrollerRect, contentRect;\n  var scrollResize = () => {\n    scrollerRect = scroller.getBoundingClientRect();\n    contentRect = content.getBoundingClientRect();\n  }\n  scrollResize()\n  window.addEventListener('resize', scrollResize, false)\n  \n  api.onScroll = (evt) => {\n    api.state.scrollAmount = evt.target.scrollTop;\n  }\n  \n  var updateScroller = () => {\n    if (!contentRect) { return }\n    if (!scrollerRect) { return }\n    \n    var contentLength = contentRect.height;\n    var scrollerHeight = scrollerRect.height;\n    \n    var totalScroll = contentLength - scrollerHeight;\n\n    var progress = api.state.scrollAmount / totalScroll;\n\n    api.state.progress = progress;\n  }\n  \n  var _internal = {\n    amount: 0,\n    inertia: 3,\n    lastValue: 0\n  }\n  \n  api.state = {\n    progress: 0,\n    get scrollAmount () {\n      return _internal.amount\n    },\n    set scrollAmount (v) {\n      _internal.lastValue = v\n      _internal.inertia = 1.0\n    }\n  }\n  \n  let rAFID\n  let rAF = function () {\n    rAFID = window.requestAnimationFrame(rAF);\n    updateScroller()\n    let diff = _internal.lastValue - _internal.amount\n    if (Math.abs((diff)) > 0) {\n      _internal.amount += diff * 0.035 * _internal.inertia\n    }\n    _internal.inertia *= 0.99\n  }\n  \n  rAFID = window.requestAnimationFrame(rAF)\n  \n  return api\n}\n"
			},
			{
				"path": "@/pages/YO2.vue",
				"src": "<template>\n  <div class=\"full\">\n\n    <Renderer\n      class=\"pos-rel full\"\n      ref=\"renderer\"\n      :size=\"size\"\n      @renderer=\"(v) => { renderer = v }\"\n    >\n    </Renderer>\n    \n    <div class=\"full layer\" ref=\"domScroller\" @scroll=\"scl.onScroll\">\n      <div class=\"dom-content\" ref=\"domContent\">\n        <h1  class=\"center\">\n          Yo Teach 2.0\n        </h1>\n        \n        <div class=\"center\">\n          <router-link to=\"/\">Back</router-link>\n        </div>\n        \n        <br />\n        \n        <div class=\"center\">\n            <iframe style=\"width: 80vw; height: 80vh;\" width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/G9rHH5XwmRg\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n        </div>\n      </div>\n    </div>\n    \n    <PerspectiveCamera\n      :fov=\"75\"\n      :aspect=\"size.aspect\"\n      :near=\"1\"\n      :far=\"1000\"\n      :position=\"{ x: 0, y: 0, z: 20 }\"\n      \n      @camera=\"(v) => { camera = v; }\"\n    />\n\n    <Scene @scene=\"(v) => { scene = v }\">\n      <Object3D pz=\"10\">\n        <PointLight />\n      </Object3D>\n      \n      <Object3D v-if=\"scl\" :py=\"scl.state.progress * 10 * 2 * 1.3\">\n        \n        <Object3D :ry=\"scl.state.progress * PI * 2.0\" :px=\"-5.553\" :py=\"10 * -1 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :px=\"5.553\" :py=\"10 * 0 * -1.3\" :pz=\"-10\" :ry=\"scl.state.progress * PI * 2.0\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :rx=\"scl.state.progress * PI * 2.0\" :px=\"-5.553\" :py=\"10 * 1 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n        \n        <Object3D :rx=\"scl.state.progress * PI * 2.0\" :rx=\"scl.state.progress * PI * 2.0\"  :px=\"5.553\" :py=\"10 * 2 * -1.3\" :pz=\"-10\">\n          <Points @element=\"(v) => { v.frustumCulled = false; }\">\n            <BoxBufferGeometry />\n            <ShaderMaterial :vs=\"simple.vs\" :fs=\"simple.fs\" :uniforms=\"animatable\" />\n          </Points>\n        </Object3D>\n\n\n      </Object3D>\n      \n    </Scene>\n\n  </div>\n</template>\n\n<script>\nimport Bundle from '@/webgl/Bundle.js';\nimport simpleVS from '@/shader/Simple/vs.vert'\nimport simpleFS from '@/shader/Simple/fs.frag'\n\nimport * as Scroller from '@/lib/scroller.js'\n\nexport default {\n  components: {\n    ...Bundle\n  },\n  methods: {\n    renderWebGL () {\n      this.animatable.time.value = window.performance.now() * 0.0001;\n\n      if (this.scene && this.camera && this.renderer) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    wonder () {\n      window.alert('click')\n    }\n  },\n  computed: {\n  },\n  data () {\n    return {\n      onScroll () {},\n      updateScroller () {},\n      scl: false,\n      progress: 0,\n      PI: Math.PI,\n      animatable: {\n        time: { value: 0 },\n        progress: { value: 0 }\n      },\n      simple: {\n        vs: simpleVS,\n        fs: simpleFS\n      },\n      size: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      },\n      renderer: false,\n      scene: false,\n      camera: false\n    }\n  },\n  created () {\n    \n  },\n  mounted () {\n    this.scl = Scroller.make({ scroller: this.$refs['domScroller'], content: this.$refs['domContent'] })\n    \n    window.addEventListener('resize', () => {\n      this.size = {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        aspect: window.innerWidth / window.innerHeight\n      }\n    })\n    this.scene.background = new THREE.Color(0x000000);\n    \n    var self = this\n    function loop () {\n      self.rAFID = window.requestAnimationFrame(loop)\n      self.renderWebGL()\n    }\n    self.rAFID = window.requestAnimationFrame(loop)\n  },\n  beforeDestroy () {\n    window.cancelAnimationFrame(this.rAFID)\n  }\n}\n</script>\n\n<style scoped>\n.taller{\n  height: 15vh;\n}\n.pos-rel{\n  position: relative;\n}\n.full{\n  width: 100%;\n  height: 100%;\n}\n.renderer{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.layer {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.touch-surface{\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  z-index: 100;\n}\n.dom-content{\n  max-width: 375px;\n  margin: 0px auto;\n  color: white;\n}\n.dom-content a {\n  color: white;\n}\n\n.center{\n  display: flex;\n  justify-content: center;\n}\n.shadow{\n  text-shadow: 1px 1px 0px black;\n}\n\n</style>\n\n"
			},
			{
				"readOnly": true,
				"path": "@/hot-data.access.js",
				"src": "import root from '@/hot-data.hydrate.json'\n\nexport const state = {\n  root: {\n    ...root\n  }\n}\n\nexport const getBycIDeID = ({ cID, eID }) => {\n  if (!state.root.dbs) {\n    state.root.dbs = []\n  }\n  let collection = state.root.dbs.find(c => c.cID === cID) || { entries: [] }\n  if (!collection.entries) {\n    collection.entries = []\n  }\n  return collection.entries.find(e => e.eID === eID)\n}\n\nexport const getBycID = ({ cID }) => {\n  if (!state.root.dbs) {\n    state.root.dbs = []\n  }\n  let collection = state.root.dbs.find(c => c.cID === cID)\n  return collection\n}\n\n\nwindow.addEventListener('hot-data-root', (evt) => {\n  console.log('App Got Root Data Update:', evt.detail.detail);\n  var data = evt.detail\n  state.root = data.detail\n}, false);\n\n"
			},
			{
				"readOnly": true,
				"path": "@/hot-data.hydrate.json",
				"src": "{\n\t\"cTrash\": [],\n\t\"dbs\": [\n\t\t{\n\t\t\t\"cID\": \"shaders\",\n\t\t\t\"desc\": \"funfunDB\",\n\t\t\t\"entries\": [\n\t\t\t\t{\n\t\t\t\t\t\"eType\": \"glsl\",\n\t\t\t\t\t\"cID\": \"shaders\",\n\t\t\t\t\t\"eID\": \"box1\",\n\t\t\t\t\t\"note\": \"wakanda\",\n\t\t\t\t\t\"data\": {\n\t\t\t\t\t\t\"inited\": true,\n\t\t\t\t\t\t\"vertexShader\": \"// falala\\n\\nvarying vec3 vPos;\\nuniform float time;\\n\\nmat3 rotateX(float rad) {\\n    float c = cos(rad);\\n    float s = sin(rad);\\n    return mat3(\\n        1.0, 0.0, 0.0,\\n        0.0, c, s,\\n        0.0, -s, c\\n    );\\n}\\n\\nmat3 rotateY(float rad) {\\n    float c = cos(rad);\\n    float s = sin(rad);\\n    return mat3(\\n        c, 0.0, -s,\\n        0.0, 1.0, 0.0,\\n        s, 0.0, c\\n    );\\n}\\n\\nmat3 rotateZ(float rad) {\\n    float c = cos(rad);\\n    float s = sin(rad);\\n    return mat3(\\n        c, s, 0.0,\\n        -s, c, 0.0,\\n        0.0, 0.0, 1.0\\n    );\\n}\\n\\nvoid main (void) {\\n  vec3 newPos = position;\\n  newPos.x += tan(tan(newPos.x * 10.0) + 5.0 * time);\\n  newPos.y += tan(tan(newPos.y * 10.0) + 5.0 * time);\\n  \\n  newPos = rotateZ(time) * newPos;\\n  \\n  vPos = position;\\n  \\n  vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);\\n  vec4 outputPos = projectionMatrix * mvPosition;\\n  gl_Position = outputPos;\\n  gl_PointSize = 1.0;\\n}\\n\\n//\\n\\n\",\n\t\t\t\t\t\t\"fragmentShader\": \"//fafafa\\n\\nuniform float time;\\n\\nvarying vec3 vPos;\\n\\nvoid main () {\\n  gl_FragColor = vec4(vec3(vPos.y, 0.5, vPos.z), 1.0);\\n}\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"eTrash\": []\n\t\t},\n\t\t{\n\t\t\t\"cID\": \"articles\",\n\t\t\t\"desc\": \"\",\n\t\t\t\"entries\": [\n\t\t\t\t{\n\t\t\t\t\t\"eType\": \"article\",\n\t\t\t\t\t\"cID\": \"articles\",\n\t\t\t\t\t\"eID\": \"iremember\",\n\t\t\t\t\t\"note\": \"asd\",\n\t\t\t\t\t\"data\": {\n\t\t\t\t\t\t\"inited\": true,\n\t\t\t\t\t\t\"markdown\": \"EffectNode.com\\n========================\\nEffectNode is LokLok's Personal Coding Platform that can help developers accelerate the production of WebGL WebSites.\\n\\nWebGL Site is adopted by Global Brands to make marketing campaigns and 3D Games.\\n\\nLokLok's WebGL Sites Examples:\\n- NIKE RexFight HK 3D Game\\n- Cl de Peau Beaut 3D Campaign\\n\\nLok wants to share that technology with as many people as possible so that he made EffectNode.com\\n\\nInventions in Effect Node\\n------------------------\\n\\n- 3D Visual Effect and Animation Components\\n - 3D Object Parallax\\n - Momentum Scroll API\\n - Sample Shader Material\\n - More...\\n\\n- Custom Made 3D Components Framework\\n - Open Source\\n - Whitebox Architecture Design\\n - Resuable 3D Visual Object\\n\\n- Hot Data Injection per Keystoke\\n - 50x faster than save, compile and refresh\\n - Realtime updates for...\\n  - 3D Shader Animation\\n  - Markdown to HTML Content\\n  - (3D Layout) comming soon\\n\\n- Time Machine System\\n - Versioning \\n - Auto backup\\n - Timeline Slider to view all versions instantly.\\n\\n- Custom Made Code Compilation System\\n - Support Essential Technology to reproduce a WebGL Marketing Campaign WebSite.\\n - Support Scoped CSS for .vue files\\n - Support Basic Import Export feature for .js and .vue files\\n - Export to Wordpress, Drupal\\n - Export to Single Website\\n - Export as a Banner with a custom div\\n\\n\",\n\t\t\t\t\t\t\"html\": \"<h1 id=\\\"effectnode-com\\\">EffectNode.com</h1>\\n<p>EffectNode is LokLok&#39;s Personal Coding Platform that can help developers accelerate the production of WebGL WebSites.</p>\\n<p>WebGL Site is adopted by Global Brands to make marketing campaigns and 3D Games.</p>\\n<p>LokLok&#39;s WebGL Sites Examples:</p>\\n<ul>\\n<li>NIKE RexFight HK 3D Game</li>\\n<li>Cl de Peau Beaut 3D Campaign</li>\\n</ul>\\n<p>Lok wants to share that technology with as many people as possible so that he made EffectNode.com</p>\\n<h2 id=\\\"inventions-in-effect-node\\\">Inventions in Effect Node</h2>\\n<ul>\\n<li><p>3D Visual Effect and Animation Components</p>\\n<ul>\\n<li>3D Object Parallax</li>\\n<li>Momentum Scroll API</li>\\n<li>Sample Shader Material</li>\\n<li>More...</li>\\n</ul>\\n</li>\\n<li><p>Custom Made 3D Components Framework</p>\\n<ul>\\n<li>Open Source</li>\\n<li>Whitebox Architecture Design</li>\\n<li>Resuable 3D Visual Object</li>\\n</ul>\\n</li>\\n<li><p>Hot Data Injection per Keystoke</p>\\n<ul>\\n<li>50x faster than save, compile and refresh</li>\\n<li>Realtime updates for...</li>\\n<li>3D Shader Animation</li>\\n<li>Markdown to HTML Content</li>\\n<li>(3D Layout) comming soon</li>\\n</ul>\\n</li>\\n<li><p>Time Machine System</p>\\n<ul>\\n<li>Versioning </li>\\n<li>Auto backup</li>\\n<li>Timeline Slider to view all versions instantly.</li>\\n</ul>\\n</li>\\n<li><p>Custom Made Code Compilation System</p>\\n<ul>\\n<li>Support Essential Technology to reproduce a WebGL Marketing Campaign WebSite.</li>\\n<li>Support Scoped CSS for .vue files</li>\\n<li>Support Basic Import Export feature for .js and .vue files</li>\\n<li>Export to Wordpress, Drupal</li>\\n<li>Export to Single Website</li>\\n<li>Export as a Banner with a custom div</li>\\n</ul>\\n</li>\\n</ul>\\n\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"eTrash\": []\n\t\t}\n\t]\n}"
			}
		],
		"date": "Thu Jul 05 2018 06:44:46 GMT+0800 (Hong Kong Standard Time)"
	},
	"backups": []
}